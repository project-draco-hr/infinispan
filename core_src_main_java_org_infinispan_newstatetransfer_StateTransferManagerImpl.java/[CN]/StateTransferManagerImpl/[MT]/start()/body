{
  if (trace) {
    log.tracef("Starting state transfer manager on " + rpcManager.getAddress());
  }
  CacheJoinInfo joinInfo=new CacheJoinInfo(configuration.clustering().hash().consistentHashFactory(),configuration.clustering().hash().hash(),configuration.clustering().hash().numSegments(),configuration.clustering().hash().numOwners(),configuration.clustering().stateTransfer().timeout());
  CacheTopologyHandler handler=new CacheTopologyHandler(){
    @Override public void updateConsistentHash(    CacheTopology cacheTopology){
      doTopologyUpdate(cacheTopology,false);
    }
    @Override public void rebalance(    CacheTopology cacheTopology){
      doTopologyUpdate(cacheTopology,true);
    }
    private void doTopologyUpdate(    CacheTopology cacheTopology,    boolean rebalance){
      if (groupManager != null) {
        ConsistentHash currentCH=cacheTopology.getCurrentCH();
        currentCH=new GroupingConsistentHash(currentCH,groupManager);
        ConsistentHash pendingCH=cacheTopology.getPendingCH();
        if (pendingCH != null) {
          pendingCH=new GroupingConsistentHash(pendingCH,groupManager);
        }
        cacheTopology=new CacheTopology(cacheTopology.getTopologyId(),currentCH,pendingCH);
      }
      topologyId=cacheTopology.getTopologyId();
      rebalanceInProgress=rebalance;
      distributionManager.setCacheTopology(cacheTopology);
      onTopologyUpdate(topologyId,cacheTopology.getReadConsistentHash(),cacheTopology.getWriteConsistentHash());
    }
  }
;
  localTopologyManager.join(cacheName,joinInfo,handler);
}
