{
  if (ctx.isInTxScope()) {
    DeadlockDetectingGlobalTransaction gtx=(DeadlockDetectingGlobalTransaction)ctx.getLockOwner();
    gtx.setLockInterntion(command.getKey());
    gtx.setProcessingThread(Thread.currentThread());
  }
  try {
    return invokeNextInterceptor(ctx,command);
  }
 catch (  InterruptedException ie) {
    if (ctx.isOriginLocal() && ctx.isInTxScope()) {
      lockManager.releaseLocks(ctx);
      Transaction transaction=txManager.getTransaction();
      if (trace)       log.trace("Marking the transaction for rollback! : " + transaction);
      if (transaction == null) {
        throw new IllegalStateException("We're running in a local transaction, there MUST be one " + "associated witht the local thread but none found! " + transaction);
      }
      transaction.setRollbackOnly();
      throw new DeadlockDetectedException("Deadlock request was detected, tx " + transaction + " was marked for rollback");
    }
 else {
      if (trace)       log.trace("Received an interrupt request, but we're not running within deadlock detection scenario, so passing it up the stack",ie);
      throw ie;
    }
  }
}
