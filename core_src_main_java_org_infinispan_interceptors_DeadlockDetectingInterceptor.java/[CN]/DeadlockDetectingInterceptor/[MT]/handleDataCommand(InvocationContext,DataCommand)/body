{
  if (ctx.isInTxScope()) {
    DeadlockDetectingGlobalTransaction gtx=(DeadlockDetectingGlobalTransaction)ctx.getLockOwner();
    gtx.setLockIntention(command.getKey());
    gtx.setProcessingThread(Thread.currentThread());
  }
  try {
    return invokeNextInterceptor(ctx,command);
  }
 catch (  InterruptedException ie) {
    if (ctx.isInTxScope()) {
      lockManager.releaseLocks(ctx);
      if (ctx.isOriginLocal()) {
        Transaction transaction=txManager.getTransaction();
        if (trace)         log.trace("Marking the transaction for rollback! : " + transaction);
        if (transaction == null) {
          throw new IllegalStateException("We're running in a local transaction, there MUST be one " + "associated witht the local thread but none found! (null)");
        }
        transaction.setRollbackOnly();
        txTable.removeLocalTransaction(transaction);
        throw new DeadlockDetectedException("Deadlock request was detected for locally originated tx " + transaction + "; it was marked for rollback");
      }
 else {
        DeadlockDetectingGlobalTransaction gtx=(DeadlockDetectingGlobalTransaction)ctx.getLockOwner();
        gtx.setMarkedForRollback(true);
        throw new DeadlockDetectedException("Deadlock request was detected for remotely originated tx " + gtx + "; it was marked for rollback");
      }
    }
 else {
      if (trace)       log.trace("Received an interrupt request, but we're not running within the scope of a transaction, so passing it up the stack",ie);
      throw ie;
    }
  }
}
