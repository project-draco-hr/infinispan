{
  long start=trace ? System.currentTimeMillis() : 0;
  int replCount=configuration.getNumOwners();
  ConsistentHash newCH=dmi.getConsistentHash();
  ConsistentHash oldCH=ConsistentHashHelper.createConsistentHash(configuration,newCH.getCaches(),leaversHandled,dmi.topologyInfo);
  try {
    log.debug("Starting leave rehash[enabled={0},isReceiver={1},isSender={2}] on node {3}",configuration.isRehashEnabled(),isReceiver,isSender,self);
    if (configuration.isRehashEnabled()) {
      if (isReceiver) {
        try {
          RehashControlCommand cmd=cf.buildRehashControlCommand(PULL_STATE_LEAVE,self,null,oldCH,newCH,leaversHandled);
          log.debug("I {0} am pulling state from {1}",self,providers);
          List<Response> resps=rpcManager.invokeRemotely(providers,cmd,SYNCHRONOUS,configuration.getRehashRpcTimeout(),true);
          log.debug("I {0} received response {1} ",self,resps);
          for (          Response r : resps) {
            if (r instanceof SuccessfulResponse) {
              Map<Object,InternalCacheValue> state=getStateFromResponse((SuccessfulResponse)r);
              log.debug("I {0} am applying state {1} ",self,state);
              dmi.applyState(newCH,state);
            }
          }
        }
  finally {
          RehashControlCommand c=cf.buildRehashControlCommand(LEAVE_REHASH_END,self);
          rpcManager.invokeRemotely(providers,c,ASYNCHRONOUS,configuration.getRehashRpcTimeout(),false);
        }
      }
      if (isSender) {
        dmi.awaitLeaveRehashAcks(receivers,configuration.getStateRetrievalTimeout());
        processAndDrainTxLog(oldCH,newCH,replCount);
        invalidateInvalidHolders(leaversHandled,oldCH,newCH);
      }
    }
  }
 catch (  Exception e) {
    throw new CacheException("Unexpected exception",e);
  }
 finally {
    leavers.removeAll(leaversHandled);
    if (trace)     log.info("Completed leave rehash on node {0} in {1}",self,Util.prettyPrintTime(System.currentTimeMillis() - start));
 else     log.info("Completed leave rehash on node {0}",self);
    for (    Address addr : leaversHandled)     dmi.topologyInfo.removeNodeInfo(addr);
  }
}
