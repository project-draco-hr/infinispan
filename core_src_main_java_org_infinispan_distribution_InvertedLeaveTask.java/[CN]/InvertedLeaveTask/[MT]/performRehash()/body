{
  long start=trace ? System.currentTimeMillis() : 0;
  int replCount=configuration.getNumOwners();
  ConsistentHash newCH=dmi.getConsistentHash();
  ConsistentHash oldCH=ConsistentHashHelper.createConsistentHash(configuration,newCH.getCaches(),leaversHandled,dmi.topologyInfo);
  try {
    log.debug("Starting leave rehash[enabled=%s,isReceiver=%s,isSender=%s] on node %s",configuration.isRehashEnabled(),isReceiver,isSender,self);
    if (configuration.isRehashEnabled()) {
      if (isReceiver) {
        try {
          RehashControlCommand cmd=cf.buildRehashControlCommand(PULL_STATE_LEAVE,self,null,oldCH,newCH,leaversHandled);
          log.debug("I %s am pulling state from %s",self,providers);
          Collection<Response> resps=rpcManager.invokeRemotely(providers,cmd,SYNCHRONOUS,configuration.getRehashRpcTimeout(),true).values();
          log.debug("I %s received response %s ",self,resps);
          for (          Response r : resps) {
            if (r instanceof SuccessfulResponse) {
              Map<Object,InternalCacheValue> state=getStateFromResponse((SuccessfulResponse)r);
              log.debug("I %s am applying state %s ",self,state);
              dmi.applyState(newCH,state);
            }
          }
        }
  finally {
          RehashControlCommand c=cf.buildRehashControlCommand(LEAVE_REHASH_END,self);
          rpcManager.invokeRemotely(providers,c,ASYNCHRONOUS,configuration.getRehashRpcTimeout(),false);
        }
      }
      if (isSender) {
        Set<Address> recCopy=new HashSet<Address>(receivers);
        if (isReceiver) {
          recCopy.remove(self);
        }
        dmi.awaitLeaveRehashAcks(recCopy,configuration.getStateRetrievalTimeout());
        processAndDrainTxLog(oldCH,newCH,replCount);
        invalidateInvalidHolders(leaversHandled,oldCH,newCH);
      }
    }
  }
 catch (  Exception e) {
    throw new CacheException("Unexpected exception",e);
  }
 finally {
    distributionManager.removeLeavers(leaversHandled);
    if (trace)     log.info("Completed leave rehash on node %s in %s",self,Util.prettyPrintTime(System.currentTimeMillis() - start));
 else     log.info("Completed leave rehash on node %s",self);
    for (    Address addr : leaversHandled)     dmi.topologyInfo.removeNodeInfo(addr);
    dmi.rehashInProgress=false;
  }
}
