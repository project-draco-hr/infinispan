{
  long start=currentTimeMillis();
  int replCount=configuration.getNumOwners();
  ConsistentHash newCH=this.distributionManager.getConsistentHash();
  ConsistentHash oldCH=ConsistentHashHelper.createConsistentHash(configuration,newCH.getCaches(),leaversHandled,this.distributionManager.topologyInfo);
  try {
    log.debugf("Starting leave rehash[enabled=%s,isReceiver=%s,isSender=%s] on node %s",configuration.isRehashEnabled(),isReceiver,isSender,self);
    if (isReceiver)     this.distributionManager.getTransactionLogger().blockNewTransactions();
    if (configuration.isRehashEnabled()) {
      if (isReceiver) {
        providers.remove(self);
        try {
          RehashControlCommand cmd=cf.buildRehashControlCommand(PULL_STATE_LEAVE,self,null,oldCH,newCH,leaversHandled);
          log.debugf("I %s am pulling state from %s",self,providers);
          Set<Future<Void>> stateRetrievalProcesses=new HashSet<Future<Void>>(providers.size());
          for (          Address stateProvider : providers) {
            stateRetrievalProcesses.add(statePullExecutor.submit(new LeaveStateGrabber(stateProvider,cmd,newCH)));
          }
          log.trace("State retrieval being processed.");
          for (          Future<Void> f : stateRetrievalProcesses)           f.get();
          log.tracef("State retrieval from %s completed.",providers);
        }
  finally {
          log.tracef("Informing %s that state has been applied.",providers);
          RehashControlCommand c=cf.buildRehashControlCommand(LEAVE_REHASH_END,self);
          rpcManager.invokeRemotely(providers,c,SYNCHRONOUS,configuration.getRehashRpcTimeout(),true);
        }
      }
      if (isSender) {
        Set<Address> recCopy=new HashSet<Address>(receivers);
        recCopy.remove(self);
        this.distributionManager.awaitLeaveRehashAcks(recCopy,configuration.getStateRetrievalTimeout());
        processAndDrainTxLog(oldCH,newCH,replCount);
        invalidateInvalidHolders(leaversHandled,oldCH,newCH);
      }
    }
  }
 catch (  Exception e) {
    throw new CacheException("Unexpected exception",e);
  }
 finally {
    for (    Address addr : leaversHandled)     this.distributionManager.markLeaverAsHandled(addr);
    if (isReceiver)     this.distributionManager.getTransactionLogger().unblockNewTransactions();
    log.completedLeaveRehash(self,prettyPrintTime(currentTimeMillis() - start),this.distributionManager.leavers);
  }
}
