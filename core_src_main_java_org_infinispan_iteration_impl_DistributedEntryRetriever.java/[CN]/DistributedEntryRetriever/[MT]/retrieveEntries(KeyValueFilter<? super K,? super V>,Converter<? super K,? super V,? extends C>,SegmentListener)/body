{
  UUID identifier=UUID.randomUUID();
  if (log.isTraceEnabled()) {
    log.tracef("Processing entry retrieval request with identifier %s with filter %s and converter %s",identifier,filter,converter);
  }
  ConsistentHash hash=getCurrentHash();
  DistributedItr<K,C> itr=new DistributedItr<>(batchSize,identifier,hash);
  Set<Integer> remoteSegments=new HashSet<>();
  AtomicReferenceArray<Set<K>> processedKeys=new AtomicReferenceArray<Set<K>>(hash.getNumSegments());
  for (int i=0; i < processedKeys.length(); ++i) {
    processedKeys.set(i,new ConcurrentHashSet<K>());
    remoteSegments.add(i);
  }
  IterationStatus status=new IterationStatus<>(itr,listener,filter,converter,processedKeys);
  iteratorDetails.put(identifier,status);
  Set<Integer> ourSegments=hash.getPrimarySegmentsForOwner(localAddress);
  remoteSegments.removeAll(ourSegments);
  if (!remoteSegments.isEmpty()) {
    eventuallySendRequest(identifier,status);
  }
  if (!ourSegments.isEmpty()) {
    wireFilterAndConverterDependencies(filter,converter);
    startRetrievingValuesLocal(identifier,ourSegments,status,new SegmentBatchHandler<K,C>(){
      @Override public void handleBatch(      UUID identifier,      boolean complete,      Set<Integer> completedSegments,      Set<Integer> inDoubtSegments,      Collection<CacheEntry<K,C>> entries){
        processData(identifier,localAddress,completedSegments,inDoubtSegments,entries);
      }
    }
);
  }
  return itr;
}
