{
  if (event.isPre()) {
    ConsistentHash beforeHash=event.getConsistentHashAtStart();
    ConsistentHash afterHash=event.getConsistentHashAtEnd();
    currentHash.set(afterHash);
    boolean trace=log.isTraceEnabled();
    if (beforeHash != null && afterHash != null) {
      if (trace) {
        log.tracef("Rehash hashes before %s after %s",beforeHash,afterHash);
      }
      Set<Address> leavers=new HashSet<Address>(beforeHash.getMembers());
      leavers.removeAll(afterHash.getMembers());
      if (!leavers.isEmpty() && trace) {
        log.tracef("Found leavers are %s",leavers);
      }
      for (      Map.Entry<UUID,IterationStatus<?>> details : iteratorDetails.entrySet()) {
        UUID identifier=details.getKey();
        final IterationStatus<?> status=details.getValue();
        Set<Integer> remoteSegments=findMissingRemoteSegments(status.processedKeys,afterHash);
        if (!remoteSegments.isEmpty()) {
          Map.Entry<Address,Set<Integer>> route=findOptimalRoute(remoteSegments,afterHash);
          boolean sendRequest;
          AtomicReference<Address> awaitingResponsefrom=status.awaitingResponseFrom;
          Address waitingFor=awaitingResponsefrom.get();
          if (sendRequest=leavers.contains(waitingFor)) {
            if (trace) {
              log.tracef("Resending new segment request %s for identifier %s since node %s has gone down",route.getValue(),identifier,waitingFor);
            }
          }
 else           if (sendRequest=(waitingFor == null && awaitingResponsefrom.compareAndSet(null,route.getKey()))) {
            if (trace) {
              log.tracef("There is no pending remote request for identifier %s, sending new one for segments %s",identifier,route.getValue());
            }
          }
          if (sendRequest) {
            if (status.ongoingIterator != null) {
              sendRequest(false,route,identifier,status);
            }
 else {
              awaitingResponsefrom.set(null);
              if (trace) {
                log.tracef("Not sending request since iterator has been closed for identifier %s",identifier);
              }
            }
          }
        }
 else {
          details.getValue().awaitingResponseFrom.set(null);
        }
        Set<Integer> processSegments=findMissingLocalSegments(status.processedKeys,afterHash);
        if (!processSegments.isEmpty()) {
          if (trace) {
            log.tracef("Rehash caused our local node to acquire new segments %s for iteration %s processing",processSegments,identifier);
          }
          startRetrievingValuesLocal(identifier,processSegments,status,new SegmentBatchHandler<K,Object>(){
            @Override public void handleBatch(            UUID identifier,            boolean complete,            Set<Integer> completedSegments,            Set<Integer> inDoubtSegments,            Collection<CacheEntry<K,Object>> entries){
              processData(identifier,localAddress,completedSegments,inDoubtSegments,entries);
            }
            @Override public void handleException(            CacheException e){
              status.ongoingIterator.close(e);
            }
          }
);
        }
      }
    }
  }
}
