{
  if (log.isTraceEnabled()) {
    log.tracef("Sending request to %s for identifier %s",route,identifier);
  }
  Address address=route.getKey();
  status.awaitingResponseFrom.set(address);
  Set<Integer> segments=route.getValue();
  Set<K> keysToFilter=new HashSet<K>();
  AtomicReferenceArray<Set<K>> ourEntries=status.processedKeys;
  for (  Integer segment : segments) {
    Set<K> valuesSeen=ourEntries.get(segment);
    if (valuesSeen != null) {
      keysToFilter.addAll(valuesSeen);
    }
  }
  if (log.isTraceEnabled()) {
    if (keysToFilter.isEmpty()) {
      log.tracef("Using provided filter %s",status.filter);
    }
 else {
      log.tracef("Applying filter for %s of keys with provided filter %s",keysToFilter.size(),status.filter);
    }
  }
  if (keysToFilter.isEmpty()) {
    keysToFilter=null;
  }
  EntryRequestCommand<K,V,?> command=commandsFactory.buildEntryRequestCommand(identifier,segments,keysToFilter,status.filter,status.converter,status.flags);
  try {
    RpcOptions options=rpcManager.getRpcOptionsBuilder(sync ? ResponseMode.SYNCHRONOUS : ResponseMode.ASYNCHRONOUS).build();
    Map<Address,Response> responseMap=rpcManager.invokeRemotely(Collections.singleton(address),command,options);
    if (sync) {
      Response response=responseMap.values().iterator().next();
      if (!response.isSuccessful()) {
        Throwable cause=response instanceof ExceptionResponse ? ((ExceptionResponse)response).getException() : null;
        if (log.isTraceEnabled()) {
          log.tracef(cause,"Unsuccessful response received from node %s for %s, must resend to a new node!",route.getKey(),identifier);
        }
        atomicRemove(status.awaitingResponseFrom,address);
        return false;
      }
    }
    return true;
  }
 catch (  SuspectException e) {
    if (log.isTraceEnabled()) {
      log.tracef("Request to %s for %s was suspect, must resend to a new node!",route,identifier);
    }
    atomicRemove(status.awaitingResponseFrom,address);
    return false;
  }
}
