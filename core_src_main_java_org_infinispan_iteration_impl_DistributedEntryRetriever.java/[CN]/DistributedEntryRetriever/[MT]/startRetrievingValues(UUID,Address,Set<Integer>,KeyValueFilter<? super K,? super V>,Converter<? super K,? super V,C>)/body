{
  if (log.isTraceEnabled()) {
    log.tracef("Received entry request for %s from node %s for segments %s",identifier,origin,segments);
  }
  wireFilterAndConverterDependencies(filter,converter);
  startRetrievingValues(identifier,segments,filter,converter,new SegmentBatchHandler<K,C>(){
    @Override public void handleBatch(    UUID identifier,    boolean complete,    Set<Integer> completedSegments,    Set<Integer> inDoubtSegments,    Collection<CacheEntry<K,C>> entries){
      if (cache.getStatus() != ComponentStatus.RUNNING) {
        if (log.isTraceEnabled()) {
          log.tracef("Cache status is no longer running, all segments are now suspect");
        }
        inDoubtSegments.addAll(completedSegments);
        completedSegments.clear();
      }
      if (log.isTraceEnabled()) {
        log.tracef("Sending batch response for %s to origin %s with %s completed segments, %s in doubt segments and %s values",identifier,origin,completedSegments,inDoubtSegments,entries.size());
      }
      EntryResponseCommand command=commandsFactory.buildEntryResponseCommand(identifier,completedSegments,inDoubtSegments,entries);
      rpcManager.invokeRemotely(Collections.singleton(origin),command,rpcManager.getRpcOptionsBuilder(ResponseMode.SYNCHRONOUS).timeout(Long.MAX_VALUE,TimeUnit.SECONDS).build());
    }
  }
);
}
