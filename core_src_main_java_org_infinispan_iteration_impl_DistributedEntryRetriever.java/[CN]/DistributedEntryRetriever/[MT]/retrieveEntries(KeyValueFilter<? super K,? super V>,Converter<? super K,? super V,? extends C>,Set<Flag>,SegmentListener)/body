{
  if (flags != null && flags.contains(Flag.CACHE_MODE_LOCAL)) {
    log.trace("Skipping distributed entry retrieval and processing local only as CACHE_MODE_LOCAL flag was set");
    return super.retrieveEntries(filter,converter,flags,listener);
  }
  ConsistentHash hash=getCurrentHash();
  if (!hash.getMembers().contains(localAddress)) {
    log.trace("Skipping distributed entry retrieval and processing local since we are not part of the consistent hash");
    return super.retrieveEntries(filter,converter,flags,listener);
  }
  UUID identifier=UUID.randomUUID();
  final Converter<? super K,? super V,? extends C> usedConverter=checkForKeyValueFilterConverter(filter,converter);
  if (log.isTraceEnabled()) {
    log.tracef("Processing entry retrieval request with identifier %s with filter %s and converter %s",identifier,filter,usedConverter);
  }
  DistributedItr<K,C> itr=new DistributedItr<>(batchSize,identifier,listener,hash);
  registerIterator(itr,flags);
  Set<Integer> remoteSegments=new HashSet<>();
  AtomicReferenceArray<Set<K>> processedKeys=new AtomicReferenceArray<Set<K>>(hash.getNumSegments());
  for (int i=0; i < processedKeys.length(); ++i) {
    processedKeys.set(i,new ConcurrentHashSet<K>());
    remoteSegments.add(i);
  }
  IterationStatus status=new IterationStatus<>(itr,listener,filter,usedConverter,flags,processedKeys);
  iteratorDetails.put(identifier,status);
  Set<Integer> ourSegments=hash.getPrimarySegmentsForOwner(localAddress);
  remoteSegments.removeAll(ourSegments);
  if (!remoteSegments.isEmpty()) {
    eventuallySendRequest(identifier,status);
  }
  if (!ourSegments.isEmpty()) {
    wireFilterAndConverterDependencies(filter,usedConverter);
    startRetrievingValuesLocal(identifier,ourSegments,status,new SegmentBatchHandler<K,C>(){
      @Override public void handleBatch(      UUID identifier,      boolean complete,      Set<Integer> completedSegments,      Set<Integer> inDoubtSegments,      Collection<CacheEntry<K,C>> entries){
        processData(identifier,localAddress,completedSegments,inDoubtSegments,entries);
      }
    }
);
  }
  return itr;
}
