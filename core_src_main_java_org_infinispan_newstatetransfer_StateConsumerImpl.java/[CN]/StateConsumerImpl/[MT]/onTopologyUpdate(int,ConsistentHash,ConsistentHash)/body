{
  log.debugf("Received new CH: %s",wCh);
  if (trace)   log.tracef("Received new CH: %s",wCh);
synchronized (this) {
    isTopologyUpdate++;
    this.topologyId=topologyId;
  }
  stateTransferLock.setTopologyId(topologyId);
  try {
    Set<Integer> addedSegments=null;
    if (this.rCh == null) {
      this.rCh=rCh;
      this.wCh=wCh;
      if (configuration.clustering().stateTransfer().fetchInMemoryState()) {
        addedSegments=this.wCh.getSegmentsForOwner(rpcManager.getAddress());
      }
    }
 else {
      Set<Integer> oldSegments=this.rCh.getMembers().contains(rpcManager.getAddress()) ? this.rCh.getSegmentsForOwner(rpcManager.getAddress()) : new HashSet<Integer>();
      this.rCh=rCh;
      this.wCh=wCh;
      Set<Integer> newSegments=this.wCh.getSegmentsForOwner(rpcManager.getAddress());
      Set<Integer> removedSegments=new HashSet<Integer>(oldSegments);
      removedSegments.removeAll(newSegments);
      discardSegments(removedSegments);
      if (configuration.clustering().stateTransfer().fetchInMemoryState()) {
        addedSegments=new HashSet<Integer>(newSegments);
        addedSegments.removeAll(oldSegments);
        Set<Address> members=new HashSet<Address>(this.rCh.getMembers());
synchronized (this) {
          for (          Address source : transfersBySource.keySet()) {
            if (!members.contains(source)) {
              List<InboundTransferTask> inboundTransfers=transfersBySource.remove(source);
              if (inboundTransfers != null) {
                for (                InboundTransferTask inboundTransfer : inboundTransfers) {
                  for (                  int segmentId : inboundTransfer.getSegments()) {
                    transfersBySegment.remove(segmentId);
                    addedSegments.add(segmentId);
                  }
                }
              }
            }
          }
        }
      }
    }
    if (addedSegments != null && !addedSegments.isEmpty()) {
      stateTransferLock.commandsExclusiveLock();
      try {
        addTransfers(addedSegments);
      }
  finally {
        stateTransferLock.commandsExclusiveUnlock();
      }
    }
  }
  finally {
synchronized (this) {
      isTopologyUpdate--;
      if (isTopologyUpdate == 0 && !isStateTransferInProgress()) {
        stateTransferManager.notifyEndOfStateTransfer(topologyId);
      }
    }
  }
}
