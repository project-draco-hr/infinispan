{
  log.debugf("Received new CH: %s",newCh);
  this.topologyId=topologyId;
  Set<Integer> addedSegments=null;
  if (currentCh == null) {
    currentCh=newCh;
    if (configuration.clustering().stateTransfer().fetchInMemoryState()) {
      addedSegments=currentCh.getSegmentsForOwner(rpcManager.getAddress());
    }
  }
 else {
    Set<Integer> oldSegments=currentCh.getSegmentsForOwner(rpcManager.getAddress());
    currentCh=newCh;
    Set<Integer> newSegments=currentCh.getSegmentsForOwner(rpcManager.getAddress());
    Set<Integer> removedSegments=new HashSet<Integer>(oldSegments);
    removedSegments.removeAll(newSegments);
    discardSegments(removedSegments);
    if (configuration.clustering().stateTransfer().fetchInMemoryState()) {
      addedSegments=new HashSet<Integer>(newSegments);
      addedSegments.removeAll(oldSegments);
      Set<Address> members=new HashSet<Address>(currentCh.getMembers());
synchronized (this) {
        for (        Address source : transfersBySource.keySet()) {
          if (!members.contains(source)) {
            List<InboundTransferTask> inboundTransfers=transfersBySource.remove(source);
            if (inboundTransfers != null) {
              for (              InboundTransferTask inboundTransfer : inboundTransfers) {
                for (                int segmentId : inboundTransfer.getSegments()) {
                  transfersBySegment.remove(segmentId);
                  addedSegments.add(segmentId);
                }
              }
            }
          }
        }
      }
    }
  }
  if (addedSegments != null) {
    stateTransferLock.commandsExclusiveLock();
    try {
      addTransfers(addedSegments);
    }
  finally {
      stateTransferLock.commandsExclusiveUnlock();
    }
  }
}
