{
  log.debugf("Adding state transfer for segments: %s",segments);
  Set<Integer> segmentsToProcess=new HashSet<Integer>(segments);
  Set<Address> faultyMembers=new HashSet<Address>();
synchronized (this) {
    while (!segmentsToProcess.isEmpty()) {
      Map<Address,Set<Integer>> segmentsBySource=new HashMap<Address,Set<Integer>>();
      for (      int segmentId : segmentsToProcess) {
        if (transfersBySegment.containsKey(segmentId)) {
          throw new IllegalArgumentException("Cannot have more than one transfer for segment " + segmentId);
        }
        Address source=pickSourceOwner(segmentId,faultyMembers);
        if (source == null) {
          log.errorf("No owners found for segment %d",segmentId);
        }
 else {
          Set<Integer> segs=segmentsBySource.get(source);
          if (segs == null) {
            segs=new HashSet<Integer>();
            segmentsBySource.put(source,segs);
          }
          segs.add(segmentId);
        }
      }
      Set<Integer> failedSegments=new HashSet<Integer>();
      for (      Address source : segmentsBySource.keySet()) {
        Set<Integer> segs=segmentsBySource.get(source);
        InboundTransferTask inboundTransfer=new InboundTransferTask(segs,source,topologyId,this,rpcManager,commandsFactory,timeout);
        for (        int segmentId : segs) {
          transfersBySegment.put(segmentId,inboundTransfer);
        }
        List<InboundTransferTask> inboundTransfers=transfersBySource.get(inboundTransfer.getSource());
        if (inboundTransfers == null) {
          inboundTransfers=new ArrayList<InboundTransferTask>();
          transfersBySource.put(inboundTransfer.getSource(),inboundTransfers);
        }
        inboundTransfers.add(inboundTransfer);
        if (inboundTransfer.requestTransactions()) {
          if (!inboundTransfer.requestSegments()) {
            log.errorf("Failed to request segments %s from %s",segs,source);
          }
        }
 else {
          log.errorf("Failed to retrieve transactions for segments %s from %s",segs,source);
          failedSegments.addAll(segs);
          faultyMembers.add(source);
          removeTransfer(inboundTransfer);
        }
      }
      segmentsToProcess=failedSegments;
    }
  }
}
