{
  DelegatingCacheEntryListenerInvocation<K,V>[] invocations;
switch ((Event.Type)eventType) {
case CACHE_ENTRY_ACTIVATED:
    invocations=activated_invocations;
  break;
case CACHE_ENTRY_CREATED:
invocations=created_invocations;
break;
case CACHE_ENTRY_INVALIDATED:
invocations=invalidated_invocations;
break;
case CACHE_ENTRY_LOADED:
invocations=loaded_invocations;
break;
case CACHE_ENTRY_MODIFIED:
invocations=modified_invocations;
break;
case CACHE_ENTRY_PASSIVATED:
invocations=passivated_invocations;
break;
case CACHE_ENTRY_REMOVED:
invocations=removed_invocations;
break;
case CACHE_ENTRY_VISITED:
invocations=visited_invocations;
break;
case CACHE_ENTRY_EVICTED:
invocations=evicted_invocations;
break;
case CACHE_ENTRY_EXPIRED:
invocations=expired_invocations;
break;
default :
return;
}
if (invocations != null) {
CacheEntryEvent<K,V> event=(CacheEntryEvent<K,V>)userContext;
if (event.isPre() && isClustered || isPrimaryOnly && !clusteringDependentLogic.localNodeIsPrimaryOwner(event.getKey())) {
return;
}
if (filterAndConvert && event instanceof EventImpl) {
EventImpl<K,V> eventImpl=(EventImpl<K,V>)event;
EventImpl<K,V> clone=eventImpl.clone();
clone.setValue((V)makeFilterResult(projection == null ? instance : null,projection,sortProjection));
event=clone;
}
for (DelegatingCacheEntryListenerInvocation<K,V> invocation : invocations) {
if (event.isPre()) {
if (invocation.getObservation() == Listener.Observation.POST) {
continue;
}
}
 else {
if (invocation.getObservation() == Listener.Observation.PRE) {
continue;
}
}
invocation.invokeNoChecks(event,false,filterAndConvert);
}
}
}
