{
  boolean localTxScope=ctx.isOriginLocal() && ctx.isInTxScope();
  boolean shouldInvokeOnCluster=false;
  try {
    if (localTxScope) {
      c.attachGlobalTransaction((GlobalTransaction)ctx.getLockOwner());
    }
    if (c.isUnlock()) {
      lockManager.releaseLocks(ctx);
      if (log.isTraceEnabled())       log.trace("Lock released for: " + ctx.getLockOwner());
      return false;
    }
    for (    Object key : c.getKeys()) {
      if (c.isImplicit() && localTxScope && !lockManager.ownsLock(key,ctx.getLockOwner())) {
        shouldInvokeOnCluster=true;
        break;
      }
    }
    boolean goRemoteFirst=configuration.isEnableDeadlockDetection() && localTxScope;
    if (goRemoteFirst) {
      Object result=invokeNextInterceptor(ctx,c);
      try {
        lockKeysForRemoteTx(ctx,c);
        result=true;
      }
 catch (      Throwable e) {
        result=false;
        c.setUnlock(true);
        invokeNextInterceptor(ctx,c);
        throw e;
      }
      return result;
    }
 else {
      lockKeysForRemoteTx(ctx,c);
      if (shouldInvokeOnCluster || c.isExplicit()) {
        invokeNextInterceptor(ctx,c);
        return true;
      }
 else {
        return true;
      }
    }
  }
 catch (  Throwable te) {
    cleanLocksAndRethrow(ctx,te);
    return false;
  }
 finally {
    if (ctx.isInTxScope()) {
      doAfterCall(ctx);
    }
 else {
      throw new IllegalStateException("Attempting to lock but there is no transactional context in scope. " + ctx);
    }
  }
}
