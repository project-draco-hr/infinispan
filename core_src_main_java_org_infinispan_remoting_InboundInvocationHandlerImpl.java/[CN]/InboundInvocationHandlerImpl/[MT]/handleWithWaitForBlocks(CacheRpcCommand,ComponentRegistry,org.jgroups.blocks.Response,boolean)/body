{
  final StateTransferManager stm=cr.getStateTransferManager();
  if (cmd instanceof TotalOrderPrepareCommand && !stm.ownsData()) {
    reply(response,null);
    return;
  }
  CommandsFactory commandsFactory=cr.getCommandsFactory();
  commandsFactory.initializeReplicableCommand(cmd,true);
  if (cmd instanceof TotalOrderPrepareCommand) {
    final TotalOrderRemoteTransactionState state=((TotalOrderPrepareCommand)cmd).getOrCreateState();
    final TotalOrderManager totalOrderManager=cr.getTotalOrderManager();
    totalOrderManager.ensureOrder(state,((PrepareCommand)cmd).getAffectedKeysToLock(false));
    totalOrderExecutorService.execute(new BlockingRunnable(){
      @Override public boolean isReady(){
        for (        TotalOrderLatch block : state.getConflictingTransactionBlocks()) {
          if (block.isBlocked()) {
            return false;
          }
        }
        return true;
      }
      @Override public void run(){
        Response resp;
        try {
          resp=handleInternal(cmd,cr);
        }
 catch (        RetryPrepareException retry) {
          log.debugf(retry,"Prepare [%s] conflicted with state transfer",cmd);
          resp=new ExceptionResponse(retry);
        }
catch (        Throwable throwable) {
          log.exceptionHandlingCommand(cmd,throwable);
          resp=new ExceptionResponse(new CacheException("Problems invoking command.",throwable));
        }
        reply(response,resp);
        if (resp instanceof ExceptionResponse) {
          totalOrderManager.release(state);
        }
        afterResponseSent(cmd,resp);
      }
    }
);
  }
 else {
    final StateTransferLock stateTransferLock=cr.getStateTransferLock();
    final int commandTopologyId=Math.max(extractCommandTopologyId(cmd),0);
    if (!preserveOrder && cmd.canBlock()) {
      remoteCommandsExecutor.execute(new BlockingRunnable(){
        @Override public boolean isReady(){
          return stateTransferLock.transactionDataReceived(commandTopologyId);
        }
        @Override public void run(){
          if (0 < commandTopologyId && commandTopologyId < stm.getFirstTopologyAsMember()) {
            if (trace)             log.tracef("Ignoring command sent before the local node was a member " + "(command topology id is %d)",commandTopologyId);
            reply(response,null);
            return;
          }
          Response resp;
          try {
            resp=handleInternal(cmd,cr);
          }
 catch (          Throwable throwable) {
            log.exceptionHandlingCommand(cmd,throwable);
            resp=new ExceptionResponse(new CacheException("Problems invoking command.",throwable));
          }
          reply(response,resp);
          afterResponseSent(cmd,resp);
        }
      }
);
    }
 else {
      stateTransferLock.waitForTransactionData(commandTopologyId,1,TimeUnit.DAYS);
      if (0 < commandTopologyId && commandTopologyId < stm.getFirstTopologyAsMember()) {
        if (trace)         log.tracef("Ignoring command sent before the local node was a member " + "(command topology id is %d)",commandTopologyId);
        reply(response,null);
        return;
      }
      Response resp=handleInternal(cmd,cr);
      if (trace && resp != null && !resp.isValid()) {
        log.tracef("Unable to execute command, got invalid response %s",resp);
      }
      reply(response,resp);
      afterResponseSent(cmd,resp);
    }
  }
}
