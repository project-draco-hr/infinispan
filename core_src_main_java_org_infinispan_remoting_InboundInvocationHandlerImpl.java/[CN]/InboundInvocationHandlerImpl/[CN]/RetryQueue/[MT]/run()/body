{
  boolean running=true;
  while (running) {
    CacheRpcCommand c=null;
    boolean unlock=false;
    try {
      c=queue.take();
      waitForStart(c);
      distributedSync.acquireProcessingLock(false,distributedSyncTimeout,MILLISECONDS);
      unlock=true;
      handleInternal(c);
      retryQueueLock.lock();
      if (queue.isEmpty()) {
        enqueueing=false;
        enqueuedBlocker.open();
      }
      retryQueueLock.unlock();
    }
 catch (    InterruptedException e) {
      enqueueing=false;
      enqueuedBlocker.open();
      running=false;
    }
catch (    Throwable throwable) {
      log.exceptionHandlingCommand(c,throwable);
    }
 finally {
      if (unlock)       distributedSync.releaseProcessingLock(false);
    }
  }
}
