{
  if (!ctx.isInTxScope())   throw new IllegalStateException("Locks should only be acquired within the scope of a transaction!");
  try {
    boolean skipLocking=hasSkipLocking(command);
    if (skipLocking) {
      return ctx.shortCircuit(ctx.forkInvocationSync(command));
    }
    if (ctx.isOriginLocal()) {
      final boolean isSingleKeyAndLocal=!command.multipleKeys() && cdl.localNodeIsPrimaryOwner(command.getSingleKey());
      boolean needBackupLocks=!isSingleKeyAndLocal || isStateTransferInProgress();
      if (needBackupLocks && !command.hasFlag(Flag.CACHE_MODE_LOCAL)) {
        LocalTransaction localTx=(LocalTransaction)ctx.getCacheTransaction();
        if (!localTx.getAffectedKeys().containsAll(command.getKeys())) {
          ctx.forkInvocationSync(command);
        }
 else {
          log.tracef("Already own locks on keys: %s, skipping remote call",command.getKeys());
        }
      }
      ((TxInvocationContext<?>)ctx).addAllAffectedKeys(command.getKeys());
    }
    if (command.isUnlock()) {
      if (ctx.isOriginLocal())       throw new AssertionError("There's no advancedCache.unlock so this must have originated remotely.");
      releaseLocksOnFailureBeforePrepare(ctx);
      return ctx.shortCircuit(Boolean.FALSE);
    }
    lockAllOrRegisterBackupLock(ctx,command.getKeys(),getLockTimeoutMillis(command));
    return ctx.shortCircuit(Boolean.TRUE);
  }
 catch (  Throwable te) {
    releaseLocksOnFailureBeforePrepare(ctx);
    throw te;
  }
}
