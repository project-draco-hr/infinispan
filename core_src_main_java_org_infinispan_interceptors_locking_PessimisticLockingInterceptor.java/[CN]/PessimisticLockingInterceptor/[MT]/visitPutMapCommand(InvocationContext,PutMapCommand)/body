{
  try {
    if (!hasSkipLocking(command)) {
      final Collection<Object> affectedKeys=command.getMap().keySet();
      acquireAllRemoteIfNeeded(ctx,affectedKeys,command);
      lockAllOrRegisterBackupLock((TxInvocationContext<?>)ctx,affectedKeys,getLockTimeoutMillis(command));
    }
    return invokeNextInterceptor(ctx,command);
  }
 catch (  Throwable te) {
    releaseLocksOnFailureBeforePrepare(ctx);
    throw te;
  }
}
