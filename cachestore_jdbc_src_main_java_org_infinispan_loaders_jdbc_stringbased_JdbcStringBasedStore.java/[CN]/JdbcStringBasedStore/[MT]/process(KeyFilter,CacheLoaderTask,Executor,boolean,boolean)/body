{
  ExecutorCompletionService<Void> ecs=new ExecutorCompletionService<Void>(executor);
  ecs.submit(new Callable<Void>(){
    @Override public Void call() throws Exception {
      Connection conn=null;
      PreparedStatement ps=null;
      ResultSet rs=null;
      try {
        String sql=tableManipulation.getLoadNonExpiredAllRowsSql();
        if (log.isTraceEnabled()) {
          log.tracef("Running sql %s",sql);
        }
        conn=connectionFactory.getConnection();
        ps=conn.prepareStatement(sql);
        ps.setLong(1,ctx.getTimeService().wallClockTime());
        rs=ps.executeQuery();
        rs.setFetchSize(tableManipulation.getFetchSize());
        TaskContext taskContext=new TaskContextImpl();
        while (rs.next()) {
          String keyStr=rs.getString(2);
          Object key=((TwoWayKey2StringMapper)key2StringMapper).getKeyMapping(keyStr);
          if (taskContext.isStopped())           break;
          if (filter != null && !filter.shouldLoadKey(key))           continue;
          InputStream inputStream=rs.getBinaryStream(1);
          MarshalledEntry entry;
          if (fetchValue || fetchMetadata) {
            KeyValuePair<ByteBuffer,ByteBuffer> kvp=JdbcUtil.unmarshall(ctx.getMarshaller(),inputStream);
            entry=new MarshalledEntryImpl(key,kvp.getKey(),kvp.getValue(),ctx.getMarshaller());
          }
 else {
            entry=new MarshalledEntryImpl(key,(Object)null,null,ctx.getMarshaller());
          }
          task.processEntry(entry,taskContext);
        }
        return null;
      }
 catch (      SQLException e) {
        log.sqlFailureFetchingAllStoredEntries(e);
        throw new CacheLoaderException("SQL error while fetching all StoredEntries",e);
      }
 finally {
        JdbcUtil.safeClose(rs);
        JdbcUtil.safeClose(ps);
        connectionFactory.releaseConnection(conn);
      }
    }
  }
);
  PersistenceUtil.waitForAllTasksToComplete(ecs,1);
}
