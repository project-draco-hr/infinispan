{
  this.cr=cr;
  List<Field> fields=ReflectionUtil.getFields(this.getClass(),AbstractNamedCacheConfigurationBean.class);
  for (  Field field : fields) {
    AbstractNamedCacheConfigurationBean fieldValueThis=null;
    try {
      field.setAccessible(true);
      fieldValueThis=(AbstractNamedCacheConfigurationBean)field.get(this);
      if (fieldValueThis != null) {
        fieldValueThis.inject(cr);
      }
    }
 catch (    Exception e) {
      String s="Could not inject for field " + field + " in class "+ fieldValueThis;
      log.error(s,e);
      throw new CacheException(s,e);
    }
  }
  fields=ReflectionUtil.getFields(this.getClass(),Collection.class);
  for (  Field field : fields) {
    Type genericType=field.getGenericType();
    if (genericType instanceof ParameterizedType) {
      ParameterizedType aType=(ParameterizedType)genericType;
      Type[] fieldArgTypes=aType.getActualTypeArguments();
      for (      Type fieldArgType : fieldArgTypes) {
        Class<?> fieldArgClass=(Class<?>)fieldArgType;
        if (!(fieldArgClass.isPrimitive() || fieldArgClass.equals(String.class))) {
          try {
            field.setAccessible(true);
            Collection<Object> c=(Collection<Object>)field.get(this);
            for (            Object nextThis : c) {
              if (AbstractNamedCacheConfigurationBean.class.isAssignableFrom(nextThis.getClass())) {
                ((AbstractNamedCacheConfigurationBean)nextThis).inject(cr);
              }
 else {
                break;
              }
            }
          }
 catch (          Exception e) {
            String errorMsg="Could not inject for field " + field + " in class "+ field;
            log.error(errorMsg,e);
            throw new CacheException(errorMsg,e);
          }
        }
      }
    }
  }
}
