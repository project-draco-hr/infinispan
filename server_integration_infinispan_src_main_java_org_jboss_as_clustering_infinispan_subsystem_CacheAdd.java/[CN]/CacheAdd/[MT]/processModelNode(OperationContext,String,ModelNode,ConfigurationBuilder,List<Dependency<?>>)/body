{
  builder.jmxStatistics().enabled(CacheResource.STATISTICS.resolveModelAttribute(context,cache).asBoolean());
  final Indexing indexing=Indexing.valueOf(CacheResource.INDEXING.resolveModelAttribute(context,cache).asString());
  final boolean batching=CacheResource.BATCHING.resolveModelAttribute(context,cache).asBoolean();
  builder.clustering().cacheMode(this.mode);
  final ModelNode indexingPropertiesModel=CacheResource.INDEXING_PROPERTIES.resolveModelAttribute(context,cache);
  Properties indexingProperties=new Properties();
  if (indexing.isEnabled() && indexingPropertiesModel.isDefined()) {
    for (    Property p : indexingPropertiesModel.asPropertyList()) {
      String value=p.getValue().asString();
      indexingProperties.put(p.getName(),value);
    }
  }
  builder.indexing().enabled(indexing.isEnabled()).indexLocalOnly(indexing.isLocalOnly()).withProperties(indexingProperties);
  if (cache.hasDefined(ModelKeys.LOCKING) && cache.get(ModelKeys.LOCKING,ModelKeys.LOCKING_NAME).isDefined()) {
    ModelNode locking=cache.get(ModelKeys.LOCKING,ModelKeys.LOCKING_NAME);
    final IsolationLevel isolationLevel=IsolationLevel.valueOf(LockingResource.ISOLATION.resolveModelAttribute(context,locking).asString());
    final boolean striping=LockingResource.STRIPING.resolveModelAttribute(context,locking).asBoolean();
    final long acquireTimeout=LockingResource.ACQUIRE_TIMEOUT.resolveModelAttribute(context,locking).asLong();
    final int concurrencyLevel=LockingResource.CONCURRENCY_LEVEL.resolveModelAttribute(context,locking).asInt();
    builder.locking().isolationLevel(isolationLevel).useLockStriping(striping).lockAcquisitionTimeout(acquireTimeout).concurrencyLevel(concurrencyLevel);
  }
  TransactionMode txMode=TransactionMode.NONE;
  LockingMode lockingMode=LockingMode.OPTIMISTIC;
  if (cache.hasDefined(ModelKeys.TRANSACTION) && cache.get(ModelKeys.TRANSACTION,ModelKeys.TRANSACTION_NAME).isDefined()) {
    ModelNode transaction=cache.get(ModelKeys.TRANSACTION,ModelKeys.TRANSACTION_NAME);
    final long stopTimeout=TransactionResource.STOP_TIMEOUT.resolveModelAttribute(context,transaction).asLong();
    txMode=TransactionMode.valueOf(TransactionResource.MODE.resolveModelAttribute(context,transaction).asString());
    lockingMode=LockingMode.valueOf(TransactionResource.LOCKING.resolveModelAttribute(context,transaction).asString());
    builder.transaction().cacheStopTimeout(stopTimeout);
  }
  builder.transaction().transactionMode(txMode.getMode()).lockingMode(lockingMode).useSynchronization(!txMode.isXAEnabled()).recovery().enabled(txMode.isRecoveryEnabled());
  if (txMode.isRecoveryEnabled()) {
    builder.transaction().syncCommitPhase(true).syncRollbackPhase(true);
  }
  if (batching) {
    builder.transaction().transactionMode(org.infinispan.transaction.TransactionMode.TRANSACTIONAL).invocationBatching().enable();
  }
 else {
    builder.transaction().invocationBatching().disable();
  }
  if (cache.hasDefined(ModelKeys.EVICTION) && cache.get(ModelKeys.EVICTION,ModelKeys.EVICTION_NAME).isDefined()) {
    ModelNode eviction=cache.get(ModelKeys.EVICTION,ModelKeys.EVICTION_NAME);
    final EvictionStrategy strategy=EvictionStrategy.valueOf(EvictionResource.EVICTION_STRATEGY.resolveModelAttribute(context,eviction).asString());
    builder.eviction().strategy(strategy);
    if (strategy.isEnabled()) {
      final int maxEntries=EvictionResource.MAX_ENTRIES.resolveModelAttribute(context,eviction).asInt();
      builder.eviction().maxEntries(maxEntries);
    }
  }
  if (cache.hasDefined(ModelKeys.EXPIRATION) && cache.get(ModelKeys.EXPIRATION,ModelKeys.EXPIRATION_NAME).isDefined()) {
    ModelNode expiration=cache.get(ModelKeys.EXPIRATION,ModelKeys.EXPIRATION_NAME);
    final long maxIdle=ExpirationResource.MAX_IDLE.resolveModelAttribute(context,expiration).asLong();
    final long lifespan=ExpirationResource.LIFESPAN.resolveModelAttribute(context,expiration).asLong();
    final long interval=ExpirationResource.INTERVAL.resolveModelAttribute(context,expiration).asLong();
    builder.expiration().maxIdle(maxIdle).lifespan(lifespan).wakeUpInterval(interval);
    if (interval > 0) {
      builder.expiration().enableReaper();
    }
 else {
      builder.expiration().disableReaper();
    }
  }
  if (cache.hasDefined(ModelKeys.COMPATIBILITY) && cache.get(ModelKeys.COMPATIBILITY,ModelKeys.COMPATIBILITY_NAME).isDefined()) {
    ModelNode compatibility=cache.get(ModelKeys.COMPATIBILITY,ModelKeys.COMPATIBILITY_NAME);
    final boolean enabled=CompatibilityResource.ENABLED.resolveModelAttribute(context,compatibility).asBoolean();
    builder.compatibility().enabled(enabled);
    if (compatibility.hasDefined(ModelKeys.MARSHALLER)) {
      String marshaller=CompatibilityResource.MARSHALLER.resolveModelAttribute(context,compatibility).asString();
      try {
        Class<? extends Marshaller> marshallerClass=CacheLoader.class.getClassLoader().loadClass(marshaller).asSubclass(Marshaller.class);
        builder.compatibility().marshaller(marshallerClass.newInstance());
      }
 catch (      Exception e) {
        throw InfinispanMessages.MESSAGES.invalidCompatibilityMarshaller(e,marshaller);
      }
    }
  }
  if (cache.hasDefined(ModelKeys.SECURITY) && cache.get(ModelKeys.SECURITY,ModelKeys.SECURITY_NAME).isDefined()) {
    ModelNode securityModel=cache.get(ModelKeys.SECURITY,ModelKeys.SECURITY_NAME);
    if (securityModel.hasDefined(ModelKeys.AUTHORIZATION) && securityModel.get(ModelKeys.AUTHORIZATION).hasDefined(ModelKeys.AUTHORIZATION_NAME)) {
      ModelNode authzModel=securityModel.get(ModelKeys.AUTHORIZATION,ModelKeys.AUTHORIZATION_NAME);
      AuthorizationConfigurationBuilder authzBuilder=builder.security().authorization();
      authzBuilder.enabled(CacheAuthorizationResource.ENABLED.resolveModelAttribute(context,authzModel).asBoolean());
      for (      ModelNode role : CacheAuthorizationResource.ROLES.resolveModelAttribute(context,authzModel).asList()) {
        authzBuilder.role(role.asString());
      }
    }
  }
  for (  String loaderKey : loaderKeys) {
    handleLoaderProperties(context,cache,loaderKey,containerName,builder,dependencies);
  }
  for (  String storeKey : storeKeys) {
    handleStoreProperties(context,cache,storeKey,containerName,builder,dependencies);
  }
  if (cache.hasDefined(ModelKeys.BACKUP)) {
    SitesConfigurationBuilder sitesBuilder=builder.sites();
    for (    Property property : cache.get(ModelKeys.BACKUP).asPropertyList()) {
      String siteName=property.getName();
      ModelNode site=property.getValue();
      sitesBuilder.addBackup().site(siteName).backupFailurePolicy(BackupFailurePolicy.valueOf(BackupSiteResource.FAILURE_POLICY.resolveModelAttribute(context,site).asString())).strategy(BackupStrategy.valueOf(BackupSiteResource.STRATEGY.resolveModelAttribute(context,site).asString())).replicationTimeout(BackupSiteResource.REPLICATION_TIMEOUT.resolveModelAttribute(context,site).asLong());
      if (BackupSiteResource.ENABLED.resolveModelAttribute(context,site).asBoolean()) {
        sitesBuilder.addInUseBackupSite(siteName);
      }
    }
  }
}
