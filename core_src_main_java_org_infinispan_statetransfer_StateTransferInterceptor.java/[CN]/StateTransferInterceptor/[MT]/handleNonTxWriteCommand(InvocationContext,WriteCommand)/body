{
  if (trace)   log.tracef("handleNonTxWriteCommand for command %s, topology id %d",command,command.getTopologyId());
  if (isLocalOnly(ctx,command)) {
    return invokeNextInterceptor(ctx,command);
  }
  updateTopologyId(command);
  if (!ctx.isOriginLocal()) {
    return invokeNextInterceptor(ctx,command);
  }
  int commandTopologyId=command.getTopologyId();
  Object localResult;
  try {
    localResult=invokeNextInterceptor(ctx,command);
    return localResult;
  }
 catch (  CacheException e) {
    Throwable ce=e;
    while (ce instanceof RemoteException) {
      ce=ce.getCause();
    }
    if (!(ce instanceof OutdatedTopologyException) && !(ce instanceof SuspectException))     throw e;
    if (trace)     log.tracef("Retrying command because of topology change, current topology is %d: %s",command);
    int newTopologyId=Math.max(currentTopologyId(),commandTopologyId + 1);
    command.setTopologyId(newTopologyId);
    waitForTransactionData(newTopologyId);
    command.setFlags(Flag.COMMAND_RETRY);
    localResult=handleNonTxWriteCommand(ctx,command);
  }
  return localResult;
}
