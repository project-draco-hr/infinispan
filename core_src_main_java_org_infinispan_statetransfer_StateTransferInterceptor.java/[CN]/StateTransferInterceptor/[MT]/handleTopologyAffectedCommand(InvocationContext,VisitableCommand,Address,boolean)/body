{
  log.tracef("handleTopologyAffectedCommand for command %s, origin %s",command,origin);
  if (isLocalOnly(ctx,command)) {
    return invokeNextInterceptor(ctx,command);
  }
  updateTopologyId((TopologyAffectedCommand)command);
  Object localResult=invokeNextInterceptor(ctx,command);
  boolean isNonTransactionalWrite=!ctx.isInTxScope() && command instanceof WriteCommand;
  boolean isTransactionalAndNotRolledBack=false;
  if (ctx.isInTxScope()) {
    isTransactionalAndNotRolledBack=command instanceof TransactionBoundaryCommand && !((TxInvocationContext)ctx).getCacheTransaction().isMarkedForRollback();
  }
  if (isNonTransactionalWrite || isTransactionalAndNotRolledBack) {
    Map<Address,Response> responseMap=stateTransferManager.forwardCommandIfNeeded(((TopologyAffectedCommand)command),getAffectedKeys(ctx,command),origin,sync);
    localResult=mergeResponses(responseMap,localResult,ctx,command);
  }
  return localResult;
}
