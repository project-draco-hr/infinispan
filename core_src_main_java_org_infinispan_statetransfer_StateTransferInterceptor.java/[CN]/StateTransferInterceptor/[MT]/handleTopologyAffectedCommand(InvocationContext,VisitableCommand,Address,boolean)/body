{
  log.tracef("handleTopologyAffectedCommand for command %s, originLocal=%b",command,originLocal);
  if (isLocal(command,originLocal)) {
    return invokeNextInterceptor(ctx,command);
  }
  updateTopologyIdAndWaitForTransactionData((TopologyAffectedCommand)command);
  Object localResult=invokeNextInterceptor(ctx,command);
  boolean isNonTransactionalWrite=!ctx.isInTxScope() && command instanceof WriteCommand;
  boolean isTransactionalAndNotRolledBack=false;
  if (ctx.isInTxScope()) {
    isTransactionalAndNotRolledBack=!((TxInvocationContext)ctx).getCacheTransaction().isMarkedForRollback();
  }
  if (isNonTransactionalWrite || isTransactionalAndNotRolledBack) {
    stateTransferManager.forwardCommandIfNeeded(((TopologyAffectedCommand)command),getAffectedKeys(ctx,command),origin,true);
  }
  return localResult;
}
