{
  boolean cacheModeLocal=false;
  if (command instanceof FlagAffectedCommand) {
    cacheModeLocal=((FlagAffectedCommand)command).hasFlag(Flag.CACHE_MODE_LOCAL);
  }
  log.tracef("handleTopologyAffectedCommand for command %s, originLocal=%s, cacheModeLocal=%s",command,originLocal,cacheModeLocal);
  if (originLocal || cacheModeLocal) {
    return invokeNextInterceptor(ctx,command);
  }
  if (command.getTopologyId() == -1) {
    command.setTopologyId(stateTransferManager.getCacheTopology().getTopologyId());
  }
  int cmdTopologyId=command.getTopologyId();
  stateTransferLock.waitForTransactionData(cmdTopologyId);
  Object localResult=invokeNextInterceptor(ctx,command);
  CacheTopology cacheTopology=stateTransferManager.getCacheTopology();
  int localTopologyId=cacheTopology.getTopologyId();
  log.tracef("CommandTopologyId=%s, localTopologyId=%s",cmdTopologyId,localTopologyId);
  if (cmdTopologyId < localTopologyId) {
    if (command instanceof TransactionBoundaryCommand || (command instanceof WriteCommand && !ctx.isInTxScope())) {
      ConsistentHash writeCh=cacheTopology.getWriteConsistentHash();
      Set<Object> affectedKeys=getAffectedKeys(ctx,command);
      Set<Address> newTargets=writeCh.locateAllOwners(affectedKeys);
      newTargets.remove(rpcManager.getAddress());
      if (!newTargets.isEmpty()) {
        command.setTopologyId(localTopologyId);
        log.tracef("Forwarding command %s to new targets %s",command,newTargets);
        rpcManager.invokeRemotely(newTargets,command,true,false);
      }
    }
  }
  return localResult;
}
