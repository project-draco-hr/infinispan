{
  Address origin=ctx.isOriginLocal() ? ctx.getOrigin() : ctx.getGlobalTransaction().getAddress();
  if (trace)   log.tracef("handleTxCommand for command %s, origin %s",command,origin);
  if (isLocalOnly(command)) {
    return ctx.continueInvocation();
  }
  updateTopologyId(command);
  int retryTopologyId=-1;
  Object localResult=null;
  try {
    localResult=ctx.forkInvocationSync(command);
  }
 catch (  OutdatedTopologyException e) {
    retryTopologyId=Math.max(currentTopologyId(),command.getTopologyId() + 1);
  }
  boolean async=isTxCommandAsync(command);
  if (async) {
    stateTransferManager.forwardCommandIfNeeded(command,getAffectedKeys(ctx,command),origin);
    return ctx.shortCircuit(null);
  }
  if (ctx.isOriginLocal()) {
    if (retryTopologyId > 0) {
      command.setTopologyId(retryTopologyId);
      waitForTransactionData(retryTopologyId);
      if (command instanceof PrepareCommand) {
        ((PrepareCommand)command).setRetriedCommand(true);
      }
      log.tracef("Retrying command %s for topology %d",command,retryTopologyId);
      return handleTxCommand(ctx,command);
    }
  }
 else {
    if (currentTopologyId() > command.getTopologyId()) {
      localResult=UnsureResponse.INSTANCE;
    }
  }
  return ctx.shortCircuit(localResult);
}
