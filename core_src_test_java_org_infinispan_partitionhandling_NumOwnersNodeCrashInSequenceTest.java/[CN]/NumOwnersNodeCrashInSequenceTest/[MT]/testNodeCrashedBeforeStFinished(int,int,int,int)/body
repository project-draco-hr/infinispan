{
  cchf.setOwnerIndexes(new int[]{a0,a1},new int[]{a1,c0},new int[]{c0,c1},new int[]{c1,a0});
  configBuilder.clustering().hash().consistentHashFactory(cchf);
  createCluster(configBuilder,4);
  waitForClusterToForm();
  Object k0=new MagicKey("k1",cache(a0),cache(a1));
  Object k1=new MagicKey("k2",cache(a0),cache(a1));
  Object k2=new MagicKey("k3",cache(a1),cache(c0));
  Object k3=new MagicKey("k4",cache(a1),cache(c0));
  Object k4=new MagicKey("k5",cache(c0),cache(c1));
  Object k5=new MagicKey("k6",cache(c0),cache(c1));
  Object k6=new MagicKey("k7",cache(c1),cache(a0));
  Object k7=new MagicKey("k8",cache(c1),cache(a0));
  final Object[] allKeys=new Object[]{k0,k1,k2,k3,k4,k5,k6,k7};
  for (  Object k : allKeys)   cache(a0).put(k,k);
  StateSequencer ss=new StateSequencer();
  ss.logicalThread("main","main:st_in_progress","main:2nd_node_left","main:cluster_unavailable","main:after_cluster_unavailable");
  advanceOnInboundRpc(ss,manager(a1),matchCommand(StateResponseCommand.class).matchCount(0).build()).before("main:st_in_progress","main:cluster_unavailable");
  advanceOnInboundRpc(ss,manager(a1),matchCommand(StateResponseCommand.class).matchCount(1).build()).before("main:after_cluster_unavailable");
  cchf.setMembersToUse(advancedCache(a0).getRpcManager().getTransport().getMembers());
  cchf.setOwnerIndexes(new int[]{a0,a1},new int[]{a1,c0},new int[]{c0,a1},new int[]{c0,a0});
  Address missing=address(c1);
  log.tracef("Before killing node %s",missing);
  crashCacheManagers(manager(c1));
  installNewView(advancedCache(a0).getRpcManager().getTransport().getMembers(),missing,manager(a0),manager(a1),manager(c0));
  ss.enter("main:2nd_node_left");
  missing=address(c0);
  log.tracef("Killing 2nd node %s",missing);
  crashCacheManagers(manager(c0));
  installNewView(advancedCache(a0).getRpcManager().getTransport().getMembers(),missing,manager(a0),manager(a1));
  final PartitionHandlingManager phm0=TestingUtil.extractComponent(cache(a0),PartitionHandlingManager.class);
  final PartitionHandlingManager phm1=TestingUtil.extractComponent(cache(a1),PartitionHandlingManager.class);
  eventually(new Condition(){
    @Override public boolean isSatisfied() throws Exception {
      return phm0.getAvailabilityMode() == expectedAvailabilityMode && phm1.getAvailabilityMode() == expectedAvailabilityMode;
    }
  }
);
  ss.exit("main:2nd_node_left");
  log.trace("Testing condition");
  ConsistentHash ch=cache(a0).getAdvancedCache().getDistributionManager().getReadConsistentHash();
  assertEquals(3,ch.getMembers().size());
  for (  Object k : allKeys) {
    Collection<Address> owners=ch.locateOwners(k);
    try {
      cache(a0).get(k);
      if (owners.contains(address(c0)) || owners.contains(address(c1))) {
        fail("get(" + k + ") should have failed on cache "+ address(a0));
      }
    }
 catch (    AvailabilityException e) {
    }
    try {
      cache(a1).put(k,k);
      if (owners.contains(address(c0)) || owners.contains(address(c1))) {
        fail("put(" + k + ", v) should have failed on cache "+ address(a0));
      }
    }
 catch (    AvailabilityException e) {
    }
  }
  log.debug("Changing partition availability mode back to AVAILABLE");
  cchf.setOwnerIndexes(new int[]{a0,a1},new int[]{a1,a0},new int[]{a0,a1},new int[]{a1,a0});
  LocalTopologyManager ltm=TestingUtil.extractGlobalComponent(manager(a0),LocalTopologyManager.class);
  ltm.setCacheAvailability(CacheContainer.DEFAULT_CACHE_NAME,AvailabilityMode.AVAILABLE);
  TestingUtil.waitForRehashToComplete(cache(a0),cache(a1));
  assertEquals(AvailabilityMode.AVAILABLE,phm0.getAvailabilityMode());
}
