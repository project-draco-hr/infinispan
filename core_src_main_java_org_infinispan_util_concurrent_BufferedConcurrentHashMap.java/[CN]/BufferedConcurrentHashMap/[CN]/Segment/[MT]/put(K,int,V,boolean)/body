{
  lock();
  Set<HashEntry<K,V>> evicted=null;
  try {
    int c=count;
    if (c++ > threshold && ea.strategy() == Eviction.NONE)     rehash();
    HashEntry<K,V>[] tab=table;
    int index=hash & (tab.length - 1);
    HashEntry<K,V> first=tab[index];
    HashEntry<K,V> e=first;
    while (e != null && (e.hash != hash || !key.equals(e.key)))     e=e.next;
    V oldValue;
    if (e != null) {
      oldValue=e.value;
      if (!onlyIfAbsent) {
        e.value=value;
        ea.onEntryHit(e);
      }
    }
 else {
      oldValue=null;
      ++modCount;
      count=c;
      if (ea.strategy() != Eviction.NONE) {
        if (c > tab.length) {
          evicted=ea.execute();
          first=tab[index];
        }
        tab[index]=new HashEntry<K,V>(key,hash,first,value);
        ea.onEntryMiss(tab[index]);
      }
 else {
        tab[index]=new HashEntry<K,V>(key,hash,first,value);
      }
    }
    return oldValue;
  }
  finally {
    unlock();
    if (evictionListener != null && evicted != null) {
      for (      HashEntry<K,V> he : evicted) {
        evictionListener.evicted(he.key,he.value);
      }
    }
  }
}
