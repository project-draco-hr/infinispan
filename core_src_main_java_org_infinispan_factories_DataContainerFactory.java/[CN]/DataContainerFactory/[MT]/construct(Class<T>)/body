{
  if (configuration.dataContainer().dataContainer() != null) {
    return (T)configuration.dataContainer().dataContainer();
  }
 else {
    EvictionStrategy st=configuration.eviction().strategy();
    int level=configuration.locking().concurrencyLevel();
    Equivalence keyEquivalence=configuration.dataContainer().keyEquivalence();
    long thresholdSize=configuration.eviction().size();
    if (thresholdSize < 0) {
      return (T)DefaultDataContainer.unBoundedDataContainer(level,keyEquivalence);
    }
switch (st) {
case NONE:
      return (T)DefaultDataContainer.unBoundedDataContainer(level,keyEquivalence);
case UNORDERED:
case LRU:
    if (configuration.eviction().type() == EvictionType.MEMORY) {
      EntrySizeCalculator esc;
      if (configuration.storeAsBinary().storeKeysAsBinary() && configuration.storeAsBinary().storeValuesAsBinary()) {
        esc=new MarshalledValueEntrySizeCalculator();
      }
 else {
        esc=new PrimitiveEntrySizeCalculator();
      }
      return (T)DefaultDataContainer.boundedDataContainer(level,thresholdSize,st,configuration.eviction().threadPolicy(),keyEquivalence,esc);
    }
case FIFO:
case LIRS:
  return (T)DefaultDataContainer.boundedDataContainer(level,thresholdSize,st,configuration.eviction().threadPolicy(),keyEquivalence,configuration.eviction().type());
default :
throw new CacheConfigurationException("Unknown eviction strategy " + configuration.eviction().strategy());
}
}
}
