{
  if (!cacheEntryEvictedListeners.isEmpty() && !entries.isEmpty()) {
    InvocationContext contexts=icc.suspend();
    try {
      EventImpl<Object,Object> e=EventImpl.createEvent(cache,CACHE_ENTRY_EVICTED);
      Map<Object,Object> evictedKeysAndValues=transformCollectionToMap(entries,new InfinispanCollections.MapMakerFunction<Object,Object,InternalCacheEntry>(){
        public Map.Entry<Object,Object> transform(        final InternalCacheEntry input){
          return new Map.Entry<Object,Object>(){
            @Override public Object getKey(){
              return input.getKey();
            }
            @Override public Object getValue(){
              return input.getValue();
            }
            @Override public Object setValue(            Object value){
              throw new UnsupportedOperationException();
            }
          }
;
        }
      }
);
      e.setEntries(evictedKeysAndValues);
      for (      ListenerInvocation listener : cacheEntryEvictedListeners)       listener.invoke(e);
    }
  finally {
      icc.resume(contexts);
    }
  }
}
