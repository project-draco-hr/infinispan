{
  if (newCaches.size() == 0 || newCaches.contains(null))   throw new IllegalArgumentException("Invalid cache list for consistent hash: " + newCaches);
  if (newCaches.size() * numVirtualNodes > Math.pow(2,32))   throw new IllegalArgumentException("Too many nodes: " + newCaches.size() + " * "+ numVirtualNodes+ " exceeds the available hash space");
  TreeMap<Integer,Address> positions=new TreeMap<Integer,Address>();
  for (  Address a : newCaches) {
    addNode(positions,a,getNormalizedHash(a));
  }
  if (isVirtualNodesEnabled()) {
    for (    Address a : newCaches) {
      for (int i=1; i < numVirtualNodes; i++) {
        Address va=new VirtualAddress(a,i);
        addNode(positions,a,getNormalizedHash(va));
      }
    }
  }
  log.tracef("Positions are: %s",positions);
  caches=new LinkedHashSet<Address>(newCaches.size());
  positionKeys=new int[positions.size()];
  positionValues=new Address[positions.size()];
  int i=0;
  for (  Map.Entry<Integer,Address> position : positions.entrySet()) {
    caches.add(position.getValue());
    positionKeys[i]=position.getKey();
    positionValues[i]=position.getValue();
    i++;
  }
  log.tracef("Consistent hash initialized: %s",this);
}
