{
  CacheSet<K> keySet=(CacheSet<K>)ctx.forkInvocationSync(command);
  if (!enabled || hasSkipLoadFlag(command)) {
    return ctx.shortCircuit(keySet);
  }
  CacheSet<K> wrappedKeySet=new AbstractDelegatingKeyCacheSet<K,V>(getCacheWithFlags(cache,command),keySet){
    @Override public CloseableIterator<K> iterator(){
      CloseableIterator<K> iterator=Closeables.iterator(keySet.stream());
      Set<K> seenKeys=new EquivalentHashSet<K>(cache.getAdvancedCache().getDataContainer().size(),keyEquivalence);
      return new DistinctKeyDoubleEntryCloseableIterator<>(iterator,new CloseableSuppliedIterator<>(new SupplierFunction<>(new PersistenceManagerCloseableSupplier<>(executorService,persistenceManager,iceFactory,new CollectionKeyFilter<>(seenKeys),10,TimeUnit.SECONDS,2048))),Function.identity(),seenKeys);
    }
    @Override public CloseableSpliterator<K> spliterator(){
      return spliteratorFromIterator(iterator());
    }
    private <E>CloseableSpliterator<E> spliteratorFromIterator(    CloseableIterator<E> iterator){
      return new IteratorAsSpliterator.Builder<>(iterator).setCharacteristics(Spliterator.CONCURRENT | Spliterator.DISTINCT | Spliterator.NONNULL).get();
    }
    @Override public int size(){
      long size=stream().count();
      if (size > Integer.MAX_VALUE) {
        return Integer.MAX_VALUE;
      }
      return (int)size;
    }
  }
;
  return ctx.shortCircuit(wrappedKeySet);
}
