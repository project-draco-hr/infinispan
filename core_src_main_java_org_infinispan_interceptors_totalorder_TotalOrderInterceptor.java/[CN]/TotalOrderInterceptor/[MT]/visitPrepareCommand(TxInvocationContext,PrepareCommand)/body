{
  if (log.isDebugEnabled()) {
    log.debugf("Prepare received. Transaction=%s, Affected keys=%s, Local=%s",command.getGlobalTransaction().globalId(),command.getAffectedKeys(),ctx.isOriginLocal());
  }
  if (!(command instanceof TotalOrderPrepareCommand)) {
    throw new IllegalStateException("TotalOrderInterceptor can only handle TotalOrderPrepareCommand");
  }
  try {
    if (ctx.isOriginLocal()) {
      return invokeNextInterceptor(ctx,command);
    }
 else {
      TotalOrderRemoteTransactionState state=getTransactionState(ctx);
      try {
        state.preparing();
        if (state.isRollbackReceived()) {
          transactionTable.removeRemoteTransaction(command.getGlobalTransaction());
          throw new CacheException("Cannot prepare transaction" + command.getGlobalTransaction().globalId() + ". it was already marked as rollback");
        }
        if (state.isCommitReceived()) {
          log.tracef("Transaction %s marked for commit, skipping the write skew check and forcing 1PC",command.getGlobalTransaction().globalId());
          ((TotalOrderPrepareCommand)command).markSkipWriteSkewCheck();
          ((TotalOrderPrepareCommand)command).markAsOnePhaseCommit();
        }
        if (log.isTraceEnabled()) {
          log.tracef("Validating transaction %s ",command.getGlobalTransaction().globalId());
        }
        Object result=invokeNextInterceptor(ctx,command);
        if (command.isOnePhaseCommit()) {
          totalOrderManager.release(state);
        }
        return result;
      }
  finally {
        state.prepared();
      }
    }
  }
 catch (  Throwable exception) {
    if (log.isDebugEnabled()) {
      log.debugf(exception,"Exception while preparing for transaction %s. Local=%s",command.getGlobalTransaction().globalId());
    }
    if (command.isOnePhaseCommit()) {
      transactionTable.remoteTransactionRollback(command.getGlobalTransaction());
    }
    throw exception;
  }
}
