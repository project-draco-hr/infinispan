{
  ReversibleOrderedSet<Map.Entry<Object,CacheEntry>> entries=ctx.getLookedUpEntries().entrySet();
  Iterator<Map.Entry<Object,CacheEntry>> it=entries.reverseIterator();
  if (trace)   log.trace("Number of entries in context: {0}",entries.size());
  if (commit) {
    while (it.hasNext()) {
      Map.Entry<Object,CacheEntry> e=it.next();
      CacheEntry entry=e.getValue();
      Object key=e.getKey();
      boolean needToUnlock=lockManager.possiblyLocked(entry);
      if (entry != null && entry.isChanged())       entry.commit(dataContainer);
 else {
        if (trace)         log.trace("Entry for key {0} is null, not calling commitUpdate",key);
      }
      if (needToUnlock) {
        if (trace)         log.trace("Releasing lock on [" + key + "] for owner "+ owner);
        lockManager.unlock(key,owner);
      }
    }
  }
 else {
    while (it.hasNext()) {
      Map.Entry<Object,CacheEntry> e=it.next();
      CacheEntry entry=e.getValue();
      Object key=e.getKey();
      boolean needToUnlock=lockManager.possiblyLocked(entry);
      if (entry != null && entry.isChanged())       entry.rollback();
 else {
        if (trace)         log.trace("Entry for key {0} is null, not calling rollbackUpdate",key);
      }
      if (needToUnlock) {
        if (trace)         log.trace("Releasing lock on [" + key + "] for owner "+ owner);
        lockManager.unlock(key,owner);
      }
    }
  }
  ctx.setContainsModifications(false);
  ctx.setContainsLocks(false);
}
