{
  final BiFun<? super K,? super K,? extends K> reducer=this.reducer;
  if (reducer == null)   return abortOnNullFunction();
  try {
    for (int c, b=batch(); b > 1 && baseIndex != baseLimit; ) {
      do {
      }
 while (!casPending(c=pending,c + 1));
      (rights=new ReduceKeysTask<K,V>(map,this,b>>>=1,rights,reducer)).fork();
    }
    K r=null;
    while (advance() != null) {
      K u=(K)nextKey;
      r=(r == null) ? u : reducer.apply(r,u);
    }
    result=r;
    for (ReduceKeysTask<K,V> t=this, s; ; ) {
      int c;
      BulkTask<K,V,?> par;
      K tr, sr;
      if ((c=t.pending) == 0) {
        for (s=t.rights; s != null; s=t.rights=s.nextRight) {
          if ((sr=s.result) != null)           t.result=(tr=t.result) == null ? sr : reducer.apply(tr,sr);
        }
        if ((par=t.parent) == null || !(par instanceof ReduceKeysTask)) {
          t.quietlyComplete();
          break;
        }
        t=(ReduceKeysTask<K,V>)par;
      }
 else       if (t.casPending(c,c - 1))       break;
    }
  }
 catch (  Throwable ex) {
    return tryCompleteComputation(ex);
  }
  return false;
}
