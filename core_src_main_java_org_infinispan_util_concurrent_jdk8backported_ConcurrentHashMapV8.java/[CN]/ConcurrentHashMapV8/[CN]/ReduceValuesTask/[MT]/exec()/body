{
  final BiFun<? super V,? super V,? extends V> reducer=this.reducer;
  if (reducer == null)   return abortOnNullFunction();
  try {
    for (int c, b=batch(); b > 1 && baseIndex != baseLimit; ) {
      do {
      }
 while (!casPending(c=pending,c + 1));
      (rights=new ReduceValuesTask<K,V>(map,this,b>>>=1,rights,reducer)).fork();
    }
    V r=null;
    Object v;
    while ((v=advance()) != null) {
      V u=(V)v;
      r=(r == null) ? u : reducer.apply(r,u);
    }
    result=r;
    for (ReduceValuesTask<K,V> t=this, s; ; ) {
      int c;
      BulkTask<K,V,?> par;
      V tr, sr;
      if ((c=t.pending) == 0) {
        for (s=t.rights; s != null; s=t.rights=s.nextRight) {
          if ((sr=s.result) != null)           t.result=(tr=t.result) == null ? sr : reducer.apply(tr,sr);
        }
        if ((par=t.parent) == null || !(par instanceof ReduceValuesTask)) {
          t.quietlyComplete();
          break;
        }
        t=(ReduceValuesTask<K,V>)par;
      }
 else       if (t.casPending(c,c - 1))       break;
    }
  }
 catch (  Throwable ex) {
    return tryCompleteComputation(ex);
  }
  return false;
}
