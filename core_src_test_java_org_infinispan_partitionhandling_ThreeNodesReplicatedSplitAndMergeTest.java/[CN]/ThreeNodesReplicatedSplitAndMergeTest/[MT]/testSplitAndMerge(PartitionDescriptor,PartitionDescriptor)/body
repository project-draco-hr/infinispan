{
  Object k0=new MagicKey(cache(p0.node(0)),cache(p0.node(1)));
  cache(0).put(k0,"v0");
  Object k1=new MagicKey(cache(p0.node(1)),cache(p1.node(0)));
  cache(1).put(k1,"v1");
  Object k2=new MagicKey(cache(p1.node(0)),cache(p0.node(0)));
  cache(2).put(k2,"v2");
  HashSet<Address> allMembers=new HashSet<>(advancedCache(0).getRpcManager().getMembers());
  assertStableTopologyMembers(allMembers,partitionHandlingManager(0));
  assertStableTopologyMembers(allMembers,partitionHandlingManager(1));
  assertStableTopologyMembers(allMembers,partitionHandlingManager(2));
  for (int i=0; i < numMembersInCluster; i++) {
    assertEquals(AvailabilityMode.AVAILABLE,partitionHandlingManager(i).getAvailabilityMode());
  }
  splitCluster(p0.getNodes(),p1.getNodes());
  TestingUtil.waitForRehashToComplete(cache(p0.node(0)),cache(p0.node(1)));
  partition(0).assertAvailabilityMode(AvailabilityMode.AVAILABLE);
  partition(1).assertAvailabilityMode(AvailabilityMode.DEGRADED_MODE);
  assertStableTopologyMembers(allMembers,partitionHandlingManager(p1.node(0)));
  partition(0).assertKeyAvailableForRead(k0,"v0");
  partition(0).assertKeyAvailableForRead(k1,"v1");
  partition(0).assertKeyAvailableForRead(k2,"v2");
  partition(1).assertKeysNotAvailableForRead(k0,k1,k2);
  assertTrue(dataContainer(p0.node(0)).containsKey(k0));
  assertTrue(dataContainer(p0.node(0)).containsKey(k1));
  assertTrue(dataContainer(p0.node(0)).containsKey(k2));
  assertTrue(dataContainer(p0.node(1)).containsKey(k0));
  assertTrue(dataContainer(p0.node(1)).containsKey(k1));
  assertTrue(dataContainer(p0.node(1)).containsKey(k2));
  assertTrue(dataContainer(p1.node(0)).containsKey(k0));
  assertTrue(dataContainer(p1.node(0)).containsKey(k1));
  assertTrue(dataContainer(p1.node(0)).containsKey(k2));
  partition(0).assertKeyAvailableForWrite(k0,"v00");
  partition(0).assertKeyAvailableForWrite(k1,"v11");
  partition(0).assertKeyAvailableForWrite(k2,"v22");
  partition(1).assertKeyNotAvailableForWrite(k0);
  partition(1).assertKeyNotAvailableForWrite(k1);
  partition(1).assertKeyNotAvailableForWrite(k2);
  partition(0).merge(partition(1));
  expectStableTopologyMembers(allMembers,partitionHandlingManager(0));
  expectStableTopologyMembers(allMembers,partitionHandlingManager(1));
  expectStableTopologyMembers(allMembers,partitionHandlingManager(2));
  partition(0).assertAvailabilityMode(AvailabilityMode.AVAILABLE);
  assertExpectedValue("v00",k0);
  assertExpectedValue("v11",k1);
  assertExpectedValue("v22",k2);
  assertTrue(dataContainer(p0.node(0)).containsKey(k0));
  assertTrue(dataContainer(p0.node(0)).containsKey(k1));
  assertTrue(dataContainer(p0.node(0)).containsKey(k2));
  assertTrue(dataContainer(p0.node(1)).containsKey(k0));
  assertTrue(dataContainer(p0.node(1)).containsKey(k1));
  assertTrue(dataContainer(p0.node(1)).containsKey(k2));
  assertTrue(dataContainer(p1.node(0)).containsKey(k0));
  assertTrue(dataContainer(p1.node(0)).containsKey(k1));
  assertTrue(dataContainer(p1.node(0)).containsKey(k2));
  cache(0).put(k0,"v000");
  cache(1).put(k1,"v111");
  cache(2).put(k2,"v222");
  assertExpectedValue("v000",k0);
  assertExpectedValue("v111",k1);
  assertExpectedValue("v222",k2);
  assertNull(cache(0).get("nonExistentKey"));
}
