{
  Object k0=new MagicKey(cache(p0.node(0)),cache(p0.node(1)));
  cache(0).put(k0,"v0");
  Object k1=new MagicKey(cache(p0.node(1)),cache(p1.node(0)));
  cache(1).put(k1,"v1");
  Object k2=new MagicKey(cache(p1.node(0)),cache(p0.node(0)));
  cache(2).put(k2,"v2");
  List<Address> allMembers=advancedCache(0).getRpcManager().getMembers();
  assertEquals(new HashSet<>(partitionHandlingManager(0).getLastStableTopology().getMembers()),new HashSet<>(allMembers));
  assertEquals(new HashSet<>(partitionHandlingManager(1).getLastStableTopology().getMembers()),new HashSet<>(allMembers));
  assertEquals(new HashSet<>(partitionHandlingManager(2).getLastStableTopology().getMembers()),new HashSet<>(allMembers));
  eventually(new Condition(){
    @Override public boolean isSatisfied() throws Exception {
      for (int i=0; i < caches().size(); i++)       if (partitionHandlingManager(i).getAvailabilityMode() != AvailabilityMode.AVAILABLE)       return false;
      return true;
    }
  }
);
  splitCluster(p0.getNodes(),p1.getNodes());
  TestingUtil.waitForRehashToComplete(cache(p0.node(0)),cache(p0.node(1)));
  partition(0).assertAvailabilityMode(AvailabilityMode.AVAILABLE);
  partition(1).assertAvailabilityMode(AvailabilityMode.DEGRADED_MODE);
  assertEquals(partitionHandlingManager(p1.node(0)).getLastStableTopology().getMembers(),allMembers);
  partition(0).assertKeyAvailableForRead(k0,"v0");
  partition(0).assertKeyAvailableForRead(k1,"v1");
  partition(0).assertKeyAvailableForRead(k2,"v2");
  partition(1).assertKeysNotAvailableForRead(k0,k1,k2);
  assertTrue(dataContainer(p0.node(0)).containsKey(k0));
  assertTrue(dataContainer(p0.node(0)).containsKey(k1));
  assertTrue(dataContainer(p0.node(0)).containsKey(k2));
  assertTrue(dataContainer(p0.node(1)).containsKey(k0));
  assertTrue(dataContainer(p0.node(1)).containsKey(k1));
  assertTrue(dataContainer(p0.node(1)).containsKey(k2));
  assertTrue(dataContainer(p1.node(0)).containsKey(k0));
  assertTrue(dataContainer(p1.node(0)).containsKey(k1));
  assertTrue(dataContainer(p1.node(0)).containsKey(k2));
  partition(0).assertKeyAvailableForWrite(k0,"v00");
  partition(0).assertKeyAvailableForWrite(k1,"v11");
  partition(0).assertKeyAvailableForWrite(k2,"v22");
  partition(1).assertKeyNotAvailableForWrite(k0);
  partition(1).assertKeyNotAvailableForWrite(k1);
  partition(1).assertKeyNotAvailableForWrite(k2);
  partition(0).merge(partition(1));
  assertEquals(new HashSet<>(partitionHandlingManager(0).getLastStableTopology().getMembers()),new HashSet<>(allMembers));
  assertEquals(new HashSet<>(partitionHandlingManager(1).getLastStableTopology().getMembers()),new HashSet<>(allMembers));
  assertEquals(new HashSet<>(partitionHandlingManager(2).getLastStableTopology().getMembers()),new HashSet<>(allMembers));
  partition(0).assertAvailabilityMode(AvailabilityMode.AVAILABLE);
  assertExpectedValue("v00",k0);
  assertExpectedValue("v11",k1);
  assertExpectedValue("v22",k2);
  assertTrue(dataContainer(p0.node(0)).containsKey(k0));
  assertTrue(dataContainer(p0.node(0)).containsKey(k1));
  assertTrue(dataContainer(p0.node(0)).containsKey(k2));
  assertTrue(dataContainer(p0.node(1)).containsKey(k0));
  assertTrue(dataContainer(p0.node(1)).containsKey(k1));
  assertTrue(dataContainer(p0.node(1)).containsKey(k2));
  assertTrue(dataContainer(p1.node(0)).containsKey(k0));
  assertTrue(dataContainer(p1.node(0)).containsKey(k1));
  assertTrue(dataContainer(p1.node(0)).containsKey(k2));
  cache(0).put(k0,"v000");
  cache(1).put(k1,"v111");
  cache(2).put(k2,"v222");
  assertExpectedValue("v000",k0);
  assertExpectedValue("v111",k1);
  assertExpectedValue("v222",k2);
}
