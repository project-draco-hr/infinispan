{
  if (parsingResult.getProjectedPaths() == null) {
    throw new ParsingException("Queries containing grouping and aggregation functions must use projections.");
  }
  LinkedHashMap<PropertyPath,RowPropertyHelper.ColumnMetadata> columns=new LinkedHashMap<PropertyPath,RowPropertyHelper.ColumnMetadata>();
  ObjectPropertyHelper<?> propertyHelper=getFirstPhaseMatcher().getPropertyHelper();
  if (parsingResult.getGroupBy() != null) {
    for (    PropertyPath p : parsingResult.getGroupBy()) {
      if (p.getAggregationType() != null) {
        throw new IllegalStateException("Cannot have aggregate functions in GROUP BY clause");
      }
      if (!columns.containsKey(p)) {
        if (propertyHelper.isRepeatedProperty(parsingResult.getTargetEntityName(),p.getPath())) {
          throw new ParsingException("The property path '" + p + "' cannot be used in the GROUP BY clause because it is multi-valued");
        }
        Class<?> propertyType=propertyHelper.getPrimitivePropertyType(parsingResult.getTargetEntityName(),p.getPath());
        int idx=columns.size();
        columns.put(p,new RowPropertyHelper.ColumnMetadata(idx,"C" + idx,propertyType));
      }
    }
  }
  final int noOfGroupingColumns=columns.size();
  for (int i=0; i < parsingResult.getProjectedPaths().length; i++) {
    PropertyPath p=parsingResult.getProjectedPaths()[i];
    RowPropertyHelper.ColumnMetadata c=columns.get(p);
    if (p.getAggregationType() == null) {
      if (c == null || c.getColumnIndex() >= noOfGroupingColumns) {
        throw new ParsingException("The expression '" + p + "' must be part of an aggregate function or it should be included in the GROUP BY clause");
      }
    }
    if (c == null) {
      Class<?> propertyType=parsingResult.getProjectedTypes()[i];
      int idx=columns.size();
      columns.put(p,new RowPropertyHelper.ColumnMetadata(idx,"C" + idx,propertyType));
    }
  }
  if (parsingResult.getSortFields() != null) {
    for (    SortField sortField : parsingResult.getSortFields()) {
      PropertyPath p=sortField.getPath();
      RowPropertyHelper.ColumnMetadata c=columns.get(p);
      if (p.getAggregationType() == null) {
        if (c == null || c.getColumnIndex() >= noOfGroupingColumns) {
          throw new ParsingException("The expression '" + p + "' must be part of an aggregate function or it should be included in the GROUP BY clause");
        }
      }
      if (c == null) {
        Class<?> propertyType=propertyHelper.getPrimitivePropertyType(parsingResult.getTargetEntityName(),p.getPath());
        int idx=columns.size();
        columns.put(p,new RowPropertyHelper.ColumnMetadata(idx,"C" + idx,propertyType));
      }
    }
  }
  String havingClause=null;
  if (parsingResult.getHavingClause() != null) {
    BooleanExpr normalizedHavingClause=booleanFilterNormalizer.normalize(parsingResult.getHavingClause());
    if (normalizedHavingClause == ConstantBooleanExpr.FALSE) {
      return new EmptyResultQuery(queryFactory,cache,jpqlString,namedParameters,startOffset,maxResults);
    }
    if (normalizedHavingClause != ConstantBooleanExpr.TRUE) {
      havingClause=JPATreePrinter.printTree(swapVariables(normalizedHavingClause,parsingResult.getTargetEntityName(),columns));
    }
  }
  LinkedHashMap<String,Integer> inColumns=new LinkedHashMap<String,Integer>();
  List<FieldAccumulator> accumulators=new LinkedList<FieldAccumulator>();
  RowPropertyHelper.ColumnMetadata[] _columns=new RowPropertyHelper.ColumnMetadata[columns.size()];
  for (  PropertyPath p : columns.keySet()) {
    RowPropertyHelper.ColumnMetadata c=columns.get(p);
    _columns[c.getColumnIndex()]=c;
    String asStringPath=p.asStringPath();
    Integer inIdx=inColumns.get(asStringPath);
    if (inIdx == null) {
      inIdx=inColumns.size();
      inColumns.put(asStringPath,inIdx);
    }
    if (p.getAggregationType() != null) {
      FieldAccumulator acc=FieldAccumulator.makeAccumulator(p.getAggregationType(),inIdx,c.getColumnIndex(),c.getPropertyType());
      accumulators.add(acc);
    }
  }
  FieldAccumulator[] _accumulators=accumulators.toArray(new FieldAccumulator[accumulators.size()]);
  StringBuilder firstPhaseQuery=new StringBuilder();
  firstPhaseQuery.append("SELECT ");
{
    boolean isFirst=true;
    for (    String p : inColumns.keySet()) {
      if (isFirst) {
        isFirst=false;
      }
 else {
        firstPhaseQuery.append(", ");
      }
      firstPhaseQuery.append(JPAQueryGenerator.DEFAULT_ALIAS).append('.').append(p);
    }
  }
  firstPhaseQuery.append(" FROM ").append(parsingResult.getTargetEntityName()).append(' ').append(JPAQueryGenerator.DEFAULT_ALIAS);
  if (parsingResult.getWhereClause() != null) {
    BooleanExpr normalizedWhereClause=booleanFilterNormalizer.normalize(parsingResult.getWhereClause());
    if (normalizedWhereClause == ConstantBooleanExpr.FALSE) {
      return new EmptyResultQuery(queryFactory,cache,jpqlString,namedParameters,startOffset,maxResults);
    }
    if (normalizedWhereClause != ConstantBooleanExpr.TRUE) {
      firstPhaseQuery.append(' ').append(JPATreePrinter.printTree(normalizedWhereClause));
    }
  }
  StringBuilder secondPhaseQuery=new StringBuilder();
  secondPhaseQuery.append("SELECT ");
{
    for (int i=0; i < parsingResult.getProjectedPaths().length; i++) {
      PropertyPath p=parsingResult.getProjectedPaths()[i];
      RowPropertyHelper.ColumnMetadata c=columns.get(p);
      if (i != 0) {
        secondPhaseQuery.append(", ");
      }
      secondPhaseQuery.append(c.getColumnName());
    }
  }
  secondPhaseQuery.append(" FROM Row ");
  if (havingClause != null) {
    secondPhaseQuery.append(' ').append(havingClause);
  }
  if (parsingResult.getSortFields() != null) {
    secondPhaseQuery.append(" ORDER BY ");
    boolean isFirst=true;
    for (    SortField sortField : parsingResult.getSortFields()) {
      if (isFirst) {
        isFirst=false;
      }
 else {
        secondPhaseQuery.append(", ");
      }
      RowPropertyHelper.ColumnMetadata c=columns.get(sortField.getPath());
      secondPhaseQuery.append(c.getColumnName()).append(' ').append(sortField.isAscending() ? "ASC" : "DESC");
    }
  }
  String firstPhaseQueryStr=firstPhaseQuery.toString();
  Query baseQuery=buildQueryNoAggregations(queryFactory,firstPhaseQueryStr,namedParameters,-1,-1,parse(firstPhaseQueryStr,namedParameters));
  String secondPhaseQueryStr=secondPhaseQuery.toString();
  return new AggregatingQuery(queryFactory,cache,secondPhaseQueryStr,namedParameters,noOfGroupingColumns,_accumulators,getObjectFilter(new RowMatcher(_columns),secondPhaseQueryStr,namedParameters),startOffset,maxResults,baseQuery);
}
