{
  final Cache<Object,String> nonOwnerCache=getFirstNonOwner(key);
  final Cache<Object,String> ownerCache=getFirstOwner(key);
  ownerCache.put(key,firstValue);
  CyclicBarrier barrier=new CyclicBarrier(2);
  addBlockingInterceptorBeforeTx(nonOwnerCache,barrier,ReplaceCommand.class,false);
  RpcManager realManager=nonOwnerCache.getAdvancedCache().getComponentRegistry().getComponent(RpcManager.class);
  RpcManager mockManager=mock(RpcManager.class,AdditionalAnswers.delegatesTo(realManager));
  doAnswer(new Answer(){
    @Override public Object answer(    InvocationOnMock invocationOnMock) throws Throwable {
      throw new RemoteException("FAIL",new TimeoutException());
    }
  }
).doAnswer(AdditionalAnswers.delegatesTo(realManager)).when(mockManager).invokeRemotely(anyCollection(),any(ReplicableCommand.class),any(RpcOptions.class));
  TestingUtil.replaceComponent(nonOwnerCache,RpcManager.class,mockManager,true);
  try {
    Future<Boolean> futureReplace=nonOwnerCache.replaceAsync(key,firstValue,secondValue);
    barrier.await(5,TimeUnit.SECONDS);
    Future<String> futureGet=nonOwnerCache.getAsync(key);
    try {
      futureGet.get(100,TimeUnit.MILLISECONDS);
      fail("Get shouldn't return until after the replace completes");
    }
 catch (    TimeoutException e) {
    }
    barrier.await(5,TimeUnit.SECONDS);
    try {
      futureReplace.get(5,TimeUnit.SECONDS);
      fail("Test should have thrown an execution exception");
    }
 catch (    ExecutionException e) {
      assertTrue(e.getCause() instanceof RemoteException);
    }
    try {
      assertEquals(firstValue,futureGet.get(5,TimeUnit.SECONDS));
    }
 catch (    ExecutionException e) {
      assertTrue(e.getCause() instanceof RemoteException);
    }
  }
  finally {
    removeAllBlockingInterceptorsFromCache(nonOwnerCache);
    TestingUtil.replaceComponent(nonOwnerCache,RpcManager.class,realManager,true);
  }
}
