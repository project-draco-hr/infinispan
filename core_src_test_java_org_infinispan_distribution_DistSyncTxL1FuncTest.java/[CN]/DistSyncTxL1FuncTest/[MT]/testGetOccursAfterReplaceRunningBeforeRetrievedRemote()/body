{
  final Cache<Object,String> nonOwnerCache=getFirstNonOwner(key);
  final Cache<Object,String> ownerCache=getFirstOwner(key);
  ownerCache.put(key,firstValue);
  CyclicBarrier barrier=new CyclicBarrier(2);
  addBlockingInterceptorBeforeTx(nonOwnerCache,barrier,ReplaceCommand.class,false);
  try {
    Future<Boolean> futureReplace=nonOwnerCache.replaceAsync(key,firstValue,secondValue);
    barrier.await(5,TimeUnit.SECONDS);
    Future<String> futureGet=nonOwnerCache.getAsync(key);
    try {
      futureGet.get(100,TimeUnit.MILLISECONDS);
      fail("Get shouldn't return until after the replace completes");
    }
 catch (    TimeoutException e) {
    }
    barrier.await(5,TimeUnit.SECONDS);
    assertTrue(futureReplace.get());
    assertEquals(firstValue,futureGet.get(5,TimeUnit.SECONDS));
  }
  finally {
    removeAllBlockingInterceptorsFromCache(nonOwnerCache);
  }
}
