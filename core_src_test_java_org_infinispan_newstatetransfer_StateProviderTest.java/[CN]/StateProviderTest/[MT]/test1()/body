{
  List<Address> members1=new ArrayList<Address>();
  for (int i=0; i < 6; i++) {
    members1.add(new TestAddress(i));
  }
  List<Address> members2=new ArrayList<Address>(members1);
  members2.remove(new TestAddress(0));
  members2.remove(new TestAddress(5));
  members2.add(new TestAddress(6));
  DefaultConsistentHashFactory chf=new DefaultConsistentHashFactory();
  DefaultConsistentHash ch1=chf.create(new MurmurHash3(),2,4,members1);
  DefaultConsistentHash ch2=chf.updateMembers(ch1,members2);
  System.out.println("StateProviderTest.test1 " + ch1.dump());
  System.out.println("StateProviderTest.test1 " + ch2.dump());
  ExecutorService executorService2=mock(ExecutorService.class);
  when(executorService2.submit(any(Runnable.class))).thenAnswer(new Answer<Future<?>>(){
    @Override public Future<?> answer(    InvocationOnMock invocation) throws Throwable {
      return null;
    }
  }
);
  StateProviderImpl stateProvider=new StateProviderImpl(executorService2,configuration,rpcManager,commandsFactory,cacheLoaderManager,dataContainer,transactionTable,stateTransferLock);
  final List<InternalCacheEntry> cacheEntries=new ArrayList<InternalCacheEntry>();
  cacheEntries.add(new ImmortalCacheEntry("key1","value1"));
  cacheEntries.add(new ImmortalCacheEntry("key2","value2"));
  when(dataContainer.iterator()).thenAnswer(new Answer<Iterator<InternalCacheEntry>>(){
    @Override public Iterator<InternalCacheEntry> answer(    InvocationOnMock invocation) throws Throwable {
      return cacheEntries.iterator();
    }
  }
);
  when(transactionTable.getLocalTransactions()).thenReturn(Collections.<LocalTransaction>emptyList());
  when(transactionTable.getRemoteTransactions()).thenReturn(Collections.<RemoteTransaction>emptyList());
  Set<Integer> segments=new HashSet<Integer>();
  for (int i=0; i < 5; i++) {
    segments.add(i);
  }
  List<TransactionInfo> transactions=stateProvider.getTransactionsForSegments(members1.get(0),1,segments);
  assertEquals(0,transactions.size());
  InOrder stateTransferLockVerifier=inOrder(stateTransferLock);
  stateTransferLockVerifier.verify(stateTransferLock).acquireTTExclusiveLock();
  stateTransferLockVerifier.verify(stateTransferLock).releaseTTExclusiveLock();
  Set<Integer> seg=new HashSet<Integer>();
  seg.add(0);
  stateProvider.startOutboundTransfer(new TestAddress(5),1,seg);
  assertTrue(stateProvider.isStateTransferInProgress());
  stateProvider.onTopologyUpdate(2,ch1);
  assertTrue(stateProvider.isStateTransferInProgress());
  stateProvider.shutdown();
  stateProvider.onTopologyUpdate(3,ch2);
  assertFalse(stateProvider.isStateTransferInProgress());
  stateProvider.shutdown();
}
