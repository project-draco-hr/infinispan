{
  String taskId=mcc.getTaskId();
  String tmpCacheName=mcc.getIntermediateCacheName();
  Cache<Object,DeltaAwareList<VOut>> tmpCache=cacheManager.getCache(tmpCacheName);
  if (tmpCache == null) {
    throw new IllegalStateException("Temporary cache for MapReduceTask " + taskId + " named "+ tmpCacheName+ " not found on "+ cdl.getAddress());
  }
  Set<KOut> mapPhaseKeys=new HashSet<KOut>();
  if (mcc.hasCombiner()) {
    Reducer<KOut,VOut> combiner=mcc.getCombiner();
    Cache<?,?> cache=cacheManager.getCache(mcc.getCacheName());
    log.tracef("For m/r task %s invoking combiner %s at %s",taskId,mcc,cdl.getAddress());
    MapReduceTaskLifecycleService taskLifecycleService=MapReduceTaskLifecycleService.getInstance();
    Map<KOut,List<VOut>> combinedMap=new ConcurrentHashMap<KOut,List<VOut>>();
    long start=log.isTraceEnabled() ? timeService.time() : 0;
    try {
      taskLifecycleService.onPreExecute(combiner,cache);
      Map<KOut,List<VOut>> collectedValues=collector.collectedValues();
      for (      Entry<KOut,List<VOut>> e : collectedValues.entrySet()) {
        List<VOut> mapped=e.getValue();
        List<VOut> combined;
        if (mapped.size() == 1) {
          combined=mapped;
        }
 else {
          combined=Arrays.asList(combiner.reduce(e.getKey(),mapped.iterator()));
        }
        combinedMap.put(e.getKey(),combined);
        log.tracef("For m/r task %s combined %s to %s at %s",taskId,e.getKey(),combined,cdl.getAddress());
      }
    }
  finally {
      if (log.isTraceEnabled()) {
        log.tracef("Combine for task %s took %s milliseconds",mcc.getTaskId(),timeService.timeDuration(start,TimeUnit.MILLISECONDS));
      }
      taskLifecycleService.onPostExecute(combiner);
    }
    migrateIntermediateKeys(mcc,mapPhaseKeys,tmpCache,combinedMap);
  }
 else {
    Map<KOut,List<VOut>> collectedValues=collector.collectedValues();
    migrateIntermediateKeys(mcc,mapPhaseKeys,tmpCache,collectedValues);
  }
  return mapPhaseKeys;
}
