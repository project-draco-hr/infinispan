{
  String taskId=mcc.getTaskId();
  String tmpCacheName=mcc.getIntermediateCacheName();
  Cache<IntermediateKey<KOut>,DeltaList<VOut>> tmpCache=cacheManager.getCache(tmpCacheName);
  if (tmpCache == null) {
    throw new IllegalStateException("Temporary cache for MapReduceTask " + taskId + " named "+ tmpCacheName+ " not found on "+ cdl.getAddress());
  }
  Set<KOut> mapPhaseKeys=new HashSet<KOut>();
  DistributionManager dm=tmpCache.getAdvancedCache().getDistributionManager();
  Map<Address,List<KOut>> keysToNodes=mapKeysToNodes(dm,taskId,collectedValues.keySet());
  long start=log.isTraceEnabled() ? timeService.time() : 0;
  tmpCache=tmpCache.getAdvancedCache().withFlags(Flag.IGNORE_RETURN_VALUES);
  try {
    for (    Entry<Address,List<KOut>> entry : keysToNodes.entrySet()) {
      List<KOut> keysHashedToAddress=entry.getValue();
      try {
        log.tracef("For m/r task %s migrating intermediate keys %s to %s",taskId,keysHashedToAddress,entry.getKey());
        for (        KOut key : keysHashedToAddress) {
          List<VOut> values=collectedValues.get(key);
          int entryTransferCount=chunkSize;
          for (int i=0; i < values.size(); i+=entryTransferCount) {
            List<VOut> chunk=values.subList(i,Math.min(values.size(),i + entryTransferCount));
            DeltaList<VOut> delta=new DeltaList<VOut>(chunk);
            tmpCache.put(new IntermediateKey<KOut>(taskId,key),delta);
          }
          mapPhaseKeys.add(key);
        }
      }
 catch (      Exception e) {
        throw new CacheException("Could not move intermediate keys/values for M/R task " + taskId,e);
      }
    }
  }
  finally {
    if (trace) {
      log.tracef("Migrating keys for task %s took %s milliseconds (Migrated %s keys)",mcc.getTaskId(),timeService.timeDuration(start,TimeUnit.MILLISECONDS),mapPhaseKeys.size());
    }
  }
  return mapPhaseKeys;
}
