{
  final Cache<KIn,VIn> cache=cacheManager.getCache(mcc.getCacheName());
  Set<KIn> keys=mcc.getKeys();
  int maxCSize=mcc.getMaxCollectorSize();
  final Mapper<KIn,VIn,KOut,VOut> mapper=mcc.getMapper();
  final boolean inputKeysSpecified=keys != null && !keys.isEmpty();
  MapReduceTaskLifecycleService taskLifecycleService=MapReduceTaskLifecycleService.getInstance();
  final CollectableCollector<KOut,VOut> collector=new SynchronizedCollector<KOut,VOut>(new DefaultCollector<KIn,VIn,KOut,VOut>(mcc,maxCSize));
  DataContainer<KIn,VIn> dc=cache.getAdvancedCache().getDataContainer();
  log.tracef("For m/r task %s invoking %s with input keys %s",mcc.getTaskId(),mcc,keys);
  long start=trace ? timeService.time() : 0;
  try {
    taskLifecycleService.onPreExecute(mapper,cache);
    if (inputKeysSpecified) {
      for (      KIn key : keys) {
        VIn value=cache.get(key);
        if (value != null) {
          mapper.map(key,value,collector);
        }
      }
    }
 else {
      dc.executeTask(new PrimaryOwnerFilter<KIn>(cdl),new DataContainerTask<KIn,VIn>(){
        @Override public void accept(        KIn key,        InternalCacheEntry<KIn,VIn> v){
          VIn value=getValue(v);
          if (value != null) {
            mapper.map(key,value,collector);
          }
        }
      }
);
    }
    if (persistenceManager != null && !inputKeysSpecified) {
      KeyFilter<?> keyFilter=new CompositeKeyFilter<KIn>(new PrimaryOwnerFilter<KIn>(cdl),new CollectionKeyFilter<KIn>(dc.keySet()));
      persistenceManager.processOnAllStores(keyFilter,new MapReduceCacheLoaderTask<KIn,VIn,KOut,VOut>(mapper,collector),true,false);
    }
  }
  finally {
    if (trace) {
      log.tracef("Map phase for task %s took %s milliseconds",mcc.getTaskId(),timeService.timeDuration(start,TimeUnit.MILLISECONDS));
    }
    taskLifecycleService.onPostExecute(mapper);
  }
  return collector;
}
