{
  final Cache<KIn,VIn> cache=cacheManager.getCache(mcc.getCacheName());
  Set<KIn> keys=mcc.getKeys();
  final Mapper<KIn,VIn,KOut,VOut> mapper=mcc.getMapper();
  final boolean inputKeysSpecified=keys != null && !keys.isEmpty();
  MapReduceTaskLifecycleService taskLifecycleService=MapReduceTaskLifecycleService.getInstance();
  final DefaultCollector<KOut,VOut> collector=new DefaultCollector<KOut,VOut>(!inputKeysSpecified);
  DataContainer dc=cache.getAdvancedCache().getDataContainer();
  log.tracef("For m/r task %s invoking %s with input keys %s",mcc.getTaskId(),mcc,keys);
  long start=log.isTraceEnabled() ? timeService.time() : 0;
  try {
    taskLifecycleService.onPreExecute(mapper,cache);
    if (inputKeysSpecified) {
      for (      KIn key : keys) {
        VIn value=cache.get(key);
        mapper.map(key,value,collector);
      }
    }
 else {
      dc.executeTask(new PrimaryOwnerFilter(cdl),new DataContainerTask<KIn,VIn>(){
        @Override public void apply(        Object key,        InternalCacheEntry v){
          VIn value=getValue(v);
          if (value != null) {
            mapper.map((KIn)key,value,collector);
          }
        }
      }
);
    }
    if (persistenceManager != null && !inputKeysSpecified) {
      KeyFilter<?> keyFilter=new CompositeKeyFilter(new PrimaryOwnerFilter(cdl),new CollectionKeyFilter(dc.keySet()));
      persistenceManager.processOnAllStores(keyFilter,new MapReduceCacheLoaderTask(mapper,collector),true,false);
    }
  }
  finally {
    if (log.isTraceEnabled()) {
      log.tracef("Map phase for task %s took %s milliseconds",mcc.getTaskId(),timeService.timeDuration(start,TimeUnit.MILLISECONDS));
    }
    taskLifecycleService.onPostExecute(mapper);
  }
  return collector;
}
