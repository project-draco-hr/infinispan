{
  Cache<KIn,VIn> cache=cacheManager.getCache(mcc.getCacheName());
  Set<KIn> keys=mcc.getKeys();
  Set<KIn> inputKeysCopy=null;
  Mapper<KIn,VIn,KOut,VOut> mapper=mcc.getMapper();
  final DistributionManager dm=cache.getAdvancedCache().getDistributionManager();
  boolean inputKeysSpecified=keys != null && !keys.isEmpty();
  Set<KIn> inputKeys=keys;
  if (!inputKeysSpecified) {
    inputKeys=filterLocalPrimaryOwner(cache.getAdvancedCache().withFlags(Flag.SKIP_CACHE_LOAD).keySet(),dm);
  }
 else {
    inputKeysCopy=new HashSet<KIn>(keys);
  }
  MapReduceTaskLifecycleService taskLifecycleService=MapReduceTaskLifecycleService.getInstance();
  DefaultCollector<KOut,VOut> collector=new DefaultCollector<KOut,VOut>();
  log.tracef("For m/r task %s invoking %s with input keys %s",mcc.getTaskId(),mcc,inputKeys);
  int interruptCount=0;
  long start=log.isTraceEnabled() ? timeService.time() : 0;
  try {
    taskLifecycleService.onPreExecute(mapper,cache);
    for (    KIn key : inputKeys) {
      if (checkInterrupt(interruptCount++) && Thread.currentThread().isInterrupted())       throw new InterruptedException();
      VIn value=cache.get(key);
      mapper.map(key,value,collector);
      if (inputKeysSpecified) {
        inputKeysCopy.remove(key);
      }
    }
    if (persistenceManager != null) {
      AdvancedCacheLoader.KeyFilter keyFilter;
      if (inputKeysSpecified) {
        keyFilter=new CollectionKeyFilter(filterLocalPrimaryOwner(inputKeysCopy,dm),true);
      }
 else {
        keyFilter=new CompositeFilter(new PrimaryOwnerFilter(cdl),new CollectionKeyFilter(inputKeys));
      }
      persistenceManager.processOnAllStores(keyFilter,new MapReduceCacheLoaderTask(mapper,collector),new WithinThreadExecutor(),true,false);
    }
  }
  finally {
    if (log.isTraceEnabled()) {
      log.tracef("Map phase for task %s took %s milliseconds",mcc.getTaskId(),timeService.timeDuration(start,TimeUnit.MILLISECONDS));
    }
    taskLifecycleService.onPostExecute(mapper);
  }
  return collector;
}
