{
  final Cache<KIn,VIn> cache=cacheManager.getCache(mcc.getCacheName());
  Set<KIn> keys=mcc.getKeys();
  int maxCSize=mcc.getMaxCollectorSize();
  final Mapper<KIn,VIn,KOut,VOut> mapper=mcc.getMapper();
  final boolean inputKeysSpecified=keys != null && !keys.isEmpty();
  MapReduceTaskLifecycleService taskLifecycleService=MapReduceTaskLifecycleService.getInstance();
  DataContainer<KIn,VIn> dc=cache.getAdvancedCache().getDataContainer();
  log.tracef("For m/r task %s invoking %s with input keys %s",mcc.getTaskId(),mcc,mcc.getKeys());
  long start=log.isTraceEnabled() ? timeService.time() : 0;
  final Set<KOut> intermediateKeys=new HashSet<KOut>();
  try {
    taskLifecycleService.onPreExecute(mapper,cache);
    if (inputKeysSpecified) {
      DefaultCollector<KIn,VIn,KOut,VOut> c=new DefaultCollector<KIn,VIn,KOut,VOut>(mcc,maxCSize);
      for (      KIn key : keys) {
        VIn value=cache.get(key);
        if (value != null) {
          mapper.map(key,value,c);
        }
      }
      combine(mcc,c);
      Set<KOut> s=migrateIntermediateKeysAndValues(mcc,c.collectedValues());
      intermediateKeys.addAll(s);
    }
 else {
      MapCombineTask<KIn,VIn,KOut,VOut> task=new MapCombineTask<KIn,VIn,KOut,VOut>(mcc,maxCSize);
      dc.executeTask(new PrimaryOwnerFilter<KIn>(cdl),task);
      intermediateKeys.addAll(task.getMigratedIntermediateKeys());
      Map<KOut,List<VOut>> combinedValues=task.collectedValues();
      Set<KOut> lastOne=migrateIntermediateKeysAndValues(mcc,combinedValues);
      intermediateKeys.addAll(lastOne);
    }
    if (persistenceManager != null && !inputKeysSpecified) {
      KeyFilter<KIn> keyFilter=new CompositeKeyFilter<KIn>(new PrimaryOwnerFilter<KIn>(cdl),new CollectionKeyFilter<KIn>(dc.keySet()));
      MapCombineTask<KIn,VIn,KOut,VOut> task=new MapCombineTask<KIn,VIn,KOut,VOut>(mcc,maxCSize);
      persistenceManager.processOnAllStores(keyFilter,task,true,false);
      intermediateKeys.addAll(task.getMigratedIntermediateKeys());
      Map<KOut,List<VOut>> combinedValues=task.collectedValues();
      Set<KOut> lastOne=migrateIntermediateKeysAndValues(mcc,combinedValues);
      intermediateKeys.addAll(lastOne);
    }
  }
  finally {
    if (log.isTraceEnabled()) {
      log.tracef("Map phase for task %s took %s milliseconds",mcc.getTaskId(),timeService.timeDuration(start,TimeUnit.MILLISECONDS));
    }
    taskLifecycleService.onPostExecute(mapper);
  }
  return intermediateKeys;
}
