{
  Set<HashEntry<K,V>> evicted=Collections.emptySet();
  if (currentLIRSize + 1 < lirSizeLimit) {
    currentLIRSize++;
    e.transitionToLIRResident();
    stack.put(e.hashCode(),e);
  }
 else {
    if (queue.size() < hirSizeLimit) {
      queue.addLast(e);
    }
 else {
      boolean inStack=stack.containsKey(e.hashCode());
      HashEntry<K,V> first=queue.removeFirst();
      first.transitionHIRResidentToHIRNonResident();
      stack.put(e.hashCode(),e);
      evicted=new HashSet<HashEntry<K,V>>();
      if (inStack) {
        e.transitionToLIRResident();
        switchBottomostLIRtoHIRAndPrune(evicted);
      }
 else {
        queue.addLast(e);
        evicted.add(first);
      }
      removeFromSegment(evicted);
    }
  }
  return evicted;
}
