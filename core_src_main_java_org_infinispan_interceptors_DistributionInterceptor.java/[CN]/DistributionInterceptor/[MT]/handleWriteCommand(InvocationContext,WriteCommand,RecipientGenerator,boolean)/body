{
  boolean localModeForced=isLocalModeForced(ctx) || isSingleOwnerAndLocal(recipientGenerator);
  if (!skipRemoteGet)   remoteGetBeforeWrite(ctx,command.isConditional(),recipientGenerator);
  if (localModeForced) {
    log.trace("LOCAL mode forced.  No RPC needed.");
    return invokeNextInterceptor(ctx,command);
  }
  Object returnValue=invokeNextInterceptor(ctx,command);
  if (command.isSuccessful()) {
    if (!ctx.isInTxScope()) {
      if (ctx.isOriginLocal()) {
        List<Address> rec=recipientGenerator.generateRecipients();
        if (trace)         log.trace("Invoking command {0} on hosts {1}",command,rec);
        boolean useFuture=ctx.isUseFutureReturnType();
        boolean sync=isSynchronous(ctx);
        NotifyingNotifiableFuture<Object> future=flushL1Cache(rec == null ? 0 : rec.size(),recipientGenerator.getKeys(),returnValue,sync);
        if (useFuture) {
          if (future == null)           future=new NotifyingFutureImpl(returnValue);
          rpcManager.invokeRemotelyInFuture(rec,command,future);
          return future;
        }
 else {
          rpcManager.invokeRemotely(rec,command,sync);
          if (future != null && !sync)           future.get();
        }
      }
    }
 else {
      ((TxInvocationContext)ctx).addAffectedKeys(recipientGenerator.getKeys());
    }
  }
  return returnValue;
}
