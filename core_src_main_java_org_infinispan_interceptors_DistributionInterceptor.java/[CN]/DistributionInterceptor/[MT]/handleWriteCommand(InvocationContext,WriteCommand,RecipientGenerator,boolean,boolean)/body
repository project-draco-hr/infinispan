{
  if (ctx.isOriginLocal() && !skipRemoteGet)   remoteGetBeforeWrite(ctx,command.isConditional(),recipientGenerator);
  boolean sync=isSynchronous(ctx);
  if (isLocalModeForced(ctx)) {
    return invokeNextInterceptor(ctx,command);
  }
  Object returnValue=invokeNextInterceptor(ctx,command);
  if (command.isSuccessful()) {
    if (!ctx.isInTxScope()) {
      NotifyingNotifiableFuture<Object> futureToReturn=null;
      Future<?> invalidationFuture=null;
      if (ctx.isOriginLocal()) {
        int newCacheViewId=-1;
        stateTransferLock.waitForStateTransferToEnd(ctx,command,newCacheViewId);
        List<Address> rec=recipientGenerator.generateRecipients();
        int numCallRecipients=rec == null ? 0 : rec.size();
        if (trace)         log.tracef("Invoking command %s on hosts %s",command,rec);
        boolean useFuture=ctx.isUseFutureReturnType();
        if (isL1CacheEnabled && !skipL1Invalidation)         if (rpcManager.getTransport().getMembers().size() > numCallRecipients) {
          if (trace)           log.tracef("Put occurring on node, requesting L1 cache invalidation for keys %s. Other data owners are %s",command.getAffectedKeys(),dm.getAffectedNodes(command.getAffectedKeys()));
          if (useFuture) {
            futureToReturn=l1Manager.flushCache(recipientGenerator.getKeys(),returnValue,ctx.getOrigin(),!(command instanceof RemoveCommand));
          }
 else {
            invalidationFuture=l1Manager.flushCacheWithSimpleFuture(recipientGenerator.getKeys(),returnValue,ctx.getOrigin(),!(command instanceof RemoveCommand));
          }
        }
 else {
          if (trace)           log.tracef("Not performing invalidation! numCallRecipients=%s",numCallRecipients);
        }
        if (!isSingleOwnerAndLocal(recipientGenerator)) {
          if (useFuture) {
            if (futureToReturn == null)             futureToReturn=new NotifyingFutureImpl(returnValue);
            rpcManager.invokeRemotelyInFuture(rec,command,futureToReturn);
            return futureToReturn;
          }
 else {
            rpcManager.invokeRemotely(rec,command,sync);
          }
        }
 else         if (useFuture && futureToReturn != null) {
          return futureToReturn;
        }
        if (invalidationFuture != null && sync) {
          invalidationFuture.get();
          if (trace)           log.tracef("Finished invalidating keys %s ",recipientGenerator.getKeys());
        }
      }
 else {
        if (isL1CacheEnabled && !skipL1Invalidation) {
          if (trace)           log.tracef("Put occurring on node, requesting cache invalidation for keys %s. Origin of command is remote",command.getAffectedKeys());
          invalidationFuture=l1Manager.flushCacheWithSimpleFuture(recipientGenerator.getKeys(),returnValue,ctx.getOrigin(),!(command instanceof RemoveCommand));
          if (sync) {
            try {
              invalidationFuture.get();
            }
 catch (            ExecutionException ee) {
              if (!(ee.getCause() instanceof SuspectException)) {
                throw ee.getCause();
              }
            }
            if (trace)             log.tracef("Finished invalidating keys %s ",recipientGenerator.getKeys());
          }
        }
      }
    }
  }
  return returnValue;
}
