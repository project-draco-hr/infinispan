{
  if (ctx.isOriginLocal() && !skipRemoteGet)   remoteGetBeforeWrite(ctx,command.isConditional(),recipientGenerator);
  boolean sync=isSynchronous(ctx);
  if (isLocalModeForced(ctx)) {
    return invokeNextInterceptor(ctx,command);
  }
  Object returnValue=invokeNextInterceptor(ctx,command);
  if (command.isSuccessful()) {
    if (!ctx.isInTxScope()) {
      if (ctx.isOriginLocal()) {
        List<Address> rec=recipientGenerator.generateRecipients();
        if (trace)         log.trace("Invoking command %s on hosts %s",command,rec);
        boolean useFuture=ctx.isUseFutureReturnType();
        NotifyingNotifiableFuture<Object> future=null;
        if (!skipL1Invalidation)         future=flushL1Cache(rec == null ? 0 : rec.size(),recipientGenerator.getKeys(),returnValue);
        if (!isSingleOwnerAndLocal(recipientGenerator)) {
          if (useFuture) {
            if (future == null)             future=new NotifyingFutureImpl(returnValue);
            rpcManager.invokeRemotelyInFuture(rec,command,future);
            return future;
          }
 else {
            rpcManager.invokeRemotely(rec,command,sync);
          }
        }
 else         if (useFuture && future != null) {
          return future;
        }
        if (future != null && sync) {
          future.get();
          if (trace)           log.trace("Finished invalidating keys %s ",recipientGenerator.getKeys());
        }
      }
    }
 else {
      ((TxInvocationContext)ctx).addAffectedKeys(recipientGenerator.getKeys());
    }
  }
  return returnValue;
}
