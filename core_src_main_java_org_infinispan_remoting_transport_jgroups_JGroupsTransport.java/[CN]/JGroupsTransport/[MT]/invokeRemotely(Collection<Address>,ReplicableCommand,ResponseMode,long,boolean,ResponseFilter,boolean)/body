{
  if (recipients != null && recipients.isEmpty()) {
    log.trace("Destination list is empty: no need to send message");
    return Collections.emptyMap();
  }
  if (trace)   log.tracef("dests=%s, command=%s, mode=%s, timeout=%s",recipients,rpcCommand,mode,timeout);
  if (mode.isSynchronous() && recipients != null && !getMembers().containsAll(recipients)) {
    if (mode == ResponseMode.SYNCHRONOUS)     throw new SuspectException("One or more nodes have left the cluster while replicating command " + rpcCommand);
 else {
      recipients=new ArrayList<Address>(recipients);
      recipients.retainAll(getMembers());
    }
  }
  boolean asyncMarshalling=mode == ResponseMode.ASYNCHRONOUS;
  if (!usePriorityQueue && (ResponseMode.SYNCHRONOUS == mode || ResponseMode.SYNCHRONOUS_IGNORE_LEAVERS == mode))   usePriorityQueue=true;
  boolean broadcast=recipients == null || recipients.size() == members.size();
  RspList<Object> rsps=dispatcher.invokeRemoteCommands(toJGroupsAddressVector(recipients),rpcCommand,toJGroupsMode(mode),timeout,recipients != null,usePriorityQueue,toJGroupsFilter(responseFilter),supportReplay,asyncMarshalling,broadcast);
  if (mode.isAsynchronous())   return Collections.emptyMap();
  if (rsps == null)   return Collections.emptyMap();
  Map<Address,Response> retval=new HashMap<Address,Response>(rsps.size());
  boolean ignoreLeavers=mode == ResponseMode.SYNCHRONOUS_IGNORE_LEAVERS || mode == ResponseMode.WAIT_FOR_VALID_RESPONSE;
  boolean noValidResponses=true;
  for (  Rsp<Object> rsp : rsps.values()) {
    noValidResponses&=parseResponseAndAddToResponseList(rsp.getValue(),rsp.getException(),retval,rsp.wasSuspected(),rsp.wasReceived(),fromJGroupsAddress(rsp.getSender()),responseFilter != null,ignoreLeavers);
  }
  if (noValidResponses)   throw new TimeoutException("Timed out waiting for valid responses!");
  return retval;
}
