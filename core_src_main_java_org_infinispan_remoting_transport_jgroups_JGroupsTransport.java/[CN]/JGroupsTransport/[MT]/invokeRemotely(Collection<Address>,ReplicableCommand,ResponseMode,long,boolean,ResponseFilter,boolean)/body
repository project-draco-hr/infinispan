{
  if (recipients != null && recipients.isEmpty()) {
    log.trace("Destination list is empty: no need to send message");
    return Collections.emptyMap();
  }
  if (trace)   log.tracef("dests=%s, command=%s, mode=%s, timeout=%s",recipients,rpcCommand,mode,timeout);
  Address self=getAddress();
  if (mode.isSynchronous() && recipients != null && !getMembers().containsAll(recipients)) {
    if (mode == ResponseMode.SYNCHRONOUS)     throw new SuspectException("One or more nodes have left the cluster while replicating command " + rpcCommand);
 else {
      recipients=new HashSet<Address>(recipients);
      recipients.retainAll(getMembers());
    }
  }
  boolean asyncMarshalling=mode == ResponseMode.ASYNCHRONOUS;
  if (!usePriorityQueue && (ResponseMode.SYNCHRONOUS == mode || ResponseMode.SYNCHRONOUS_IGNORE_LEAVERS == mode))   usePriorityQueue=true;
  List<org.jgroups.Address> jgAddressList=toJGroupsAddressListExcludingSelf(recipients);
  int membersSize=members.size();
  boolean broadcast=jgAddressList == null || recipients.size() == membersSize;
  if (membersSize < 3 || (jgAddressList != null && jgAddressList.size() < 2))   broadcast=false;
  RspList<Object> rsps=null;
  Response singleResponse=null;
  org.jgroups.Address singleJGAddress=null;
  if (broadcast) {
    rsps=dispatcher.broadcastRemoteCommands(rpcCommand,toJGroupsMode(mode),timeout,recipients != null,usePriorityQueue,toJGroupsFilter(responseFilter),supportReplay,asyncMarshalling);
  }
 else {
    if (jgAddressList == null || !jgAddressList.isEmpty()) {
      boolean singleRecipient=jgAddressList != null && jgAddressList.size() == 1;
      boolean skipRpc=false;
      if (jgAddressList == null) {
        ArrayList<Address> others=new ArrayList<Address>(members);
        others.remove(self);
        skipRpc=others.isEmpty();
        singleRecipient=others.size() == 1;
        if (singleRecipient)         singleJGAddress=toJGroupsAddress(others.get(0));
      }
      if (!skipRpc) {
        if (singleRecipient) {
          if (singleJGAddress == null)           singleJGAddress=jgAddressList.get(0);
          singleResponse=dispatcher.invokeRemoteCommand(singleJGAddress,rpcCommand,toJGroupsMode(mode),timeout,usePriorityQueue,supportReplay,asyncMarshalling);
        }
 else {
          rsps=dispatcher.invokeRemoteCommands(jgAddressList,rpcCommand,toJGroupsMode(mode),timeout,recipients != null,usePriorityQueue,toJGroupsFilter(responseFilter),supportReplay,asyncMarshalling);
        }
      }
    }
  }
  if (mode.isAsynchronous())   return Collections.emptyMap();
  Map<Address,Response> responses;
  if (rsps == null) {
    if (singleJGAddress == null || (singleResponse == null && rpcCommand instanceof ClusteredGetCommand)) {
      responses=Collections.emptyMap();
    }
 else {
      responses=Collections.singletonMap(fromJGroupsAddress(singleJGAddress),singleResponse);
    }
  }
 else {
    Map<Address,Response> retval=new HashMap<Address,Response>(rsps.size());
    boolean ignoreLeavers=mode == ResponseMode.SYNCHRONOUS_IGNORE_LEAVERS || mode == ResponseMode.WAIT_FOR_VALID_RESPONSE;
    boolean noValidResponses=true;
    for (    Rsp<Object> rsp : rsps.values()) {
      noValidResponses&=parseResponseAndAddToResponseList(rsp.getValue(),rsp.getException(),retval,rsp.wasSuspected(),rsp.wasReceived(),fromJGroupsAddress(rsp.getSender()),responseFilter != null,ignoreLeavers);
    }
    if (noValidResponses)     throw new TimeoutException("Timed out waiting for valid responses!");
    responses=retval;
  }
  return responses;
}
