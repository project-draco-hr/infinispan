{
  if (rpcCommands == null || rpcCommands.isEmpty()) {
    log.trace("Destination list is empty: no need to send message");
    return InfinispanCollections.emptyMap();
  }
  if (trace)   log.tracef("commands=%s, mode=%s, timeout=%s",rpcCommands,mode,timeout);
  boolean ignoreLeavers=mode == ResponseMode.SYNCHRONOUS_IGNORE_LEAVERS || mode == ResponseMode.WAIT_FOR_VALID_RESPONSE;
  List<Address> members=getMembers();
  Map<org.jgroups.Address,ReplicableCommand> forJGroups=new HashMap<>();
  for (  Map.Entry<Address,ReplicableCommand> entry : rpcCommands.entrySet()) {
    if (!members.contains(entry.getKey())) {
      if (mode.isSynchronous() && ignoreLeavers) {
        throw new SuspectException("One or more nodes have left the cluster while replicating commands " + rpcCommands);
      }
    }
 else {
      forJGroups.put(toJGroupsAddress(entry.getKey()),entry.getValue());
    }
  }
  boolean asyncMarshalling=mode == ResponseMode.ASYNCHRONOUS;
  if (!usePriorityQueue && (ResponseMode.SYNCHRONOUS == mode || ResponseMode.SYNCHRONOUS_IGNORE_LEAVERS == mode))   usePriorityQueue=true;
  RspList<Object> rsps=dispatcher.invokeRemoteCommands(forJGroups,toJGroupsMode(mode),timeout,usePriorityQueue,asyncMarshalling,ignoreLeavers);
  if (mode.isAsynchronous() || rsps == null)   return InfinispanCollections.emptyMap();
  Set<Address> suspectedAddresses=new HashSet<>();
  Map<Address,Response> retval=new HashMap<Address,Response>(rsps.size());
  boolean noValidResponses=true;
  for (  Entry<org.jgroups.Address,Rsp<Object>> entry : rsps.entrySet()) {
    Rsp<Object> rsp=entry.getValue();
    Object value=rsp.getValue();
    if (value instanceof ExceptionResponse) {
      ExceptionResponse exceptionResponse=(ExceptionResponse)value;
      if (exceptionResponse.getException() instanceof SuspectedException) {
        suspectedAddresses.add(fromJGroupsAddress(entry.getKey()));
        continue;
      }
    }
    noValidResponses&=parseResponseAndAddToResponseList(value,rsp.getException(),retval,rsp.wasSuspected(),rsp.wasReceived(),fromJGroupsAddress(rsp.getSender()),responseFilter != null,ignoreLeavers);
  }
  if (noValidResponses) {
    boolean throwException;
    if (ignoreLeavers) {
      throwException=!suspectedAddresses.containsAll(rpcCommands.keySet());
    }
 else {
      throwException=true;
    }
    if (throwException)     throw new TimeoutException("Timed out waiting for valid responses!");
  }
  return retval;
}
