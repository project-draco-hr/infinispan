{
  if (recipients != null && recipients.isEmpty()) {
    log.trace("Destination list is empty: no need to send message");
    return InfinispanCollections.emptyMap();
  }
  boolean totalOrder=deliverOrder == DeliverOrder.TOTAL;
  if (trace)   log.tracef("dests=%s, command=%s, mode=%s, timeout=%s",recipients,rpcCommand,mode,timeout);
  Address self=getAddress();
  boolean ignoreLeavers=mode == ResponseMode.SYNCHRONOUS_IGNORE_LEAVERS || mode == ResponseMode.WAIT_FOR_VALID_RESPONSE;
  if (mode.isSynchronous() && recipients != null && !getMembers().containsAll(recipients)) {
    if (!ignoreLeavers) {
      throw new SuspectException("One or more nodes have left the cluster while replicating command " + rpcCommand);
    }
  }
  List<org.jgroups.Address> jgAddressList=toJGroupsAddressListExcludingSelf(recipients,totalOrder);
  int membersSize=members.size();
  boolean broadcast=jgAddressList == null || recipients.size() == membersSize;
  if (membersSize < 3 || (jgAddressList != null && jgAddressList.size() < 2))   broadcast=false;
  RspList<Object> rsps=null;
  Response singleResponse=null;
  org.jgroups.Address singleJGAddress=null;
  if (broadcast) {
    rsps=dispatcher.broadcastRemoteCommands(rpcCommand,toJGroupsMode(mode),timeout,toJGroupsFilter(responseFilter),deliverOrder,ignoreLeavers);
  }
 else   if (totalOrder) {
    rsps=dispatcher.invokeRemoteCommands(jgAddressList,rpcCommand,toJGroupsMode(mode),timeout,toJGroupsFilter(responseFilter),deliverOrder,ignoreLeavers);
  }
 else {
    if (jgAddressList == null || !jgAddressList.isEmpty()) {
      boolean singleRecipient=!ignoreLeavers && jgAddressList != null && jgAddressList.size() == 1;
      boolean skipRpc=false;
      if (jgAddressList == null) {
        ArrayList<Address> others=new ArrayList<>(members);
        others.remove(self);
        skipRpc=others.isEmpty();
        singleRecipient=!ignoreLeavers && others.size() == 1;
        if (singleRecipient)         singleJGAddress=toJGroupsAddress(others.get(0));
      }
      if (!skipRpc) {
        if (singleRecipient) {
          if (singleJGAddress == null)           singleJGAddress=jgAddressList.get(0);
          singleResponse=dispatcher.invokeRemoteCommand(singleJGAddress,rpcCommand,toJGroupsMode(mode),timeout,deliverOrder);
        }
 else {
          rsps=dispatcher.invokeRemoteCommands(jgAddressList,rpcCommand,toJGroupsMode(mode),timeout,toJGroupsFilter(responseFilter),deliverOrder,ignoreLeavers);
        }
      }
    }
  }
  if (mode.isAsynchronous())   return InfinispanCollections.emptyMap();
  Map<Address,Response> responses;
  if (rsps == null) {
    if (singleJGAddress == null || (singleResponse == null && rpcCommand instanceof ClusteredGetCommand)) {
      responses=InfinispanCollections.emptyMap();
    }
 else {
      responses=Collections.singletonMap(fromJGroupsAddress(singleJGAddress),singleResponse);
    }
  }
 else {
    Map<Address,Response> retval=new HashMap<>(rsps.size());
    boolean noValidResponses=true;
    for (    Rsp<Object> rsp : rsps.values()) {
      noValidResponses&=parseResponseAndAddToResponseList(rsp.getValue(),rsp.getException(),retval,rsp.wasSuspected(),rsp.wasReceived(),fromJGroupsAddress(rsp.getSender()),responseFilter != null,ignoreLeavers);
    }
    if (noValidResponses) {
      boolean throwRpcException=false;
      if (responseFilter != null) {
        for (        Rsp<Object> rsp : rsps.values()) {
          if (rsp.wasReceived()) {
            throwRpcException=true;
            break;
          }
        }
      }
      if (throwRpcException) {
        throw new RpcException(String.format("Received invalid responses from all of %s",recipients));
      }
 else {
        throw new TimeoutException("Timed out waiting for valid responses!");
      }
    }
    responses=retval;
  }
  return responses;
}
