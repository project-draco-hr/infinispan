{
  LinkedEntry lastLink=null, link1, prev2;
  long backOffNanos=100000;
  while (true) {
    link1=currentEntry.p;
    if (isMarkedForRemoval(link1))     break;
    prev2=suggestedPreviousEntry.n;
    if (isMarkedForRemoval(prev2)) {
      if (lastLink != null) {
        markPrevReference(suggestedPreviousEntry);
        lastLink.casNext(suggestedPreviousEntry,prev2.p);
        suggestedPreviousEntry=lastLink;
        lastLink=null;
        continue;
      }
      prev2=suggestedPreviousEntry.p;
      suggestedPreviousEntry=prev2;
      continue;
    }
    if (prev2 != currentEntry) {
      lastLink=suggestedPreviousEntry;
      suggestedPreviousEntry=prev2;
      continue;
    }
    if (currentEntry.casPrev(link1,suggestedPreviousEntry)) {
      if (isMarkedForRemoval(suggestedPreviousEntry.p))       continue;
      break;
    }
    LockSupport.parkNanos(backOffNanos);
    backOffNanos<<=1;
  }
  return suggestedPreviousEntry;
}
