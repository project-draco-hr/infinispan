{
  final int concurrencyLevel=configuration.locking().concurrencyLevel();
  localTransactions=CollectionFactory.makeConcurrentMap(concurrencyLevel,0.75f,concurrencyLevel,new IdentityEquivalence<Transaction>(),AnyEquivalence.getInstance());
  globalToLocalTransactions=CollectionFactory.makeConcurrentMap(concurrencyLevel,0.75f,concurrencyLevel);
  boolean transactional=configuration.transaction().transactionMode().isTransactional();
  if (clustered && transactional) {
    minTopologyRecalculationLock=new ReentrantLock();
    remoteTransactions=CollectionFactory.makeConcurrentMap(concurrencyLevel,0.75f,concurrencyLevel);
    ThreadFactory tf=new ThreadFactory(){
      @Override public Thread newThread(      Runnable r){
        String address=rpcManager != null ? rpcManager.getTransport().getAddress().toString() : "local";
        Thread th=new Thread(r,"TxCleanupService," + cacheName + ","+ address);
        th.setDaemon(true);
        return th;
      }
    }
;
    executorService=Executors.newSingleThreadScheduledExecutor(tf);
    notifier.addListener(this);
    cacheManagerNotifier.addListener(this);
    boolean totalOrder=configuration.transaction().transactionProtocol().isTotalOrder();
    if (!totalOrder) {
      completedTransactionsInfo=new CompletedTransactionsInfo();
      long interval=configuration.transaction().reaperWakeUpInterval();
      executorService.scheduleAtFixedRate(new Runnable(){
        @Override public void run(){
          completedTransactionsInfo.cleanupCompletedTransactions();
        }
      }
,interval,interval,TimeUnit.MILLISECONDS);
      executorService.scheduleAtFixedRate(new Runnable(){
        @Override public void run(){
          cleanupTimedOutTransactions();
        }
      }
,interval,interval,TimeUnit.MILLISECONDS);
    }
  }
  running=true;
}
