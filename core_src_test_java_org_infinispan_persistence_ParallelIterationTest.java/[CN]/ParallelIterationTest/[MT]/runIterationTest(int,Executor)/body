{
  int numEntries=insertData();
  final ConcurrentMap<Object,Object> entries=new ConcurrentHashMap<>();
  final ConcurrentHashSet<Thread> threads=new ConcurrentHashSet<>();
  final AtomicBoolean sameKeyMultipleTimes=new AtomicBoolean();
  final CyclicBarrier barrier=new CyclicBarrier(numThreads);
  final AtomicBoolean brokenBarrier=new AtomicBoolean(false);
  store.process(null,new AdvancedCacheLoader.CacheLoaderTask(){
    @Override public void processEntry(    MarshalledEntry marshalledEntry,    AdvancedCacheLoader.TaskContext taskContext) throws InterruptedException {
      Object existing=entries.put(marshalledEntry.getKey(),marshalledEntry.getValue());
      if (threads.add(Thread.currentThread())) {
        try {
          barrier.await(1,TimeUnit.MINUTES);
        }
 catch (        BrokenBarrierException|TimeoutException e) {
          log.warn("Exception occurred while waiting for barrier",e);
          brokenBarrier.set(true);
        }
      }
      if (existing != null) {
        log.warnf("Already a value present for key %s: %s",marshalledEntry.getKey(),existing);
        sameKeyMultipleTimes.set(true);
      }
    }
  }
,persistenceExecutor1,true,true);
  assertFalse(sameKeyMultipleTimes.get());
  assertFalse(brokenBarrier.get());
  for (int i=0; i < numEntries; i++) {
    assertEquals(entries.get(i),i,"For key" + i);
  }
  assertEquals(threads.size(),numThreads);
}
