{
  if (leafNodes == null)   throw new IllegalArgumentException();
  byte[] newPrefix;
  byte[][] newKeyParts;
  LeafNode[] newLeafNodes;
  if (leafNodes.length == 0) {
    overwriteHook.setOverwritten(false,-1,-1);
    if (overwriteHook.check(-1,-1)) {
      return new IndexNode(segment,prefix,keyParts,new LeafNode[]{new LeafNode(file,offset)});
    }
 else {
      segment.getCompactor().free(file,size);
      return this;
    }
  }
  int insertPart=getInsertionPoint(key);
  EntryRecord hak=null;
  try {
    hak=leafNodes[insertPart].loadHeaderAndKey(segment.getFileProvider(),segment.getTimeService());
  }
 catch (  IndexNodeOutdatedException e) {
    throw new IllegalStateException("Index cannot be outdated for segment updater thread",e);
  }
  int keyComp=Integer.MAX_VALUE;
  if (hak == null || hak.getKey() == null || (keyComp=compare(hak.getKey(),key)) == 0) {
    if (offset >= 0) {
      if (overwriteHook.check(leafNodes[insertPart].file,leafNodes[insertPart].offset)) {
        newPrefix=prefix;
        newKeyParts=keyParts;
        newLeafNodes=new LeafNode[leafNodes.length];
        System.arraycopy(leafNodes,0,newLeafNodes,0,leafNodes.length);
        if (trace) {
          log.trace(String.format("Overwriting %d:%d (%s) with %d:%d",leafNodes[insertPart].file,leafNodes[insertPart].offset,hak == null ? "removed" : (hak.getKey() == null ? "expired" : "matching"),file,offset));
        }
        newLeafNodes[insertPart]=new LeafNode(file,offset);
        if (hak != null) {
          segment.getCompactor().free(leafNodes[insertPart].file,hak.getHeader().totalLength());
        }
        overwriteHook.setOverwritten(true,leafNodes[insertPart].file,leafNodes[insertPart].offset);
      }
 else {
        overwriteHook.setOverwritten(false,-1,-1);
        segment.getCompactor().free(file,size);
        return this;
      }
    }
 else {
      overwriteHook.setOverwritten(keyComp == 0,leafNodes[insertPart].file,leafNodes[insertPart].offset);
      if (keyParts.length <= 1) {
        newPrefix=new byte[0];
        newKeyParts=new byte[0][];
      }
 else {
        newPrefix=prefix;
        newKeyParts=new byte[keyParts.length - 1][];
        if (insertPart == keyParts.length) {
          System.arraycopy(keyParts,0,newKeyParts,0,newKeyParts.length);
        }
 else {
          System.arraycopy(keyParts,0,newKeyParts,0,insertPart);
          System.arraycopy(keyParts,insertPart + 1,newKeyParts,insertPart,newKeyParts.length - insertPart);
        }
      }
      if (leafNodes.length > 0) {
        newLeafNodes=new LeafNode[leafNodes.length - 1];
        System.arraycopy(leafNodes,0,newLeafNodes,0,insertPart);
        System.arraycopy(leafNodes,insertPart + 1,newLeafNodes,insertPart,newLeafNodes.length - insertPart);
      }
 else {
        newLeafNodes=leafNodes;
      }
      if (hak != null) {
        segment.getCompactor().free(leafNodes[insertPart].file,hak.getHeader().totalLength());
      }
    }
  }
 else {
    overwriteHook.setOverwritten(false,-1,-1);
    if (offset < 0) {
      return this;
    }
    if (keyParts.length == 0) {
      newPrefix=keyComp > 0 ? key : hak.getKey();
    }
 else {
      newPrefix=commonPrefix(prefix,key);
    }
    newKeyParts=new byte[keyParts.length + 1][];
    newLeafNodes=new LeafNode[leafNodes.length + 1];
    copyKeyParts(keyParts,0,newKeyParts,0,insertPart,prefix,newPrefix);
    copyKeyParts(keyParts,insertPart,newKeyParts,insertPart + 1,keyParts.length - insertPart,prefix,newPrefix);
    if (keyComp > 0) {
      newKeyParts[insertPart]=substring(key,newPrefix.length,keyComp);
      System.arraycopy(leafNodes,0,newLeafNodes,0,insertPart + 1);
      System.arraycopy(leafNodes,insertPart + 1,newLeafNodes,insertPart + 2,leafNodes.length - insertPart - 1);
      newLeafNodes[insertPart + 1]=new LeafNode(file,offset);
    }
 else {
      newKeyParts[insertPart]=substring(hak.getKey(),newPrefix.length,-keyComp);
      System.arraycopy(leafNodes,0,newLeafNodes,0,insertPart);
      System.arraycopy(leafNodes,insertPart,newLeafNodes,insertPart + 1,leafNodes.length - insertPart);
      newLeafNodes[insertPart]=new LeafNode(file,offset);
    }
  }
  return new IndexNode(segment,newPrefix,newKeyParts,newLeafNodes);
}
