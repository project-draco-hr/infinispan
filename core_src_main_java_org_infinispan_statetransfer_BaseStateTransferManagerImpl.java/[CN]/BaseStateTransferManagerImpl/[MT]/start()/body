{
  if (configuration.transaction().transactionMode().isTransactional() && configuration.versioning().enabled() && configuration.locking().writeSkewCheck()&& configuration.transaction().lockingMode() == LockingMode.OPTIMISTIC && configuration.clustering().cacheMode().isClustered()) {
    commandBuilder=new CommandBuilder(){
      @Override public PutKeyValueCommand buildPut(      InvocationContext ctx,      CacheEntry e){
        return cf.buildVersionedPutKeyValueCommand(e.getKey(),e.getValue(),e.getLifespan(),e.getMaxIdle(),e.getVersion(),ctx.getFlags());
      }
    }
;
  }
 else {
    commandBuilder=new CommandBuilder(){
      @Override public PutKeyValueCommand buildPut(      InvocationContext ctx,      CacheEntry e){
        return cf.buildPutKeyValueCommand(e.getKey(),e.getValue(),e.getLifespan(),e.getMaxIdle(),ctx.getFlags());
      }
    }
;
  }
  this.withTopology=globalCfg.transport().hasTopologyInfo();
  if (trace)   log.tracef("Starting state transfer manager on " + getAddress());
  int numSegments=configuration.clustering().hash().numVirtualNodes();
  int numOwners=configuration.clustering().hash().numOwners();
  int timeout=(int)configuration.clustering().stateTransfer().timeout();
  localTopologyManager.join(cacheName,new CacheJoinInfo(DefaultConsistentHashFactory.class.getName(),MurmurHash3.class.getName(),numSegments,numOwners,timeout),this);
}
