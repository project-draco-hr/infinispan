{
  if (configuration.transaction().transactionMode().isTransactional() && configuration.versioning().enabled() && configuration.locking().writeSkewCheck()&& configuration.transaction().lockingMode() == LockingMode.OPTIMISTIC && configuration.clustering().cacheMode().isClustered()) {
    commandBuilder=new CommandBuilder(){
      @Override public PutKeyValueCommand buildPut(      InvocationContext ctx,      CacheEntry e){
        return cf.buildVersionedPutKeyValueCommand(e.getKey(),e.getValue(),e.getLifespan(),e.getMaxIdle(),e.getVersion(),ctx.getFlags());
      }
    }
;
  }
 else {
    commandBuilder=new CommandBuilder(){
      @Override public PutKeyValueCommand buildPut(      InvocationContext ctx,      CacheEntry e){
        return cf.buildPutKeyValueCommand(e.getKey(),e.getValue(),e.getLifespan(),e.getMaxIdle(),ctx.getFlags());
      }
    }
;
  }
  this.withTopology=globalCfg.transport().hasTopologyInfo();
  if (trace)   log.tracef("Starting state transfer manager on " + getAddress());
  HashConfiguration hashConfig=configuration.clustering().hash();
  Hash hashFunction=hashConfig.hash();
  int numSegments=hashConfig.numVirtualNodes();
  int numOwners=hashConfig.numOwners();
  long timeout=configuration.clustering().stateTransfer().timeout();
  localTopologyManager.join(cacheName,new CacheJoinInfo(new DefaultConsistentHashFactory(),hashFunction,numSegments,numOwners,timeout),this);
}
