{
  if (acc != null) {
    if (projectionTypes == null) {
      throw new IllegalArgumentException("Accumulators can only be used with projections");
    }
    if (sortFields != null) {
      throw new IllegalArgumentException("Accumulators cannot be used with sorting");
    }
  }
  this.namedParameters=null;
  this.paramNames=paramNames;
  this.matcher=matcher;
  this.metadataAdapter=metadataAdapter;
  this.acc=acc;
  this.query=query;
  this.queryString=queryString;
  this.projection=projection;
  this.projectionTypes=projectionTypes;
  this.sortFields=sortFields;
  if (projection != null && projection.length != 0) {
    translatedProjections=new ArrayList<>(projection.length);
    for (    String projectionPath : projection) {
      translatedProjections.add(metadataAdapter.translatePropertyPath(StringHelper.split(projectionPath)));
    }
  }
 else {
    translatedProjections=null;
  }
  if (sortFields != null) {
    LinkedHashMap<String,SortField> sortFieldMap=new LinkedHashMap<>();
    for (    SortField sf : sortFields) {
      String path=sf.getPath().asStringPath();
      if (!sortFieldMap.containsKey(path)) {
        sortFieldMap.put(path,sf);
      }
    }
    sortFields=sortFieldMap.values().toArray(new SortField[sortFieldMap.size()]);
    translatedSortFields=new ArrayList<>(sortFields.length);
    for (    SortField sortField : sortFields) {
      translatedSortFields.add(metadataAdapter.translatePropertyPath(sortField.getPath().getPath()));
    }
  }
 else {
    translatedSortFields=null;
  }
  BooleanFilterNormalizer booleanFilterNormalizer=new BooleanFilterNormalizer();
  normalizedQuery=booleanFilterNormalizer.normalize(query);
  if (paramNames.isEmpty()) {
    subscribe();
  }
}
