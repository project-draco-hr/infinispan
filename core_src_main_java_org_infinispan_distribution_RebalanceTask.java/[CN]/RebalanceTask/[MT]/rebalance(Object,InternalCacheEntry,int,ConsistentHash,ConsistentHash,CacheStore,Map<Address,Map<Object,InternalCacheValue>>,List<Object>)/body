{
  List<Address> oldOwners=chOld.locate(key,numOwners);
  List<Address> newOwners=chNew.locate(key,numOwners);
  if (oldOwners.equals(newOwners))   return;
  Address pushingOwner=null;
  if (oldOwners.size() == 1) {
    pushingOwner=oldOwners.get(0);
  }
 else {
    for (int i=oldOwners.size() - 1; i >= 0; i--) {
      Address server=oldOwners.get(i);
      if (newOwners.contains(server)) {
        pushingOwner=server;
        break;
      }
    }
  }
  if (trace)   log.tracef("Rebalancing key %s from %s to %s, pushing owner is %s",key,oldOwners,newOwners,pushingOwner);
  if (self.equals(pushingOwner)) {
    if (value == null) {
      try {
        value=cacheStore.load(key);
      }
 catch (      CacheLoaderException e) {
        log.failedLoadingValueFromCacheStore(key);
      }
    }
    for (    Address server : newOwners) {
      if (!oldOwners.contains(server)) {
        Map<Object,InternalCacheValue> map=states.get(server);
        if (map == null) {
          map=new HashMap<Object,InternalCacheValue>();
          states.put(server,map);
        }
        if (value != null)         map.put(key,value.toInternalCacheValue());
      }
    }
  }
  if (oldOwners.contains(self) && !newOwners.contains(self)) {
    keysToRemove.add(key);
  }
}
