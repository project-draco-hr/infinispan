{
  long start=System.currentTimeMillis();
  if (log.isDebugEnabled())   log.debugf("Commencing rehash on node: %s. Before start, distributionManager.joinComplete = %s",getMyAddress(),distributionManager.isJoinComplete());
  ConsistentHash chOld, chNew;
  try {
    distributionManager.getTransactionLogger().blockNewTransactions();
    chOld=distributionManager.getConsistentHash();
    List<Address> newMembers=rpcManager.getTransport().getMembers();
    chNew=createConsistentHash(configuration,newMembers);
    notifier.notifyTopologyChanged(chOld,chNew,true);
    distributionManager.setConsistentHash(chNew);
    notifier.notifyTopologyChanged(chOld,chNew,false);
    if (log.isTraceEnabled()) {
      log.tracef("Rebalancing\nchOld = %s\nchNew = %s",chOld,chNew);
    }
    if (configuration.isRehashEnabled()) {
      Collection<Address> oldCacheSet=Immutables.immutableCollectionWrap(chOld.getCaches());
      Collection<Address> newCacheSet=Immutables.immutableCollectionWrap(chNew.getCaches());
      notifier.notifyDataRehashed(oldCacheSet,newCacheSet,newViewId,true);
      List<Object> keysToRemove=new ArrayList<Object>();
      int numOwners=configuration.getNumOwners();
      final Map<Address,Map<Object,InternalCacheValue>> states=new HashMap<Address,Map<Object,InternalCacheValue>>();
      for (      InternalCacheEntry ice : dataContainer) {
        rebalance(ice.getKey(),ice,numOwners,chOld,chNew,null,states,keysToRemove);
      }
      CacheStore cacheStore=distributionManager.getCacheStoreForRehashing();
      if (cacheStore != null) {
        for (        Object key : cacheStore.loadAllKeys(new ReadOnlyDataContainerBackedKeySet(dataContainer))) {
          rebalance(key,null,numOwners,chOld,chNew,cacheStore,states,keysToRemove);
        }
      }
 else {
        if (trace)         log.trace("No cache store or cache store is shared, not rebalancing stored keys");
      }
      pushState(chOld,chNew,states);
      invalidateKeys(oldCacheSet,newCacheSet,keysToRemove);
    }
 else {
      if (trace)       log.trace("Rehash not enabled, so not pushing state");
    }
  }
  finally {
    try {
      distributionManager.notifyCoordinatorPushCompleted(newViewId);
      distributionManager.waitForRehashToComplete(newViewId);
    }
  finally {
      try {
        distributionManager.getTransactionLogger().unblockNewTransactions();
      }
 catch (      Exception e) {
        log.debug("Unblocking transactions failed",e);
      }
    }
    log.debugf("Node %s completed join rehash in %s!",self,Util.prettyPrintTime(System.currentTimeMillis() - start));
  }
}
