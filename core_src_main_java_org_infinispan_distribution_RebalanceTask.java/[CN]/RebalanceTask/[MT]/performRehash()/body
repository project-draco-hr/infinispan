{
  long start=System.currentTimeMillis();
  if (log.isDebugEnabled())   log.debugf("Commencing rehash on node: %s. Before start, data container had %d entries",getMyAddress(),dataContainer.size());
  ConsistentHash chOld, chNew;
  try {
    if (rehashInterrupted) {
      log.tracef("Rehash is still in progress, not blocking transactions as they should already be blocked");
    }
 else {
      distributionManager.getTransactionLogger().blockNewTransactions();
    }
    List<Address> newMembers=rpcManager.getTransport().getMembers();
    chNew=createConsistentHash(configuration,newMembers);
    chOld=distributionManager.setConsistentHash(chNew);
    if (trace) {
      log.tracef("Rebalancing\nchOld = %s\nchNew = %s",chOld,chNew);
    }
    if (configuration.isRehashEnabled()) {
      Collection<Address> oldCacheSet=Immutables.immutableCollectionWrap(chOld.getCaches());
      Collection<Address> newCacheSet=Immutables.immutableCollectionWrap(chNew.getCaches());
      notifier.notifyDataRehashed(oldCacheSet,newCacheSet,newViewId,true);
      List<Object> keysToRemove=new ArrayList<Object>();
      int numOwners=configuration.getNumOwners();
      final Map<Address,Map<Object,InternalCacheValue>> states=new HashMap<Address,Map<Object,InternalCacheValue>>();
      for (      InternalCacheEntry ice : dataContainer) {
        rebalance(ice.getKey(),ice,numOwners,chOld,chNew,null,states,keysToRemove);
      }
      CacheStore cacheStore=distributionManager.getCacheStoreForRehashing();
      if (cacheStore != null) {
        for (        Object key : cacheStore.loadAllKeys(new ReadOnlyDataContainerBackedKeySet(dataContainer))) {
          rebalance(key,null,numOwners,chOld,chNew,cacheStore,states,keysToRemove);
        }
      }
 else {
        if (trace)         log.trace("No cache store or cache store is shared, not rebalancing stored keys");
      }
      pushState(chOld,chNew,states);
      invalidateKeys(oldCacheSet,newCacheSet,keysToRemove);
    }
 else {
      if (trace)       log.trace("Rehash not enabled, so not pushing state");
    }
  }
  finally {
    boolean pendingRehash=false;
    try {
      distributionManager.notifyCoordinatorPushCompleted(newViewId);
      pendingRehash=!distributionManager.waitForRehashToComplete(newViewId);
    }
  finally {
      if (pendingRehash) {
        log.debugf("Another rehash is pending, keeping the transactions blocked");
      }
 else {
        try {
          distributionManager.getTransactionLogger().unblockNewTransactions();
        }
 catch (        Exception e) {
          log.debug("Unblocking transactions failed",e);
        }
      }
    }
    log.debugf("Node %s completed rehash for view %d in %s!",self,newViewId,Util.prettyPrintTime(System.currentTimeMillis() - start));
  }
}
