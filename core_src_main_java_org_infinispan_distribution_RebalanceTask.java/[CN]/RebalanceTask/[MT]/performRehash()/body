{
  long start=System.currentTimeMillis();
  if (log.isDebugEnabled())   log.debugf("Commencing rehash %d on node: %s. Before start, data container had %d entries",newViewId,getMyAddress(),dataContainer.size());
  Collection<Address> oldCacheSet=Collections.emptySet(), newCacheSet=Collections.emptySet();
  List<Object> keysToRemove=new ArrayList<Object>();
  boolean anotherRehashIsPending=false;
  try {
    if (previousRehashWasInterrupted) {
      log.tracef("Rehash is still in progress, not blocking transactions as they should already be blocked");
    }
 else {
      distributionManager.getTransactionLogger().blockNewTransactions();
    }
    List<Address> newMembers=rpcManager.getTransport().getMembers();
    ConsistentHash chNew=ConsistentHashHelper.createConsistentHash(configuration,newMembers);
    ConsistentHash chOld=distributionManager.setConsistentHash(chNew);
    if (trace) {
      log.tracef("Rebalancing: chOld = %s, chNew = %s",chOld,chNew);
    }
    if (configuration.isRehashEnabled()) {
      oldCacheSet=Immutables.immutableCollectionWrap(chOld.getCaches());
      newCacheSet=Immutables.immutableCollectionWrap(chNew.getCaches());
      notifier.notifyDataRehashed(oldCacheSet,newCacheSet,newViewId,true);
      int numOwners=configuration.getNumOwners();
      final Map<Address,Map<Object,InternalCacheValue>> states=new HashMap<Address,Map<Object,InternalCacheValue>>();
      for (      InternalCacheEntry ice : dataContainer) {
        rebalance(ice.getKey(),ice,numOwners,chOld,chNew,null,states,keysToRemove);
      }
      CacheStore cacheStore=distributionManager.getCacheStoreForRehashing();
      if (cacheStore != null) {
        for (        Object key : cacheStore.loadAllKeys(new ReadOnlyDataContainerBackedKeySet(dataContainer))) {
          rebalance(key,null,numOwners,chOld,chNew,cacheStore,states,keysToRemove);
        }
      }
 else {
        if (trace)         log.trace("No cache store or cache store is shared, not rebalancing stored keys");
      }
      pushState(chOld,chNew,states);
    }
 else {
      if (trace)       log.trace("Rehash not enabled, so not pushing state");
    }
  }
  finally {
    try {
      distributionManager.notifyCoordinatorPushCompleted(newViewId);
      anotherRehashIsPending=!distributionManager.waitForRehashToComplete(newViewId);
      if (!anotherRehashIsPending && configuration.isRehashEnabled()) {
        invalidateKeys(keysToRemove);
        notifier.notifyDataRehashed(oldCacheSet,newCacheSet,newViewId,false);
      }
    }
  finally {
      if (anotherRehashIsPending) {
        log.debugf("Another rehash is pending, keeping the transactions blocked");
      }
 else {
        try {
          distributionManager.getTransactionLogger().unblockNewTransactions();
        }
 catch (        Exception e) {
          log.debug("Unblocking transactions failed",e);
        }
        distributionManager.markRehashTaskCompleted();
      }
    }
    log.debugf("Node %s completed rehash for view %d in %s!",self,newViewId,Util.prettyPrintTime(System.currentTimeMillis() - start));
  }
}
