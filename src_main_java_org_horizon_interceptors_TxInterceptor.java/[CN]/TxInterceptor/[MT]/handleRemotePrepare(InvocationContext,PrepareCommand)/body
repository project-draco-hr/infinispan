{
  GlobalTransaction gtx=ctx.getGlobalTransaction();
  Transaction ltx=txTable.getLocalTransaction(gtx);
  Transaction currentTx=txManager.getTransaction();
  TransactionContext transactionContext;
  Object retval=null;
  boolean success=false;
  try {
    if (ltx == null) {
      if (currentTx != null)       txManager.suspend();
      ltx=createLocalTx();
      if (log.isDebugEnabled())       log.debug("creating new tx transactionContext");
      transactionContext=contextFactory.createTransactionContext(ltx);
      txTable.associateTransaction(ltx,gtx,transactionContext);
      if (trace)       log.trace("Created new tx for gtx " + gtx);
      if (log.isDebugEnabled())       log.debug("Started new local tx as result of remote prepare: local tx=" + ltx + " (status="+ ltx.getStatus()+ "), gtx="+ gtx);
    }
 else {
      if (!TransactionTable.isValid(ltx))       throw new CacheException("Transaction " + ltx + " not in correct state to be prepared");
      if (currentTx == null || !ltx.equals(currentTx)) {
        if (trace)         log.trace("Suspending current tx " + currentTx);
        txManager.suspend();
        txManager.resume(ltx);
      }
      transactionContext=txTable.getTransactionContext(gtx);
      if (transactionContext == null) {
        if (log.isDebugEnabled())         log.debug("creating new tx transactionContext");
        transactionContext=contextFactory.createTransactionContext(ltx);
        txTable.associateTransaction(ltx,gtx,transactionContext);
      }
    }
    if (trace)     log.trace("Resuming existing tx " + ltx + ", global tx="+ gtx);
    ctx.setTransactionContext(transactionContext);
    ctx.setTransaction(ltx);
    ctx.setGlobalTransaction(gtx);
    registerHandler(ltx,new RemoteSynchronizationHandler(gtx,ltx,transactionContext),ctx);
    success=false;
    replayModifications(ctx,ltx,command);
    success=true;
    if (command.isOnePhaseCommit()) {
      if (trace)       log.trace("Using one-phase prepare.  Not propagating the prepare call up the stack until called to do so by the sync handler.");
    }
 else {
      transactionLog.logPrepare(command);
      invokeNextInterceptor(ctx,command);
    }
    assertTxIsStillValid(ltx);
  }
  finally {
    if (trace)     log.trace("Are we running a 1-phase commit? " + command.isOnePhaseCommit());
    if (command.isOnePhaseCommit()) {
      try {
        if (success) {
          ltx.commit();
        }
 else {
          ltx.rollback();
        }
      }
 catch (      Throwable t) {
        log.error("Commit/rollback failed.",t);
        if (success) {
          try {
            log.info("Attempting anotehr rollback");
            ltx.rollback();
          }
 catch (          Throwable t2) {
            log.error("Unable to rollback",t2);
          }
        }
      }
 finally {
        transactions.remove(ltx);
      }
    }
    txManager.suspend();
    if (currentTx != null)     txManager.resume(currentTx);
    if (log.isDebugEnabled())     log.debug("Finished remote prepare " + gtx);
  }
  return retval;
}
