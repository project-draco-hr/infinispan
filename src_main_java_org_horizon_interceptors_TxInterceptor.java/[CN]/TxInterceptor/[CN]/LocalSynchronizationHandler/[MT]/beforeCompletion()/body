{
  super.beforeCompletion();
  ctx.setOriginLocal(!remoteLocal);
  setTransactionalContext(tx,gtx,transactionContext,ctx);
  if (!transactionContext.hasModifications()) {
    if (trace)     log.trace("No modifications in this tx.  Skipping beforeCompletion()");
    modifications=Collections.emptyList();
    return;
  }
 else {
    modifications=transactionContext.getModifications();
  }
  originalOptions=ctx.getOptions();
  transactionalOptions=transactionContext.getOptions();
  ctx.setOptions(transactionalOptions);
  try {
switch (tx.getStatus()) {
case Status.STATUS_ACTIVE:
case Status.STATUS_PREPARING:
      Object result=isOnePhaseCommit() ? null : runPreparePhase(ctx,gtx,modifications);
    if (result instanceof Throwable) {
      if (log.isDebugEnabled())       log.debug("Transaction needs to be rolled back - the cache returned an instance of Throwable for this prepare call (tx=" + tx + " and gtx="+ gtx+ ")",(Throwable)result);
      tx.setRollbackOnly();
      throw (Throwable)result;
    }
  break;
default :
throw new CacheException("transaction " + tx + " in status "+ tx.getStatus()+ " unable to start transaction");
}
}
 catch (Throwable t) {
if (log.isWarnEnabled()) log.warn("Caught exception, will now set transaction to roll back",t);
try {
tx.setRollbackOnly();
}
 catch (SystemException se) {
throw new RuntimeException("setting tx rollback failed ",se);
}
if (t instanceof RuntimeException) throw (RuntimeException)t;
 else throw new RuntimeException("",t);
}
 finally {
localRollbackOnly=false;
setTransactionalContext(null,null,null,ctx);
ctx.setOptions(originalOptions);
}
}
