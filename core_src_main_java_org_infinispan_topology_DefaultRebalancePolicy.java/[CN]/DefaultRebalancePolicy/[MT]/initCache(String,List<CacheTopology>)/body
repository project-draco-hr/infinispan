{
  log.tracef("Initializing rebalance policy for cache %s, pre-existing partitions are %s",cacheName,partitionTopologies);
  CacheStatus cacheStatus=cacheStatusMap.get(cacheName);
  if (partitionTopologies.isEmpty())   return;
  int unionTopologyId=0;
  ConsistentHash currentCHUnion=null;
  ConsistentHash pendingCHUnion=null;
  ConsistentHashFactory chFactory=cacheStatus.getJoinInfo().getConsistentHashFactory();
  for (  CacheTopology topology : partitionTopologies) {
    if (topology.getTopologyId() > unionTopologyId) {
      unionTopologyId=topology.getTopologyId();
    }
    if (currentCHUnion == null) {
      currentCHUnion=topology.getCurrentCH();
    }
 else {
      currentCHUnion=chFactory.union(currentCHUnion,topology.getCurrentCH());
    }
    if (pendingCHUnion == null) {
      pendingCHUnion=topology.getPendingCH();
    }
 else {
      if (topology.getPendingCH() != null)       pendingCHUnion=chFactory.union(pendingCHUnion,topology.getPendingCH());
    }
  }
synchronized (cacheStatus) {
    CacheTopology cacheTopology=new CacheTopology(unionTopologyId,currentCHUnion,pendingCHUnion);
    updateConsistentHash(cacheName,cacheStatus,cacheTopology);
  }
}
