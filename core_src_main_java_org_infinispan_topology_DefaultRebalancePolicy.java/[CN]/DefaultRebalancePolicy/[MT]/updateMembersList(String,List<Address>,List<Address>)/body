{
  CacheStatus cacheStatus=cacheStatusMap.get(cacheName);
  if (!leavers.isEmpty()) {
synchronized (cacheStatus) {
      int topologyId=cacheStatus.cacheTopology.getTopologyId();
      ConsistentHash currentCH=cacheStatus.cacheTopology.getCurrentCH();
      ConsistentHash pendingCH=cacheStatus.cacheTopology.getPendingCH();
      List<Address> newMembers=new ArrayList<Address>(clusterMembers);
      newMembers.retainAll(pendingCH.getMembers());
      ConsistentHash newPendingCH=cacheStatus.chFactory.updateMembers(pendingCH,newMembers);
      newMembers.retainAll(currentCH.getMembers());
      ConsistentHash newCurrentCH=cacheStatus.chFactory.updateMembers(currentCH,newMembers);
      cacheStatus.cacheTopology=new CacheTopology(topologyId,newCurrentCH,newPendingCH);
      clusterTopologyManager.updateConsistentHash(cacheName,topologyId,newCurrentCH,newPendingCH);
    }
  }
  if (!joiners.isEmpty()) {
synchronized (cacheStatus) {
      cacheStatus.joiners.addAll(joiners);
      int topologyId=cacheStatus.cacheTopology.getTopologyId();
      ConsistentHash currentCH=cacheStatus.cacheTopology.getCurrentCH();
      ConsistentHash pendingCH=cacheStatus.cacheTopology.getPendingCH();
      if (pendingCH != null) {
        log.debugf("Received join request from %s, but there is already a rebalance operation " + "in progress. The node will join once the current rebalance has ended.",joiners);
        return;
      }
      int newTopologyId=topologyId + 1;
      List<Address> newMembers=cacheStatus.joiners;
      cacheStatus.joiners=new ArrayList<Address>();
      newMembers.addAll(cacheStatus.cacheTopology.getMembers());
      newMembers.retainAll(clusterMembers);
      ConsistentHash balancedCH=cacheStatus.chFactory.rebalance(pendingCH);
      cacheStatus.balancedCH=balancedCH;
      ConsistentHash newPendingCH=cacheStatus.chFactory.union(currentCH,balancedCH);
      cacheStatus.cacheTopology=new CacheTopology(newTopologyId,currentCH,newPendingCH);
      clusterTopologyManager.updateConsistentHash(cacheName,newTopologyId,currentCH,newPendingCH);
    }
  }
}
