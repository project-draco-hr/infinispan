{
  cchf.setOwnerIndexes(new int[]{a0,a1},new int[]{a1,c0},new int[]{c0,c1},new int[]{c1,a0});
  configBuilder.clustering().hash().consistentHashFactory(cchf);
  createCluster(configBuilder,4);
  waitForClusterToForm();
  Object k0=new MagicKey("k1",cache(a0),cache(a1));
  Object k1=new MagicKey("k2",cache(a0),cache(a1));
  Object k2=new MagicKey("k3",cache(a1),cache(c0));
  Object k3=new MagicKey("k4",cache(a1),cache(c0));
  Object k4=new MagicKey("k5",cache(c0),cache(c1));
  Object k5=new MagicKey("k6",cache(c0),cache(c1));
  Object k6=new MagicKey("k7",cache(c1),cache(a0));
  Object k7=new MagicKey("k8",cache(c1),cache(a0));
  final Object[] allKeys=new Object[]{k0,k1,k2,k3,k4,k5,k6,k7};
  for (  Object k : allKeys)   cache(a0).put(k,k);
  StateSequencer ss=new StateSequencer();
  ss.logicalThread("main","main:st_in_progress","main:2nd_node_left","main:cluster_unavailable");
  final StateTransferManager stm0=advancedCache(a0).getComponentRegistry().getStateTransferManager();
  final int initialTopologyId=stm0.getCacheTopology().getTopologyId();
  StateSequencerUtil.advanceOnInboundRpc(ss,manager(a1),new CommandMatcher(){
    @Override public boolean accept(    ReplicableCommand command){
      if (!(command instanceof StateResponseCommand))       return false;
      StateResponseCommand responseCommand=(StateResponseCommand)command;
      return initialTopologyId < responseCommand.getCommandId();
    }
  }
).before("main:st_in_progress","main:cluster_unavailable");
  cchf.setMembersToUse(advancedCache(a0).getRpcManager().getTransport().getMembers());
  cchf.setOwnerIndexes(new int[]{a0,a1},new int[]{a1,c0},new int[]{c0,a1},new int[]{c0,a0});
  Address missing=address(c1);
  log.tracef("Before killing node %s",missing);
  TestingUtil.killCacheManagers(manager(c1));
  installNewView(advancedCache(a0).getRpcManager().getTransport().getMembers(),missing,manager(a0),manager(a1),manager(c0));
  ss.enter("main:2nd_node_left");
  missing=address(c0);
  log.tracef("Killing 2nd node %s",missing);
  TestingUtil.killCacheManagers(manager(c0));
  installNewView(advancedCache(a0).getRpcManager().getTransport().getMembers(),missing,manager(a0),manager(a1));
  eventually(new Condition(){
    @Override public boolean isSatisfied() throws Exception {
      PartitionHandlingManager phm0=TestingUtil.extractComponent(cache(a0),PartitionHandlingManager.class);
      return phm0.getAvailabilityMode() == AvailabilityMode.UNAVAILABLE;
    }
  }
);
  ss.exit("main:2nd_node_left");
  eventually(new Condition(){
    @Override public boolean isSatisfied() throws Exception {
      log.trace("Testing condition");
      for (      Object k : allKeys) {
        try {
          cache(a0).get(k);
          return false;
        }
 catch (        AvailabilityException e) {
        }
        try {
          cache(a1).put(k,k);
          return false;
        }
 catch (        AvailabilityException e) {
        }
      }
      return true;
    }
  }
);
}
