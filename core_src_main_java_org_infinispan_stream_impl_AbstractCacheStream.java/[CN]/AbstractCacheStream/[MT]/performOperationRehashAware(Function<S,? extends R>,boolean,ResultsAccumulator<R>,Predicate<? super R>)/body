{
  Set<Integer> segmentsToProcess=segmentsToFilter;
  TerminalOperation<R> op;
  do {
    remoteResults.lostSegments.clear();
    ConsistentHash ch=dm.getReadConsistentHash();
    if (retryOnRehash) {
      op=new SegmentRetryingOperation<>(intermediateOperations,supplierForSegments(ch,segmentsToProcess,null),function);
    }
 else {
      op=new SingleRunOperation<>(intermediateOperations,supplierForSegments(ch,segmentsToProcess,null),function);
    }
    UUID id=csm.remoteStreamOperationRehashAware(getParallelDistribution(),parallel,ch,segmentsToProcess,keysToFilter,Collections.emptyMap(),includeLoader,op,remoteResults,earlyTerminatePredicate);
    try {
      R localValue=op.performOperation();
      if (dm.getReadConsistentHash().equals(ch)) {
        remoteResults.onCompletion(null,ch.getPrimarySegmentsForOwner(localAddress),localValue);
      }
 else {
        if (segmentsToProcess != null) {
          Set<Integer> ourSegments=ch.getPrimarySegmentsForOwner(localAddress);
          ourSegments.retainAll(segmentsToProcess);
          remoteResults.onSegmentsLost(ourSegments);
        }
 else {
          remoteResults.onSegmentsLost(ch.getPrimarySegmentsForOwner(localAddress));
        }
      }
      try {
        if ((earlyTerminatePredicate == null || !earlyTerminatePredicate.test(localValue)) && !csm.awaitCompletion(id,30,TimeUnit.SECONDS)) {
          throw new CacheException(new TimeoutException());
        }
      }
 catch (      InterruptedException e) {
        throw new CacheException(e);
      }
      segmentsToProcess=new HashSet<>(remoteResults.lostSegments);
      if (!segmentsToProcess.isEmpty()) {
        log.tracef("Found %s lost segments for identifier %s",segmentsToProcess,id);
      }
 else {
        log.tracef("Finished rehash aware operation for id %s",id);
      }
    }
  finally {
      csm.forgetOperation(id);
    }
  }
 while (!remoteResults.lostSegments.isEmpty());
  return remoteResults.currentValue;
}
