{
  final List<CacheEntry<String,String>> initialValues=new ArrayList<CacheEntry<String,String>>();
  for (int i=0; i < 10; i++) {
    String key="key-" + i;
    String value="value-" + i;
    initialValues.add(new ImmortalCacheEntry(key,value));
  }
  final CyclicBarrier barrier=new CyclicBarrier(2);
  when(retriever.retrieveEntries(Mockito.any(KeyValueFilter.class),Mockito.any(Converter.class),Mockito.any(EntryRetriever.SegmentListener.class))).thenAnswer(new Answer<CloseableIterator<CacheEntry<String,String>>>(){
    @Override public CloseableIterator<CacheEntry<String,String>> answer(    InvocationOnMock invocationOnMock) throws Throwable {
      barrier.await(10,TimeUnit.SECONDS);
      barrier.await(10,TimeUnit.SECONDS);
      return new IteratorAsCloseableIterator<CacheEntry<String,String>>(initialValues.iterator());
    }
  }
);
  Future<Void> future=fork(new Callable<Void>(){
    @Override public Void call() throws Exception {
      n.addListener(listener);
      return null;
    }
  }
);
  barrier.await(10,TimeUnit.SECONDS);
switch (operation) {
case REMOVE:
    String key="key-3";
  Object prevValue=initialValues.get(3).getValue();
n.notifyCacheEntryRemoved(key,prevValue,prevValue,true,ctx,null);
n.notifyCacheEntryRemoved(key,null,prevValue,false,ctx,null);
initialValues.remove(3);
break;
case CREATE:
key="new-key";
String value="new-value";
n.notifyCacheEntryCreated(key,null,true,ctx,null);
n.notifyCacheEntryCreated(key,value,false,ctx,null);
initialValues.add(new ImmortalCacheEntry(key,value));
break;
case PUT:
key="key-3";
value="value-3-changed";
n.notifyCacheEntryModified(key,initialValues.get(3).getValue(),false,true,ctx,null);
n.notifyCacheEntryModified(key,value,false,false,ctx,null);
initialValues.remove(3);
initialValues.add(3,new ImmortalCacheEntry(key,value));
break;
default :
throw new IllegalArgumentException("Unsupported Operation provided " + operation);
}
barrier.await(10,TimeUnit.SECONDS);
future.get(10,TimeUnit.MINUTES);
verifyEvents(isClustered(listener),listener,initialValues);
}
