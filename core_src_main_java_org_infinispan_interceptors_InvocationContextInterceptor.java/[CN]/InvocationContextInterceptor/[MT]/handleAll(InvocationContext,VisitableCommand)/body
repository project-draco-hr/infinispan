{
  try {
    ComponentStatus status=componentRegistry.getStatus();
    if (command.ignoreCommandOnStatus(status)) {
      log.debugf("Status: %s : Ignoring %s command",status,command);
      return null;
    }
    if (status.isTerminated()) {
      throw log.cacheIsTerminated(getCacheNamePrefix());
    }
 else     if (stoppingAndNotAllowed(status,ctx)) {
      throw log.cacheIsStopping(getCacheNamePrefix());
    }
    LogFactory.pushNDC(componentRegistry.getCacheName(),trace);
    invocationContextContainer.setThreadLocal(ctx);
    try {
      if (trace)       log.tracef("Invoked with command %s and InvocationContext [%s]",command,ctx);
      if (ctx == null)       throw new IllegalStateException("Null context not allowed!!");
      try {
        return invokeNextInterceptor(ctx,command);
      }
 catch (      InvalidCacheUsageException ex) {
        throw ex;
      }
catch (      Throwable th) {
        boolean suppressExceptions=(command instanceof FlagAffectedCommand) && ((FlagAffectedCommand)command).hasFlag(Flag.FAIL_SILENTLY);
        suppressExceptions=suppressExceptions || shuttingDown;
        if (suppressExceptions) {
          if (shuttingDown)           log.trace("Exception while executing code, but we're shutting down so failing silently.",th);
 else           log.trace("Exception while executing code, failing silently...",th);
          return null;
        }
 else {
          if (th instanceof WriteSkewException) {
            log.debug("Exception executing call",th);
          }
 else           if (th instanceof OutdatedTopologyException) {
            log.outdatedTopology(th);
          }
 else {
            Collection<Object> affectedKeys=extractWrittenKeys(ctx,command);
            log.executionError(command.getClass().getSimpleName(),affectedKeys,th);
          }
          if (ctx.isInTxScope() && ctx.isOriginLocal()) {
            if (trace)             log.trace("Transaction marked for rollback as exception was received.");
            markTxForRollbackAndRethrow(ctx,th);
            throw new IllegalStateException("This should not be reached");
          }
          throw th;
        }
      }
    }
  finally {
      LogFactory.popNDC(trace);
    }
  }
  finally {
    invocationContextContainer.clearThreadLocal();
  }
}
