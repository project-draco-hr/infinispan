{
  if (trace)   log.trace("Checking for modifications");
  boolean unlock=false;
  try {
    acquireLock(write);
    unlock=true;
    swap=state;
    state=newStateMap();
    for (    Object key : swap.keySet()) {
      boolean acquired=lockContainer.acquireLock(key,0,TimeUnit.NANOSECONDS) != null;
      if (trace)       log.trace("Lock for key {0} was acquired={1}",key,acquired);
      if (!acquired) {
        Modification prev=swap.remove(key);
        state.put(key,prev);
      }
 else {
        lockedKeys.add(key);
      }
    }
  }
  finally {
    if (unlock)     write.unlock();
  }
  try {
    int size=swap.size();
    if (swap.isEmpty()) {
      awaitNotEmptyOrStopped();
    }
 else {
      decrementAndGet(size);
      if (trace)       log.trace("Apply {0} modifications",size);
      int maxRetries=3;
      int attemptNumber=0;
      boolean successful;
      do {
        if (attemptNumber > 0 && log.isDebugEnabled())         log.debug("Retrying due to previous failure. {0} attempts left.",maxRetries - attemptNumber);
        successful=put(swap);
        attemptNumber++;
      }
 while (!successful && attemptNumber <= maxRetries);
      if (!successful)       log.warn("Unable to process some async modifications after " + maxRetries + " retries!");
    }
  }
  finally {
    lockContainer.releaseLocks(lockedKeys);
    lockedKeys.clear();
  }
}
