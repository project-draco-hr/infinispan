{
  final ConcurrentMap<Object,Modification> swap;
  if (trace)   log.trace("Checking for modifications");
  try {
    acquireLock(stateMapLock);
    try {
      swap=state;
      state=newStateMap();
      for (      Object key : swap.keySet()) {
        if (trace)         log.tracef("Going to process mod key: %s",key);
        boolean acquired;
        try {
          acquired=lockContainer.acquireLock(null,key,0,TimeUnit.NANOSECONDS) != null;
        }
 catch (        InterruptedException e) {
          log.interruptedAcquiringLock(0,e);
          Thread.currentThread().interrupt();
          return;
        }
        if (trace)         log.tracef("Lock for key %s was acquired=%s",key,acquired);
        if (!acquired) {
          Modification prev=swap.remove(key);
          Modification didPut=state.putIfAbsent(key,prev);
          if (didPut == null) {
            runAgainAfterWaiting=true;
          }
        }
 else {
          lockedKeys.add(key);
        }
      }
    }
  finally {
      stateMapLock.unlock();
    }
    if (swap.isEmpty()) {
      if (lastAsyncProcessorShutsDownExecutor && !runAgainAfterWaiting) {
        executor.shutdown();
      }
    }
 else {
      if (trace)       log.tracef("Apply %s modifications",swap.size());
      int maxRetries=3;
      int attemptNumber=0;
      boolean successful;
      do {
        if (attemptNumber > 0 && log.isDebugEnabled())         log.debugf("Retrying due to previous failure. %s attempts left.",maxRetries - attemptNumber);
        successful=put(swap);
        attemptNumber++;
      }
 while (!successful && attemptNumber <= maxRetries);
      if (!successful)       log.unableToProcessAsyncModifications(maxRetries);
    }
  }
  finally {
    lockContainer.releaseLocks(lockedKeys);
    lockedKeys.clear();
  }
}
