{
  final ConcurrentMap<Object,Modification> swap;
  if (trace)   log.trace("Checking for modifications");
  try {
    acquireLock(stateMapLock);
    try {
      swap=state;
      state=newStateMap();
      for (      Object key : swap.keySet()) {
        if (trace)         log.trace("Going to process mod key: %s",key);
        boolean acquired=false;
        try {
          acquired=lockContainer.acquireLock(key,0,TimeUnit.NANOSECONDS) != null;
        }
 catch (        InterruptedException e) {
          log.error("interrupted on acquireLock %s, 0 nanoseconds!",e);
          Thread.currentThread().interrupt();
          return;
        }
        if (trace)         log.trace("Lock for key %s was acquired=%s",key,acquired);
        if (!acquired) {
          Modification prev=swap.remove(key);
          Modification didPut=state.putIfAbsent(key,prev);
          if (didPut == null) {
            runAgainAfterWaiting=true;
          }
        }
 else {
          lockedKeys.add(key);
        }
      }
    }
  finally {
      stateMapLock.unlock();
    }
    if (swap.isEmpty()) {
      if (lastAsyncProcessorShutsDownExecutor && runAgainAfterWaiting == false) {
        executor.shutdown();
      }
      return;
    }
 else {
      if (trace)       log.trace("Apply %s modifications",swap.size());
      int maxRetries=3;
      int attemptNumber=0;
      boolean successful;
      do {
        if (attemptNumber > 0 && log.isDebugEnabled())         log.debug("Retrying due to previous failure. %s attempts left.",maxRetries - attemptNumber);
        successful=put(swap);
        attemptNumber++;
      }
 while (!successful && attemptNumber <= maxRetries);
      if (!successful)       log.warn("Unable to process some async modifications after " + maxRetries + " retries!");
    }
  }
  finally {
    lockContainer.releaseLocks(lockedKeys);
    lockedKeys.clear();
  }
}
