{
  if (command.isCausedByALocalWrite(cdl.getAddress())) {
    getLog().trace("Skipping invalidation as the write operation originated here.");
    return null;
  }
  Object keys[]=command.getKeys();
  try {
    if (keys != null && keys.length >= 1) {
      ArrayList<Object> keysCopy=new ArrayList<Object>(Arrays.asList(keys));
      for (      Object key : command.getKeys()) {
        boolean skipLocking=hasSkipLocking(command);
        try {
          lockKey(ctx,key,0,skipLocking);
        }
 catch (        TimeoutException te) {
          getLog().unableToLockToInvalidate(key,cdl.getAddress());
          keysCopy.remove(key);
          if (keysCopy.isEmpty())           return null;
        }
      }
      command.setKeys(keysCopy.toArray());
    }
    return invokeNextInterceptor(ctx,command);
  }
 catch (  Throwable te) {
    throw cleanLocksAndRethrow(ctx,te);
  }
 finally {
    command.setKeys(keys);
    if (!ctx.isInTxScope())     lockManager.unlockAll(ctx);
  }
}
