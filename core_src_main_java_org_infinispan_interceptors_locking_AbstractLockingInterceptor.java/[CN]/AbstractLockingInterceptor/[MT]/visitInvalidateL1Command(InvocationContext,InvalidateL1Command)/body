{
  if (command.isCausedByALocalWrite(cdl.getAddress())) {
    if (trace)     getLog().trace("Skipping invalidation as the write operation originated here.");
    return ctx.shortCircuit(null);
  }
  if (hasSkipLocking(command)) {
    return ctx.continueInvocation();
  }
  final Object[] keys=command.getKeys();
  try {
    if (keys != null && keys.length >= 1) {
      ArrayList<Object> keysToInvalidate=new ArrayList<>(keys.length);
      for (      Object key : keys) {
        try {
          lockAndRecord(ctx,key,0);
          keysToInvalidate.add(key);
        }
 catch (        TimeoutException te) {
          getLog().unableToLockToInvalidate(key,cdl.getAddress());
        }
      }
      if (keysToInvalidate.isEmpty()) {
        return ctx.shortCircuit(null);
      }
      command.setKeys(keysToInvalidate.toArray());
    }
    return ctx.shortCircuit(ctx.forkInvocationSync(command));
  }
  finally {
    command.setKeys(keys);
    if (!ctx.isInTxScope())     lockManager.unlockAll(ctx);
  }
}
