{
  if (tce.isPre())   return;
  Address self=rpcManager.getAddress();
  ConsistentHash chOld=tce.getConsistentHashAtStart();
  ConsistentHash chNew=tce.getConsistentHashAtEnd();
  if (configuration.isEagerLockingSingleNodeInUse()) {
    log.tracef("Cleaning local transactions with stale eager single node locks");
    for (    LocalTransaction localTx : localTransactions.values()) {
      for (      Object key : localTx.getAffectedKeys()) {
        List<Address> oldPrimaryOwner=chOld.locate(key,1);
        List<Address> newPrimaryOwner=chNew.locate(key,1);
        if (!oldPrimaryOwner.get(0).equals(newPrimaryOwner.get(0))) {
          localTx.markForRollback(true);
          log.tracef("Marked local transaction %sfor rollback, as the main data " + "owner has changed from %s to %s",localTx.getGlobalTransaction(),oldPrimaryOwner,newPrimaryOwner);
          break;
        }
      }
    }
    log.tracef("Finished cleaning local transactions with stale eager single node locks");
  }
  log.tracef("Unlocking keys for which we are no longer an owner");
  int numOwners=configuration.isEagerLockingSingleNodeInUse() ? 1 : configuration.getNumOwners();
  for (  RemoteTransaction remoteTx : remoteTransactions.values()) {
    GlobalTransaction gtx=remoteTx.getGlobalTransaction();
    List<Object> keys=new ArrayList<Object>();
    boolean txHasLocalKeys=false;
    for (    Object key : remoteTx.getLockedKeys()) {
      boolean wasLocal=chOld.isKeyLocalToAddress(self,key,numOwners);
      boolean isLocal=chNew.isKeyLocalToAddress(self,key,numOwners);
      if (wasLocal && !isLocal) {
        keys.add(key);
      }
      txHasLocalKeys|=isLocal;
    }
    if (keys.size() > 0) {
      if (trace)       log.tracef("Unlocking keys %s for remote transaction %s as we are no longer an owner",keys,gtx);
      Set<Flag> flags=EnumSet.of(Flag.CACHE_MODE_LOCAL);
      String cacheName=configuration.getName();
      LockControlCommand unlockCmd=new LockControlCommand(keys,cacheName,flags,false);
      unlockCmd.init(invoker,icc,TransactionTable.this);
      unlockCmd.attachGlobalTransaction(gtx);
      unlockCmd.setUnlock(true);
      try {
        unlockCmd.perform(null);
        log.tracef("Unlocking moved keys for %s complete.",gtx);
      }
 catch (      Throwable t) {
        log.unableToUnlockRebalancedKeys(gtx,keys,self,t);
      }
      if (!txHasLocalKeys) {
        if (trace)         log.tracef("Killing remote transaction without any local keys %s",gtx);
        RollbackCommand rc=new RollbackCommand(cacheName,gtx);
        rc.init(invoker,icc,TransactionTable.this);
        try {
          rc.perform(null);
          log.tracef("Rollback of transaction %s complete.",gtx);
        }
 catch (        Throwable e) {
          log.unableToRollbackGlobalTx(gtx,e);
        }
 finally {
          removeRemoteTransaction(gtx);
        }
      }
    }
  }
  log.trace("Finished cleaning locks for keys that are no longer local");
}
