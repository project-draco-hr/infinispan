{
  Set<GlobalTransaction> toKill=new HashSet<GlobalTransaction>();
  for (  GlobalTransaction gt : remoteTransactions.keySet()) {
    if (leavers.contains(gt.getAddress()))     toKill.add(gt);
  }
  if (trace) {
    if (toKill.isEmpty())     log.tracef("No global transactions pertain to originator(s) %s who have left the cluster.",leavers);
 else     log.tracef("%s global transactions pertain to leavers list %s and need to be killed",toKill.size(),leavers);
  }
  for (  GlobalTransaction gtx : toKill) {
    if (trace)     log.tracef("Killing remote transaction originating on leaver %s",gtx);
    RollbackCommand rc=new RollbackCommand(gtx);
    rc.init(invoker,icc,TransactionTable.this);
    try {
      rc.perform(null);
      if (trace)       log.tracef("Rollback of transaction %s complete.",gtx);
    }
 catch (    Throwable e) {
      log.unableToRollbackGlobalTx(gtx,e);
    }
 finally {
      removeRemoteTransaction(gtx);
    }
  }
  if (trace)   log.trace("Completed cleaning transactions originating on leavers");
}
