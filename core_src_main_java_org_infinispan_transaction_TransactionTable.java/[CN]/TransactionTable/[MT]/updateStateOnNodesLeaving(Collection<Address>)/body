{
  Set<GlobalTransaction> toKill=new HashSet<GlobalTransaction>();
  for (  GlobalTransaction gt : remoteTransactions.keySet()) {
    if (leavers.contains(gt.getAddress()))     toKill.add(gt);
  }
  if (toKill.isEmpty())   log.tracef("No global transactions pertain to originator(s) %s who have left the cluster.",leavers);
 else   log.tracef("%s global transactions pertain to leavers list %s and need to be killed",toKill.size(),leavers);
  for (  GlobalTransaction gtx : toKill) {
    log.tracef("Killing remote transaction originating on leaver %s",gtx);
    RollbackCommand rc=new RollbackCommand(cacheName,gtx);
    rc.init(invoker,icc,TransactionTable.this);
    try {
      rc.perform(null);
      log.tracef("Rollback of transaction %s complete.",gtx);
    }
 catch (    Throwable e) {
      log.unableToRollbackGlobalTx(gtx,e);
    }
  }
  log.trace("Completed cleaning transactions originating on leavers");
}
