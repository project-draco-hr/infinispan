{
  final int taskTimeout=REPLICATION_TIMEOUT / 4;
  final int sleepTime=REPLICATION_TIMEOUT / 2;
  final String sleepOnKey=init();
  MapReduceTask<String,String,String,Integer> task=createMapReduceTask(this.<String,String>cache(0));
  assertEquals("Wrong task timeout.",REPLICATION_TIMEOUT,task.timeout(MILLISECONDS));
  assertEquals("Wrong replication timeout.",REPLICATION_TIMEOUT,cache(0).getCacheConfiguration().clustering().sync().replTimeout());
  task.timeout(taskTimeout,MILLISECONDS);
  assertEquals("Wrong new task timeout.",taskTimeout,task.timeout(MILLISECONDS));
  task.mappedWith(new SleepMapper(sleepTime,sleepOnKey)).reducedWith(new DummyReducer());
  long start=System.nanoTime();
  if (sync) {
    try {
      task.execute();
      fail("Should have gotten an exception for task.execute() call");
    }
 catch (    CacheException expected) {
      assertTrue(hasTimeoutException(expected));
    }
  }
 else {
    try {
      Future<Map<String,Integer>> future=task.executeAsynchronously();
      future.get();
      fail("Should have gotten an exception for future.get() call");
    }
 catch (    ExecutionException e) {
      assertTrue(hasTimeoutException(e));
    }
  }
  long duration=System.nanoTime() - start;
  assertTrue(NANOSECONDS.toMillis(duration) >= taskTimeout);
}
