{
  entries=CollectionFactory.makeConcurrentParallelMap(128,concurrencyLevel);
  evictionListener=null;
  extendedMap=new ExtendedMap<K,V>(){
    @Override public void evict(    K key){
      ((EquivalentConcurrentHashMapV8<K,InternalCacheEntry<K,V>>)entries).computeIfPresent(key,new EquivalentConcurrentHashMapV8.BiFun<K,InternalCacheEntry<K,V>,InternalCacheEntry<K,V>>(){
        @Override public InternalCacheEntry<K,V> apply(        K o,        InternalCacheEntry<K,V> entry){
          passivator.passivate(entry);
          return null;
        }
      }
);
    }
    @Override public void compute(    K key,    final ComputeAction<K,V> action){
      ((EquivalentConcurrentHashMapV8<K,InternalCacheEntry<K,V>>)entries).compute(key,new EquivalentConcurrentHashMapV8.BiFun<K,InternalCacheEntry<K,V>,InternalCacheEntry<K,V>>(){
        @Override public InternalCacheEntry<K,V> apply(        K key,        InternalCacheEntry<K,V> oldEntry){
          InternalCacheEntry<K,V> newEntry=action.compute(key,oldEntry,entryFactory);
          if (newEntry == oldEntry) {
            return oldEntry;
          }
 else           if (newEntry == null) {
            return null;
          }
          if (oldEntry == null) {
            activator.activate(key);
          }
          if (trace)           log.tracef("Store %s in container",newEntry);
          return newEntry;
        }
      }
);
    }
    @Override public void putAndActivate(    final InternalCacheEntry<K,V> newEntry){
      ((EquivalentConcurrentHashMapV8<K,InternalCacheEntry<K,V>>)entries).compute(newEntry.getKey(),new EquivalentConcurrentHashMapV8.BiFun<Object,InternalCacheEntry<K,V>,InternalCacheEntry<K,V>>(){
        @Override public InternalCacheEntry apply(        Object key,        InternalCacheEntry<K,V> entry){
          if (entry == null) {
            activator.activate(key);
          }
          return newEntry;
        }
      }
);
    }
  }
;
}
