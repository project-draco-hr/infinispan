{
switch (policy) {
case PIGGYBACK:
case DEFAULT:
    evictionListener=new DefaultEvictionListener();
  break;
default :
throw new IllegalArgumentException("No such eviction thread policy " + strategy);
}
Eviction eviction;
switch (strategy) {
case FIFO:
case UNORDERED:
case LRU:
eviction=Eviction.LRU;
break;
case LIRS:
eviction=Eviction.LIRS;
break;
default :
throw new IllegalArgumentException("No such eviction strategy " + strategy);
}
final BoundedConcurrentHashMap<Object,InternalCacheEntry> boundedMap=new BoundedConcurrentHashMap<Object,InternalCacheEntry>(maxEntries,concurrencyLevel,eviction,evictionListener,keyEquivalence,valueEquivalence);
entries=boundedMap;
extendedMap=new ExtendedMap(){
@Override public void evict(Object key){
boundedMap.evict(key);
}
@Override public void compute(Object key,final ComputeAction action){
boundedMap.lock(key);
try {
InternalCacheEntry oldEntry=boundedMap.get(key);
InternalCacheEntry newEntry=action.compute(key,oldEntry,entryFactory);
if (oldEntry == newEntry) {
return;
}
 else if (newEntry == null) {
boundedMap.remove(key);
return;
}
if (trace) log.tracef("Store %s in container",newEntry);
boundedMap.put(key,newEntry);
}
  finally {
boundedMap.unlock(key);
}
}
@Override public void putAndActivate(InternalCacheEntry newEntry){
boundedMap.put(newEntry.getKey(),newEntry);
}
}
;
}
