{
  final Transaction tx=getOngoingTransaction();
  final NotifyingNotifiableFuture f=new DeferredReturnFuture();
  final EnumSet<Flag> flags=flagHolder.get() == null ? null : flagHolder.get().flags;
  boolean isSkipLoader=isSkipLoader(flags);
  if (isDistributedAndLocal(flags,key,isSkipLoader) || isSkipLoader) {
    return wrapInFuture(get(key));
  }
 else {
    Callable<V> c=new Callable<V>(){
      @Override public V call() throws Exception {
        assertKeyNotNull(key);
        InvocationContext ctx=getInvocationContext(tx);
        if (flags != null)         ctx.setFlags(flags);
        GetKeyValueCommand command=commandsFactory.buildGetKeyValueCommand(key,flags);
        Object ret=invoker.invoke(ctx,command);
        f.notifyDone();
        return (V)ret;
      }
    }
;
    f.setNetworkFuture(asyncExecutor.submit(c));
    return f;
  }
}
