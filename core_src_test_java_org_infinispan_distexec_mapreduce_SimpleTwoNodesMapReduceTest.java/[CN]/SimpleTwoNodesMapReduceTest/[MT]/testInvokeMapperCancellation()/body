{
  counter=new AtomicInteger();
  MapReduceTask<String,String,String,Integer> task=invokeMapReduce(null,new LatchMapper(),new WordCountReducer());
  final Future<Map<String,Integer>> future=task.executeAsynchronously();
  Future<Boolean> cancelled=fork(new Callable<Boolean>(){
    @Override public Boolean call() throws Exception {
      eventually(new Condition(){
        @Override public boolean isSatisfied() throws Exception {
          return counter.get() >= nodeCount();
        }
      }
);
      return future.cancel(true);
    }
  }
);
  boolean mapperCancelled=false;
  Throwable root=null;
  try {
    future.get();
  }
 catch (  Exception e) {
    root=e;
    while (root.getCause() != null) {
      root=root.getCause();
    }
    mapperCancelled=root.getClass().equals(RuntimeException.class);
  }
  assertTrue("Mapper not cancelled, root cause " + root,mapperCancelled);
  assertTrue(cancelled.get());
  assertTrue(future.isDone());
  boolean canceled=future.cancel(true);
  assertFalse(canceled);
  future.get();
}
