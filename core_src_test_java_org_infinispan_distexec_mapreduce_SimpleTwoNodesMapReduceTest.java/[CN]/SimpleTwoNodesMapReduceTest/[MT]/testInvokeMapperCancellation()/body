{
  final CyclicBarrier barrier=new CyclicBarrier(nodeCount() + 1);
  final String name=this.getClass().getSimpleName();
  barriers.put(name,barrier);
  MapReduceTask<String,String,String,Integer> task=invokeMapReduce(null,new LatchMapper(name),new WordCountReducer());
  final Future<Map<String,Integer>> future=task.executeAsynchronously();
  Future<Boolean> cancelled=fork(new Callable<Boolean>(){
    @Override public Boolean call() throws Exception {
      barrier.await(10,TimeUnit.SECONDS);
      return future.cancel(true);
    }
  }
);
  boolean mapperCancelled=false;
  Throwable root=null;
  try {
    future.get();
  }
 catch (  Exception e) {
    root=e;
    while (root.getCause() != null) {
      root=root.getCause();
    }
    mapperCancelled=root.getClass().equals(RuntimeException.class);
  }
  assertTrue("Mapper not cancelled, root cause " + root,mapperCancelled);
  assertTrue(cancelled.get());
  assertTrue(future.isDone());
  boolean canceled=future.cancel(true);
  assertFalse(canceled);
  future.get();
}
