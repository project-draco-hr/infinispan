{
  final CacheViewInfo cacheViewInfo=viewsInfo.get(cacheName);
  final CacheView committedView=cacheViewInfo.getCommittedView();
  log.tracef("%s: Preparing view %d on members %s",cacheName,pendingView.getViewId(),pendingView.getMembers());
  final CacheViewControlCommand cmd=new CacheViewControlCommand(cacheName,CacheViewControlCommand.Type.PREPARE_VIEW,self,pendingView.getViewId(),pendingView.getMembers(),committedView.getViewId(),committedView.getMembers());
  Set<Address> leavers=cacheViewInfo.getPendingChanges().getLeavers();
  if (pendingView.containsAny(leavers))   throw new IllegalStateException("Cannot prepare cache view " + pendingView + ", some nodes already left the cluster: "+ leavers);
  Future<Map<Address,Response>> remoteFuture=asyncTransportExecutor.submit(new Callable<Map<Address,Response>>(){
    @Override public Map<Address,Response> call() throws Exception {
      Map<Address,Response> rspList=transport.invokeRemotely(pendingView.getMembers(),cmd,ResponseMode.SYNCHRONOUS,timeout,false,null);
      return rspList;
    }
  }
);
  Future<Object> localFuture=asyncTransportExecutor.submit(new Callable<Object>(){
    @Override public Object call() throws Exception {
      handlePrepareView(cacheName,pendingView,committedView);
      return null;
    }
  }
);
  Map<Address,Response> rspList=remoteFuture.get(timeout,TimeUnit.MILLISECONDS);
  checkRemoteResponse(cacheName,cmd,rspList);
  localFuture.get(timeout,TimeUnit.MILLISECONDS);
  return pendingView;
}
