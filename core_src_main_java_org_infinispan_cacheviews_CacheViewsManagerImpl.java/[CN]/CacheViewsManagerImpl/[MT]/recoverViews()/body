{
  final Map<Address,Map<String,CacheView>> recoveryInfo;
  try {
    Thread.sleep(100);
    log.debugf("Node %s is the new coordinator, recovering cache views",self);
    recoveryInfo=new HashMap<Address,Map<String,CacheView>>();
    recoveryInfo.put(self,handleRecoverViews());
    final CacheViewControlCommand cmd=new CacheViewControlCommand(DUMMY_CACHE_NAME_FOR_GLOBAL_COMMANDS,CacheViewControlCommand.Type.RECOVER_VIEW,self);
    List<Address> tempMembers=members;
    List<Future<Map<Address,Response>>> futures=new ArrayList<Future<Map<Address,Response>>>(tempMembers.size());
    for (    final Address member : tempMembers) {
      Future<Map<Address,Response>> future=asyncTransportExecutor.submit(new Callable<Map<Address,Response>>(){
        @Override public Map<Address,Response> call() throws Exception {
          return transport.invokeRemotely(Collections.singleton(member),cmd,ResponseMode.SYNCHRONOUS_IGNORE_LEAVERS,timeout,true,null);
        }
      }
);
      futures.add(future);
    }
    Map<Address,Response> rspList=new HashMap<Address,Response>(tempMembers.size());
    for (    Future<Map<Address,Response>> future : futures) {
      rspList.putAll(future.get());
    }
    checkRemoteResponse(null,cmd,rspList);
    for (    Map.Entry<Address,Response> e : rspList.entrySet()) {
      SuccessfulResponse value=(SuccessfulResponse)e.getValue();
      recoveryInfo.put(e.getKey(),(Map<String,CacheView>)value.getResponseValue());
    }
    Set<String> cacheNames=new HashSet<String>();
    for (    Map<String,CacheView> m : recoveryInfo.values()) {
      cacheNames.addAll(m.keySet());
    }
    for (    final String cacheName : cacheNames) {
      CacheViewInfo cacheViewInfo=getCacheViewInfo(cacheName);
      List<Address> recoveredMembers=new ArrayList(recoveryInfo.size());
      List<Address> recoveredJoiners=new ArrayList(recoveryInfo.size());
      for (      Map.Entry<Address,Map<String,CacheView>> nodeRecoveryInfo : recoveryInfo.entrySet()) {
        Address node=nodeRecoveryInfo.getKey();
        CacheView lastCommittedView=nodeRecoveryInfo.getValue().get(cacheName);
        if (lastCommittedView != null) {
          if (lastCommittedView.contains(node)) {
            recoveredMembers.add(node);
          }
 else {
            recoveredJoiners.add(node);
          }
        }
      }
      Collections.sort(recoveredMembers,new Comparator<Address>(){
        @Override public int compare(        Address o1,        Address o2){
          return recoveryInfo.get(o2).get(cacheName).getViewId() - recoveryInfo.get(o1).get(cacheName).getViewId();
        }
      }
);
      log.tracef("%s: Recovered members (including joiners) are %s",cacheName,recoveredMembers);
      int partitionCount=0;
      List<Address> membersToProcess=new ArrayList<Address>(recoveredMembers);
      List<CacheView> partitions=new ArrayList(2);
      while (!membersToProcess.isEmpty()) {
        Address node=membersToProcess.get(0);
        CacheView committedView=recoveryInfo.get(node).get(cacheName);
        int highestViewId=committedView.getViewId();
        if (partitionCount == 0) {
          cacheViewInfo.getPendingChanges().updateLatestViewId(highestViewId + 1);
        }
        final List<Address> partitionMembers=new ArrayList<Address>(committedView.getMembers());
        partitionMembers.retainAll(membersToProcess);
        membersToProcess.removeAll(committedView.getMembers());
        if (partitionMembers.isEmpty())         continue;
        int minViewId=Integer.MAX_VALUE;
        for (        Address partitionMember : partitionMembers) {
          CacheView pmCommittedView=recoveryInfo.get(partitionMember).get(cacheName);
          int pmViewId=pmCommittedView.getViewId();
          if (pmViewId < minViewId)           minViewId=pmViewId;
        }
        if (minViewId != highestViewId) {
          log.tracef("Found partition %d (%s) that should have committed view id %d but not all of them do (min view id %d), " + "committing the view",partitionCount,partitionMembers,highestViewId,minViewId);
          clusterCommitView(cacheName,highestViewId,partitionMembers,false);
        }
 else {
          log.tracef("Found partition %d (%s) that has committed view id %d, sending a rollback command " + "to clear any pending prepare",partitionCount,partitionMembers,highestViewId);
          clusterRollbackView(cacheName,highestViewId,partitionMembers,false);
        }
        partitions.add(new CacheView(highestViewId,partitionMembers));
        partitionCount++;
      }
      log.debugf("Recovered partitions after merge for cache %s: %s",cacheName,partitions);
      cacheViewInfo.getPendingChanges().recoveredViews(recoveredMembers,recoveredJoiners);
    }
    shouldRecoverViews=false;
  }
 catch (  Exception e) {
    log.error("Error recovering views from the cluster members",e);
  }
}
