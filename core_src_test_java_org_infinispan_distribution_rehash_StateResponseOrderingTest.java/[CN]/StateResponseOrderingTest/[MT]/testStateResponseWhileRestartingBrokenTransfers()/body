{
  Address primary=address(1);
  MagicKey k1=new MagicKey("k1",cache(1));
  cache(0).put(k1,"v1");
  Address backup1=advancedCache(0).getDistributionManager().locate(k1).get(1);
  Address backup2=advancedCache(0).getDistributionManager().locate(k1).get(2);
  List<Address> nonOwners=new ArrayList<Address>(advancedCache(0).getRpcManager().getMembers());
  nonOwners.removeAll(Arrays.asList(primary,backup1,backup2));
  Address nonOwner=nonOwners.get(0);
  log.debugf("Starting test with key %s, primary owner %s, backup owners %s and %s, non-owner %s",k1,primary,backup1,backup2,nonOwner);
  AdvancedCache nonOwnerCache=manager(nonOwner).getCache().getAdvancedCache();
  final StateTransferManager stm=nonOwnerCache.getComponentRegistry().getStateTransferManager();
  final int initialTopologyId=stm.getCacheTopology().getTopologyId();
  final CheckPoint checkPoint=new CheckPoint();
  replaceInvocationHandler(checkPoint,manager(nonOwner),nonOwner);
  replaceInvocationHandler(checkPoint,manager(primary),nonOwner);
  replaceInvocationHandler(checkPoint,manager(backup1),nonOwner);
  log.debugf("Killing node %s",backup2);
  manager(backup2).getCache().stop();
  eventually(new Condition(){
    @Override public boolean isSatisfied() throws Exception {
      return stm.getCacheTopology().getTopologyId() == initialTopologyId + 2;
    }
  }
);
  checkPoint.trigger("OUT_GET_TRANSACTIONS_" + primary);
  checkPoint.trigger("OUT_GET_TRANSACTIONS_" + backup1);
  checkPoint.awaitStrict("IN_GET_TRANSACTIONS_" + primary,10,SECONDS);
  checkPoint.awaitStrict("IN_GET_TRANSACTIONS_" + backup1,10,SECONDS);
  String event=checkPoint.peek(5,TimeUnit.SECONDS,"IN_START_STATE_TRANSFER_" + primary,"IN_START_STATE_TRANSFER_" + backup1);
  Address liveNode=event.endsWith(primary.toString()) ? primary : backup1;
  Address nodeToKill=liveNode == primary ? backup1 : primary;
  List<Address> keyOwners=nonOwnerCache.getDistributionManager().locate(k1);
  log.debugf("Killing node %s. Key %s is located on %s",nodeToKill,k1,keyOwners);
  log.debugf("Data on node %s: %s",primary,manager(primary).getCache().keySet());
  log.debugf("Data on node %s: %s",backup1,manager(backup1).getCache().keySet());
  checkPoint.await("IN_START_STATE_TRANSFER_" + liveNode,1,SECONDS);
  checkPoint.trigger("OUT_START_STATE_TRANSFER_" + liveNode);
  manager(nodeToKill).getCache().stop();
  checkPoint.awaitStrict("IN_RESPONSE_" + liveNode,10,SECONDS);
  checkPoint.trigger("OUT_RESPONSE_" + liveNode);
  log.debugf("Received segments?");
  Thread.sleep(1000);
  checkPoint.awaitStrict("IN_GET_TRANSACTIONS_" + liveNode,10,SECONDS);
  checkPoint.trigger("OUT_GET_TRANSACTIONS_" + liveNode);
  checkPoint.awaitStrict("IN_START_STATE_TRANSFER_" + liveNode,10,SECONDS);
  checkPoint.trigger("OUT_START_STATE_TRANSFER_" + liveNode);
  checkPoint.awaitStrict("IN_RESPONSE_" + liveNode,10,SECONDS);
  checkPoint.trigger("OUT_RESPONSE_" + liveNode);
  TestingUtil.waitForRehashToComplete(nonOwnerCache,manager(liveNode).getCache());
  log.debugf("Final checkpoint status: %s",checkPoint);
  DataContainer dataContainer=TestingUtil.extractComponent(nonOwnerCache,DataContainer.class);
  assertTrue(dataContainer.containsKey(k1));
}
