{
  log.trace("Starting rehash on new joiner");
  boolean unlocked=false;
  try {
    dmi.joinComplete=false;
    long sleepTime=500;
    int incrementFactor=2;
    int maxSleepTime=600000;
    do {
      log.trace("Requesting old consistent hash from coordinator");
      List<Response> resp=rpcManager.invokeRemotely(coordinator(),commandsFactory.buildGetConsistentHashCommand(self),ResponseMode.SYNCHRONOUS,100000,true);
      for (      Response r : resp) {
        if (r instanceof SuccessfulResponse) {
          List<Address> list=(List<Address>)((SuccessfulResponse)r).getResponseValue();
          chOld=createConsistentHash(list);
          break;
        }
      }
      log.trace("Retrieved old consistent hash {0}",chOld);
      if (chOld == null) {
        if (sleepTime > maxSleepTime)         throw new CacheException("Unable to retrieve old consistent hash from coordinator even after several attempts at sleeping and retrying!");
        log.debug("Sleeping for {0}",Util.prettyPrintTime(sleepTime));
        Thread.sleep(sleepTime);
        sleepTime*=incrementFactor;
      }
    }
 while (chOld == null);
    chNew=createConsistentHash(chOld.getCaches(),self);
    transactionLogger.enable();
    rpcManager.broadcastRpcCommand(commandsFactory.buildInstallConsistentHashCommand(self,true),true,true);
    Address myAddress=rpcManager.getTransport().getAddress();
    PullStateCommand cmd=commandsFactory.buildPullStateCommand(myAddress,chNew);
    List<Response> resps=rpcManager.invokeRemotely(chOld.getCaches(),cmd,ResponseMode.SYNCHRONOUS,10000,true);
    for (    Response r : resps) {
      if (r instanceof SuccessfulResponse) {
        Map<Object,InternalCacheValue> state=(Map<Object,InternalCacheValue>)((SuccessfulResponse)r).getResponseValue();
        for (        Map.Entry<Object,InternalCacheValue> e : state.entrySet()) {
          if (chNew.locate(e.getKey(),configuration.getNumOwners()).contains(myAddress)) {
            InternalCacheValue v=e.getValue();
            PutKeyValueCommand put=commandsFactory.buildPutKeyValueCommand(e.getKey(),v.getValue(),v.getLifespan(),v.getMaxIdle());
            InvocationContext ctx=icc.createInvocationContext();
            ctx.setFlags(Flag.CACHE_MODE_LOCAL,Flag.SKIP_REMOTE_LOOKUP);
            interceptorChain.invoke(ctx,put);
          }
        }
      }
    }
    List<WriteCommand> c=null;
    while (transactionLogger.size() > 10) {
      c=transactionLogger.drain();
      apply(c);
    }
    c=transactionLogger.drainAndLock();
    apply(c);
    unlocked=true;
    transactionLogger.unlockAndDisable();
    rpcManager.broadcastRpcCommand(commandsFactory.buildInstallConsistentHashCommand(self,false),true,true);
    rpcManager.invokeRemotely(coordinator(),commandsFactory.buildJoinCompleteCommand(self),ResponseMode.SYNCHRONOUS,100000,true);
    Map<Address,Set<Object>> invalidations=new HashMap<Address,Set<Object>>();
    for (    Object key : dataContainer.keySet()) {
      Collection<Address> invalidHolders=getInvalidHolders(key,chOld,chNew);
      for (      Address a : invalidHolders) {
        Set<Object> s=invalidations.get(a);
        if (s == null) {
          s=new HashSet<Object>();
          invalidations.put(a,s);
        }
        s.add(key);
      }
    }
    Set<Future> futures=new HashSet<Future>();
    for (    Map.Entry<Address,Set<Object>> e : invalidations.entrySet()) {
      InvalidateCommand ic=commandsFactory.buildInvalidateFromL1Command(e.getValue().toArray());
      NotifyingNotifiableFuture f=new NotifyingFutureImpl(null);
      rpcManager.invokeRemotelyInFuture(Collections.singletonList(e.getKey()),ic,true,f);
      futures.add(f);
    }
    for (    Future f : futures)     f.get();
  }
 catch (  Exception e) {
    log.warn("Caught error performing rehash!",e);
  }
 finally {
    if (!unlocked)     transactionLogger.unlockAndDisable();
    dmi.joinComplete=true;
  }
}
