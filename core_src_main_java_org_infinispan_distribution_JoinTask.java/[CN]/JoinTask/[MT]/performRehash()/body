{
  long start=System.currentTimeMillis();
  if (log.isDebugEnabled())   log.debug("Commencing");
  boolean unlocked=false;
  try {
    dmi.joinComplete=false;
    long minSleepTime=500, maxSleepTime=2000;
    int maxWaitTime=(int)configuration.getRehashRpcTimeout() * 10;
    Random rand=new Random();
    long giveupTime=System.currentTimeMillis() + maxWaitTime;
    do {
      if (log.isTraceEnabled())       log.trace("Requesting old consistent hash from coordinator");
      List<Response> resp=rpcManager.invokeRemotely(coordinator(),cf.buildRehashControlCommand(JOIN_REQ,self),SYNCHRONOUS,configuration.getRehashRpcTimeout(),true);
      List<Address> addresses=parseResponses(resp);
      if (log.isDebugEnabled())       log.debug("Retrieved old consistent hash address list {0}",addresses);
      if (addresses == null) {
        long time=rand.nextInt((int)(maxSleepTime - minSleepTime) / 10);
        time=(time * 10) + minSleepTime;
        if (log.isTraceEnabled())         log.trace("Sleeping for {0}",Util.prettyPrintTime(time));
        Thread.sleep(time);
      }
 else {
        chOld=createConsistentHash(configuration,addresses);
      }
    }
 while (chOld == null && System.currentTimeMillis() < giveupTime);
    if (chOld == null)     throw new CacheException("Unable to retrieve old consistent hash from coordinator even after several attempts at sleeping and retrying!");
    chNew=createConsistentHash(configuration,chOld.getCaches(),self);
    dmi.setConsistentHash(chNew);
    transactionLogger.enable();
    rpcManager.broadcastRpcCommand(cf.buildRehashControlCommand(JOIN_REHASH_START,self),true,true);
    Address myAddress=rpcManager.getTransport().getAddress();
    RehashControlCommand cmd=cf.buildRehashControlCommand(PULL_STATE,myAddress,null,chNew);
    List<Address> addressesWhoMaySendStuff=getAddressesWhoMaySendStuff();
    List<Response> resps=rpcManager.invokeRemotely(addressesWhoMaySendStuff,cmd,SYNCHRONOUS,configuration.getRehashRpcTimeout(),true);
    for (    Response r : resps) {
      if (r instanceof SuccessfulResponse) {
        Map<Object,InternalCacheValue> state=getStateFromResponse((SuccessfulResponse)r);
        dmi.applyState(chNew,state);
      }
    }
    dmi.drainTransactionLog();
    unlocked=true;
    rpcManager.broadcastRpcCommand(cf.buildRehashControlCommand(JOIN_REHASH_END,self),true,true);
    rpcManager.invokeRemotely(coordinator(),cf.buildRehashControlCommand(JOIN_COMPLETE,self),SYNCHRONOUS,configuration.getRehashRpcTimeout(),true);
    invalidateInvalidHolders(chOld,chNew);
    if (log.isInfoEnabled())     log.info("Completed in {0}!",Util.prettyPrintTime(System.currentTimeMillis() - start));
  }
 catch (  Exception e) {
    log.error("Caught exception!",e);
  }
 finally {
    if (!unlocked)     transactionLogger.unlockAndDisable();
    dmi.joinComplete=true;
  }
}
