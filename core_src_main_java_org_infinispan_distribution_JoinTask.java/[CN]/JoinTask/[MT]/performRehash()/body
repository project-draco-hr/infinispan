{
  long start=System.currentTimeMillis();
  if (log.isDebugEnabled())   log.debug("Commencing rehash on node: %s. Before start, distributionManager.joinComplete = %s",getMyAddress(),distributionManager.isJoinComplete());
  boolean cleanup=false;
  boolean aborted=false;
  try {
    getPermissionToJoin();
    cleanup=true;
    distributionManager.setConsistentHash(chNew);
    if (configuration.isRehashEnabled()) {
      broadcastNewConsistentHash();
      Address myAddress=rpcManager.getTransport().getAddress();
      RehashControlCommand cmd=cf.buildRehashControlCommand(PULL_STATE_JOIN,myAddress,null,chOld,chNew,null);
      List<Address> addressesWhoMaySendStuff=getAddressesWhoMaySendStuff(chNew,configuration.getNumOwners());
      Set<Future<Void>> stateRetrievalProcesses=new HashSet<Future<Void>>(addressesWhoMaySendStuff.size());
      for (      Address stateProvider : addressesWhoMaySendStuff) {
        stateRetrievalProcesses.add(statePullExecutor.submit(new JoinStateGrabber(stateProvider,cmd,chNew)));
      }
      for (      Future<Void> f : stateRetrievalProcesses)       f.get();
    }
 else {
      broadcastNewConsistentHash();
      if (trace)       log.trace("Rehash not enabled, so not pulling state.");
    }
  }
 catch (  Exception e) {
    log.error("Caught exception!  Aborting join.",e);
    broadcastAbort(cleanup);
    aborted=true;
    throw new CacheException("Unexpected exception",e);
  }
 finally {
    distributionManager.setJoinComplete(true);
    distributionManager.setRehashInProgress(false);
    inboundInvocationHandler.blockTillNoLongerRetrying(cf.getCacheName());
    if (!aborted) {
      signalJoinRehashEnd();
      if (configuration.isRehashEnabled())       invalidateInvalidHolders(chOld,chNew);
      log.info("%s completed join rehash in %s!",self,Util.prettyPrintTime(System.currentTimeMillis() - start));
    }
 else {
      log.info("%s aborted join rehash after %s!",self,Util.prettyPrintTime(System.currentTimeMillis() - start));
    }
  }
}
