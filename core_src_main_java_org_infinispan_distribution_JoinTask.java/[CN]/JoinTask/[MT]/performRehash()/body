{
  long start=System.currentTimeMillis();
  if (log.isDebugEnabled())   log.debug("Commencing");
  boolean unlocked=false;
  try {
    dmi.joinComplete=false;
    long minSleepTime=500, maxSleepTime=2000;
    int maxWaitTime=(int)configuration.getRehashRpcTimeout() * 10;
    Random rand=new Random();
    long giveupTime=System.currentTimeMillis() + maxWaitTime;
    do {
      if (log.isTraceEnabled())       log.trace("Requesting old consistent hash from coordinator");
      List<Response> resp;
      List<Address> addresses;
      try {
        resp=rpcManager.invokeRemotely(coordinator(),cf.buildRehashControlCommand(JOIN_REQ,self),SYNCHRONOUS,configuration.getRehashRpcTimeout(),true);
        addresses=parseResponses(resp);
        if (log.isDebugEnabled())         log.debug("Retrieved old consistent hash address list {0}",addresses);
      }
 catch (      TimeoutException te) {
        resp=null;
        addresses=null;
        if (log.isDebugEnabled())         log.debug("Timed out waiting for responses.");
      }
      if (addresses == null) {
        long time=rand.nextInt((int)(maxSleepTime - minSleepTime) / 10);
        time=(time * 10) + minSleepTime;
        if (log.isTraceEnabled())         log.trace("Sleeping for {0}",Util.prettyPrintTime(time));
        Thread.sleep(time);
      }
 else {
        chOld=createConsistentHash(configuration,addresses);
      }
    }
 while (chOld == null && System.currentTimeMillis() < giveupTime);
    if (chOld == null)     throw new CacheException("Unable to retrieve old consistent hash from coordinator even after several attempts at sleeping and retrying!");
    if (chOld.getCaches().contains(self))     chNew=chOld;
 else     chNew=createConsistentHash(configuration,chOld.getCaches(),self);
    dmi.setConsistentHash(chNew);
    if (configuration.isRehashEnabled()) {
      transactionLogger.enable();
      rpcManager.broadcastRpcCommand(cf.buildRehashControlCommand(JOIN_REHASH_START,self),true,true);
      Address myAddress=rpcManager.getTransport().getAddress();
      RehashControlCommand cmd=cf.buildRehashControlCommand(PULL_STATE,myAddress,null,chNew);
      List<Address> addressesWhoMaySendStuff=getAddressesWhoMaySendStuff(configuration.getNumOwners());
      List<Response> resps=rpcManager.invokeRemotely(addressesWhoMaySendStuff,cmd,SYNCHRONOUS,configuration.getRehashRpcTimeout(),true);
      for (      Response r : resps) {
        if (r instanceof SuccessfulResponse) {
          Map<Object,InternalCacheValue> state=getStateFromResponse((SuccessfulResponse)r);
          dmi.applyState(chNew,state);
        }
      }
      dmi.drainLocalTransactionLog();
    }
    unlocked=true;
    if (!configuration.isRehashEnabled()) {
      rpcManager.broadcastRpcCommand(cf.buildRehashControlCommand(JOIN_REHASH_START,self),true,true);
    }
    rpcManager.broadcastRpcCommand(cf.buildRehashControlCommand(JOIN_REHASH_END,self),true,true);
    rpcManager.invokeRemotely(coordinator(),cf.buildRehashControlCommand(JOIN_COMPLETE,self),SYNCHRONOUS,configuration.getRehashRpcTimeout(),true);
    if (configuration.isRehashEnabled()) {
      invalidateInvalidHolders(chOld,chNew);
    }
    if (log.isInfoEnabled())     log.info("{0} completed join in {1}!",self,Util.prettyPrintTime(System.currentTimeMillis() - start));
  }
 catch (  Exception e) {
    log.error("Caught exception!",e);
    throw new CacheException("Unexpected exception",e);
  }
 finally {
    if (!unlocked)     transactionLogger.unlockAndDisable();
    dmi.joinComplete=true;
  }
}
