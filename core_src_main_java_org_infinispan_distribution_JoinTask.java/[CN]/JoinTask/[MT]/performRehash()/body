{
  log.trace("Starting rehash on new joiner");
  boolean unlocked=false;
  try {
    dmi.joinComplete=false;
    long minSleepTime=500, maxSleepTime=2000;
    int maxWaitTime=600000;
    Random rand=new Random();
    long giveupTime=System.currentTimeMillis() + maxWaitTime;
    do {
      log.trace("Requesting old consistent hash from coordinator");
      List<Response> resp=rpcManager.invokeRemotely(coordinator(),commandsFactory.buildGetConsistentHashCommand(self),ResponseMode.SYNCHRONOUS,100000,true);
      List<Address> addresses=null;
      for (      Response r : resp) {
        if (r instanceof SuccessfulResponse) {
          addresses=(List<Address>)((SuccessfulResponse)r).getResponseValue();
          break;
        }
      }
      log.trace("Retrieved old consistent hash address list {0}",addresses);
      if (addresses == null) {
        long time=rand.nextInt((int)(maxSleepTime - minSleepTime) / 10);
        time=(time * 10) + minSleepTime;
        log.debug("Sleeping for {0}",Util.prettyPrintTime(time));
        Thread.sleep(time);
      }
 else {
        chOld=createConsistentHash(addresses);
      }
    }
 while (chOld == null && System.currentTimeMillis() < giveupTime);
    if (chOld == null)     throw new CacheException("Unable to retrieve old consistent hash from coordinator even after several attempts at sleeping and retrying!");
    chNew=createConsistentHash(chOld.getCaches(),self);
    dmi.setConsistentHash(chNew);
    transactionLogger.enable();
    rpcManager.broadcastRpcCommand(commandsFactory.buildInstallConsistentHashCommand(self,true),true,true);
    Address myAddress=rpcManager.getTransport().getAddress();
    PullStateCommand cmd=commandsFactory.buildPullStateCommand(myAddress,chNew);
    List<Response> resps=rpcManager.invokeRemotely(chOld.getCaches(),cmd,ResponseMode.SYNCHRONOUS,10000,true);
    for (    Response r : resps) {
      if (r instanceof SuccessfulResponse) {
        Map<Object,InternalCacheValue> state=(Map<Object,InternalCacheValue>)((SuccessfulResponse)r).getResponseValue();
        for (        Map.Entry<Object,InternalCacheValue> e : state.entrySet()) {
          if (chNew.locate(e.getKey(),configuration.getNumOwners()).contains(myAddress)) {
            InternalCacheValue v=e.getValue();
            PutKeyValueCommand put=commandsFactory.buildPutKeyValueCommand(e.getKey(),v.getValue(),v.getLifespan(),v.getMaxIdle());
            InvocationContext ctx=icc.createInvocationContext();
            ctx.setFlags(Flag.CACHE_MODE_LOCAL,Flag.SKIP_REMOTE_LOOKUP);
            interceptorChain.invoke(ctx,put);
          }
        }
      }
    }
    List<WriteCommand> c=null;
    while (transactionLogger.size() > 10) {
      c=transactionLogger.drain();
      apply(c);
    }
    c=transactionLogger.drainAndLock();
    apply(c);
    unlocked=true;
    transactionLogger.unlockAndDisable();
    rpcManager.broadcastRpcCommand(commandsFactory.buildInstallConsistentHashCommand(self,false),true,true);
    rpcManager.invokeRemotely(coordinator(),commandsFactory.buildJoinCompleteCommand(self),ResponseMode.SYNCHRONOUS,100000,true);
    Map<Address,Set<Object>> invalidations=new HashMap<Address,Set<Object>>();
    for (    Object key : dataContainer.keySet()) {
      Collection<Address> invalidHolders=getInvalidHolders(key,chOld,chNew);
      for (      Address a : invalidHolders) {
        Set<Object> s=invalidations.get(a);
        if (s == null) {
          s=new HashSet<Object>();
          invalidations.put(a,s);
        }
        s.add(key);
      }
    }
    Set<Future> futures=new HashSet<Future>();
    for (    Map.Entry<Address,Set<Object>> e : invalidations.entrySet()) {
      InvalidateCommand ic=commandsFactory.buildInvalidateFromL1Command(e.getValue().toArray());
      NotifyingNotifiableFuture f=new NotifyingFutureImpl(null);
      rpcManager.invokeRemotelyInFuture(Collections.singletonList(e.getKey()),ic,true,f);
      futures.add(f);
    }
    for (    Future f : futures)     f.get();
  }
 catch (  Exception e) {
    log.warn("Caught error performing rehash!",e);
  }
 finally {
    if (!unlocked)     transactionLogger.unlockAndDisable();
    dmi.joinComplete=true;
  }
}
