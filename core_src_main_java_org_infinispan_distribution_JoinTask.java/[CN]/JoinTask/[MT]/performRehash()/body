{
  long start=System.currentTimeMillis();
  if (log.isDebugEnabled())   log.debug("Commencing rehash on node: %s. Before start, distributionManager.joinComplete = %s",getMyAddress(),distributionManager.isJoinComplete());
  boolean cleanup=false;
  try {
    cleanup=getPermissionToJoin();
    distributionManager.setConsistentHash(chNew);
    try {
      if (configuration.isRehashEnabled()) {
        broadcastNewConsistentHash();
        Address myAddress=rpcManager.getTransport().getAddress();
        RehashControlCommand cmd=cf.buildRehashControlCommand(PULL_STATE_JOIN,myAddress,null,chOld,chNew,null);
        List<Address> addressesWhoMaySendStuff=getAddressesWhoMaySendStuff(chNew,configuration.getNumOwners());
        Set<Future<Void>> stateRetrievalProcesses=new HashSet<Future<Void>>(addressesWhoMaySendStuff.size());
        for (        Address stateProvider : addressesWhoMaySendStuff) {
          stateRetrievalProcesses.add(statePullExecutor.submit(new JoinStateGrabber(stateProvider,cmd,chNew)));
        }
        for (        Future<Void> f : stateRetrievalProcesses)         f.get();
      }
 else {
        broadcastNewConsistentHash();
        if (trace)         log.trace("Rehash not enabled, so not pulling state.");
      }
    }
  finally {
      distributionManager.setJoinComplete(true);
      distributionManager.setRehashInProgress(false);
      inboundInvocationHandler.blockTillNoLongerRetrying(cf.getCacheName());
      signalJoinRehashEnd();
      if (configuration.isRehashEnabled())       invalidateInvalidHolders(chOld,chNew);
    }
  }
 catch (  Exception e) {
    log.error("Caught exception!  Aborting join.",e);
    broadcastAbort(cleanup);
    throw new CacheException("Unexpected exception",e);
  }
 finally {
    log.info("%s completed join rehash in %s!",self,Util.prettyPrintTime(System.currentTimeMillis() - start));
  }
}
