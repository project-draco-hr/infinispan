{
  final List<K> keysToLoad=filterLoadAllKeys(keys,replaceExistingValues,true);
  if (keysToLoad.isEmpty()) {
    listener.onCompletion();
    return;
  }
  try {
    final CyclicBarrier barrier=new CyclicBarrier(keysToLoad.size(),new Runnable(){
      @Override public void run(){
        if (log.isTraceEnabled())         log.tracef("Keys %s loaded, notify listener on completion",keysToLoad);
        listener.onCompletion();
      }
    }
);
    FutureListener<V> futureListener=new FutureListener<V>(){
      @Override public void futureDone(      Future<V> future){
        try {
          if (log.isTraceEnabled())           log.tracef("Key loaded, wait for the rest of keys to load");
          barrier.await(30,TimeUnit.SECONDS);
        }
 catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
        }
catch (        BrokenBarrierException e) {
          setListenerException(listener,e);
        }
catch (        TimeoutException e) {
          setListenerException(listener,e);
        }
      }
    }
;
    AsyncCache<K,V> asyncCache=cache;
    for (    K k : keysToLoad)     asyncCache.getAsync(k).attachListener(futureListener);
  }
 catch (  Throwable t) {
    log.errorLoadingAll(keysToLoad,t);
    setListenerException(listener,t);
  }
}
