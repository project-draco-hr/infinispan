{
  checkNotClosed();
  verifyKey(key);
  verifyEntryProcessor(entryProcessor);
  if (log.isTraceEnabled())   log.tracef("Invoke entry processor %s for key=%s",entryProcessor,key);
  return new WithProcessorLock<T>().call(key,new Callable<T>(){
    @Override public T call() throws Exception {
      V oldValue=skipCacheLoadAndStatsCache.get(key);
      V safeOldValue=oldValue;
      if (configuration.isStoreByValue()) {
        safeOldValue=safeCopy(oldValue);
      }
      MutableJCacheEntry<K,V> mutable=createMutableCacheEntry(safeOldValue,key);
      T ret=processEntryProcessor(mutable,entryProcessor,arguments);
switch (mutable.getOperation()) {
case NONE:
        break;
case ACCESS:
      skipCacheLoadCache.get(key);
    updateTTLForAccessed(cache,key,oldValue);
  break;
case UPDATE:
V newValue=mutable.getNewValue();
if (oldValue != null) {
replace(cache,key,oldValue,newValue,true);
}
 else {
put(cache,skipCacheLoadCache,key,newValue,true);
}
break;
case REMOVE:
cache.remove(key);
break;
}
return ret;
}
}
);
}
