{
  InvocationContext ctx=getInvocationContext(context);
  boolean noInputKeys=keys == null || keys.isEmpty();
  if (noInputKeys) {
    KeySetCommand keySetCommand=commandsFactory.buildKeySetCommand();
    Set<Object> nodeLocalKeys=(Set<Object>)invoker.invoke(ctx,keySetCommand);
    List<Object> selectedKeys=new ArrayList<Object>();
    for (    Object key : nodeLocalKeys) {
      List<Address> locations=dm.locate(key);
      log.trace("For key %s at %s owners are %s",key,localAddress,locations);
      if (locations != null && !locations.isEmpty() && locations.get(0).equals(localAddress)) {
        selectedKeys.add(key);
      }
    }
    keys.addAll(selectedKeys);
  }
  log.trace("For %s at %s invoking mapper on keys %s",this,localAddress,keys);
  DefaultCollector<Object,Object> collector=new DefaultCollector<Object,Object>();
  for (  Object key : keys) {
    GetKeyValueCommand command=commandsFactory.buildGetKeyValueCommand(key,ctx.getFlags());
    command.setReturnCacheEntry(false);
    Object value=invoker.invoke(ctx,command);
    mapper.map(key,value,collector);
  }
  Map<Object,List<Object>> collectedValues=collector.collectedValues();
  Map<Object,Object> reducedMap=new HashMap<Object,Object>();
  for (  Entry<Object,List<Object>> e : collectedValues.entrySet()) {
    List<Object> list=e.getValue();
    if (list.size() > 1) {
      Object reduced=reducer.reduce(e.getKey(),list.iterator());
      reducedMap.put(e.getKey(),reduced);
    }
 else {
      reducedMap.put(e.getKey(),list.get(0));
    }
  }
  log.trace("%s executed at %s was reduced to %s",this,localAddress,reducedMap);
  return reducedMap;
}
