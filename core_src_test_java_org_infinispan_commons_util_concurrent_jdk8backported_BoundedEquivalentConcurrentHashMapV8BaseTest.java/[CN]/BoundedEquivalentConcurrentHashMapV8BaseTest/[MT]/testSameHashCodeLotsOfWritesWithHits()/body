{
  final int READ_THREADS=6;
  final int WRITE_THREADS=2;
  final int INSERTIONCOUNT=2048;
  final int READCOUNT=20;
  ExecutorService execService=Executors.newFixedThreadPool(READ_THREADS + WRITE_THREADS);
  ExecutorCompletionService<Void> service=new ExecutorCompletionService<Void>(execService);
  try {
    final int COUNT=INSERTIONCOUNT >> 4;
    final int hash=23;
    final Map<HashCodeControlled,HashCodeControlled> bchm=createMap(COUNT,evictionPolicy());
    for (int i=0; i < WRITE_THREADS; ++i) {
      service.submit(new Callable<Void>(){
        @Override public Void call() throws Exception {
          for (int i=0; i < INSERTIONCOUNT; ++i) {
            HashCodeControlled hcc=new HashCodeControlled(hash);
            bchm.put(hcc,hcc);
          }
          return null;
        }
      }
);
    }
    for (int i=0; i < READ_THREADS; ++i) {
      service.submit(new Callable<Void>(){
        @Override public Void call() throws Exception {
          for (int i=0; i < READCOUNT; ++i) {
            for (            Entry<HashCodeControlled,HashCodeControlled> entry : bchm.entrySet()) {
              HashCodeControlled key=entry.getKey();
              bchm.get(key);
            }
          }
          return null;
        }
      }
);
    }
    for (int i=0; i < WRITE_THREADS + READ_THREADS; ++i) {
      try {
        Future<Void> future=service.poll(1000,TimeUnit.SECONDS);
        if (future == null) {
          throw new TimeoutException();
        }
        future.get();
      }
 catch (      Exception e) {
        throw e;
      }
    }
    int manualCount=0;
    for (    Entry<HashCodeControlled,HashCodeControlled> entry : bchm.entrySet()) {
      assertNotNull(entry.getValue());
      assertNotSame(BoundedEquivalentConcurrentHashMapV8.NULL_VALUE,entry.getValue());
      manualCount++;
    }
    assertEquals(COUNT,manualCount);
    assertEquals(COUNT,bchm.size());
  }
  finally {
    execService.shutdown();
    execService.awaitTermination(10,TimeUnit.SECONDS);
  }
}
