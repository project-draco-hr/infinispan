{
  if (trace)   log.tracef("Invalidating L1 caches for keys %s",keys);
  NotifyingNotifiableFuture<Object> future=new AggregatingNotifyingFutureImpl(retval,2);
  Collection<Address> invalidationAddresses=buildInvalidationAddressList(keys,origin);
  int nodes=invalidationAddresses.size();
  if (nodes > 0) {
    boolean multicast=isUseMulticast(nodes);
    if (trace)     log.tracef("There are %s nodes involved in invalidation. Threshold is: %s; using multicast: %s",nodes,threshold,multicast);
    if (multicast) {
      if (trace)       log.tracef("Invalidating keys %s via multicast",keys);
      InvalidateCommand ic=commandsFactory.buildInvalidateFromL1Command(origin,false,keys);
      rpcManager.broadcastRpcCommandInFuture(ic,future);
    }
 else {
      InvalidateCommand ic=commandsFactory.buildInvalidateFromL1Command(origin,false,keys);
      if (trace)       log.tracef("Keys %s needs invalidation on %s",keys,invalidationAddresses);
      rpcManager.invokeRemotelyInFuture(invalidationAddresses,ic,true,future,rpcTimeout,true);
      return future;
    }
  }
 else   if (trace)   log.trace("No L1 caches to invalidate");
  return future;
}
