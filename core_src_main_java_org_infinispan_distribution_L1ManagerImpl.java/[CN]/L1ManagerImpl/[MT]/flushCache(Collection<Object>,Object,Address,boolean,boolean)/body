{
  if (trace)   log.tracef("Invalidating L1 caches for keys %s",keys);
  final Collection<Address> invalidationAddresses=buildInvalidationAddressList(keys,origin,assumeOriginKeptEntryInL1);
  int nodes=invalidationAddresses.size();
  if (nodes > 0) {
    boolean multicast=isUseMulticast(nodes);
    if (trace)     log.tracef("There are %s nodes involved in invalidation. Threshold is: %s; using multicast: %s",nodes,threshold,multicast);
    if (multicast) {
      if (trace)       log.tracef("Invalidating keys %s via multicast",keys);
      final InvalidateCommand ic=commandsFactory.buildInvalidateFromL1Command(origin,false,InfinispanCollections.<Flag>emptySet(),keys);
      if (useNotifyingFuture) {
        NotifyingNotifiableFuture<Object> future=new AggregatingNotifyingFutureImpl(retval,2);
        rpcManager.broadcastRpcCommandInFuture(ic,future);
        return future;
      }
 else {
        return asyncTransportExecutor.submit(new Callable<Object>(){
          @Override public Object call() throws Exception {
            rpcManager.broadcastRpcCommand(ic,true);
            return retval;
          }
        }
);
      }
    }
 else {
      final CacheRpcCommand rpc=commandsFactory.buildSingleRpcCommand(commandsFactory.buildInvalidateFromL1Command(origin,false,InfinispanCollections.<Flag>emptySet(),keys));
      if (trace)       log.tracef("Keys %s needs invalidation on %s",keys,invalidationAddresses);
      if (useNotifyingFuture) {
        NotifyingNotifiableFuture<Object> future=new AggregatingNotifyingFutureImpl(retval,2);
        rpcManager.invokeRemotelyInFuture(invalidationAddresses,rpc,true,future,rpcTimeout,true);
        return future;
      }
 else {
        return asyncTransportExecutor.submit(new Callable<Object>(){
          @Override public Object call() throws Exception {
            rpcManager.invokeRemotely(invalidationAddresses,rpc,ResponseMode.SYNCHRONOUS,rpcTimeout,true);
            return retval;
          }
        }
);
      }
    }
  }
 else {
    if (trace)     log.trace("No L1 caches to invalidate");
    return useNotifyingFuture ? new NotifyingFutureImpl(retval) : new NoOpFuture<Object>(retval);
  }
}
