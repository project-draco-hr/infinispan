{
  CheckPoint checkPoint=new CheckPoint();
  LocalTopologyManager ltm0=TestingUtil.extractGlobalComponent(manager(0),LocalTopologyManager.class);
  int preJoinTopologyId=ltm0.getCacheTopology(CACHE_NAME).getTopologyId();
  final AdvancedCache<Object,Object> cache0=advancedCache(0);
  addBlockingLocalTopologyManager(manager(0),checkPoint,preJoinTopologyId);
  final AdvancedCache<Object,Object> cache1=advancedCache(1);
  addBlockingLocalTopologyManager(manager(1),checkPoint,preJoinTopologyId);
  ConfigurationBuilder c=getConfigurationBuilder();
  c.clustering().stateTransfer().awaitInitialTransfer(false);
  addClusterEnabledCacheManager(c);
  addBlockingLocalTopologyManager(manager(2),checkPoint,preJoinTopologyId);
  log.tracef("Starting the cache on the joiner");
  final AdvancedCache<Object,Object> cache2=advancedCache(2);
  int duringJoinTopologyId=preJoinTopologyId + 1;
  checkPoint.trigger("allow_topology_" + duringJoinTopologyId + "_on_"+ address(0));
  checkPoint.trigger("allow_topology_" + duringJoinTopologyId + "_on_"+ address(1));
  checkPoint.trigger("allow_topology_" + duringJoinTopologyId + "_on_"+ address(2));
  eventually(new Condition(){
    @Override public boolean isSatisfied() throws Exception {
      return cache0.getRpcManager().getMembers().size() == 3 && cache1.getRpcManager().getMembers().size() == 3 && cache2.getRpcManager().getMembers().size() == 3;
    }
  }
);
  CyclicBarrier beforeCache0Barrier=new CyclicBarrier(2);
  BlockingInterceptor blockingInterceptor0=new BlockingInterceptor(beforeCache0Barrier,GetKeyValueCommand.class,false);
  cache0.addInterceptorBefore(blockingInterceptor0,StateTransferInterceptor.class);
  CyclicBarrier afterCache1Barrier=new CyclicBarrier(2);
  BlockingInterceptor blockingInterceptor1=new BlockingInterceptor(afterCache1Barrier,op.getCommandClass(),false);
  cache1.addInterceptorBefore(blockingInterceptor1,StateTransferInterceptor.class);
  CyclicBarrier beforeCache2Barrier=new CyclicBarrier(2);
  BlockingInterceptor blockingInterceptor2=new BlockingInterceptor(beforeCache2Barrier,op.getCommandClass(),true);
  cache2.addInterceptorBefore(blockingInterceptor2,NonTxDistributionInterceptor.class);
  final MagicKey key=getKeyForCache2();
  if (op.getPreviousValue() != null) {
    cache0.withFlags(Flag.CACHE_MODE_LOCAL).put(key,op.getPreviousValue());
    cache1.withFlags(Flag.CACHE_MODE_LOCAL).put(key,op.getPreviousValue());
  }
  Future<Object> future=fork(new Callable<Object>(){
    @Override public Object call() throws Exception {
      return op.perform(cache0,key);
    }
  }
);
  afterCache1Barrier.await(10,TimeUnit.SECONDS);
  afterCache1Barrier.await(10,TimeUnit.SECONDS);
  beforeCache2Barrier.await(10,TimeUnit.SECONDS);
  beforeCache2Barrier.await(10,TimeUnit.SECONDS);
  Object result=future.get(10,TimeUnit.SECONDS);
  assertEquals(op.getReturnValue(),result);
  log.tracef("%s operation is done",op);
  cache0.removeInterceptor(BlockingInterceptor.class);
  int postJoinTopologyId=duringJoinTopologyId + 1;
  checkPoint.trigger("allow_topology_" + postJoinTopologyId + "_on_"+ address(0));
  checkPoint.trigger("allow_topology_" + postJoinTopologyId + "_on_"+ address(1));
  checkPoint.trigger("allow_topology_" + postJoinTopologyId + "_on_"+ address(2));
  TestingUtil.waitForRehashToComplete(cache0,cache1,cache2);
  assertEquals(op.getValue(),cache0.get(key));
  assertEquals(op.getValue(),cache1.get(key));
  assertEquals(op.getValue(),cache2.get(key));
}
