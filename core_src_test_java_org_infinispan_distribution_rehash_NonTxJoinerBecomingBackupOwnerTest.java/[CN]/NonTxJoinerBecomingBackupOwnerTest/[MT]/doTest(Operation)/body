{
  final AdvancedCache<Object,Object> cache0=advancedCache(0);
  final AdvancedCache<Object,Object> cache1=advancedCache(1);
  ControlledRpcManager blockingRpcManager1=blockStateResponseCommand(cache1);
  ConfigurationBuilder c=getConfigurationBuilder();
  c.clustering().stateTransfer().awaitInitialTransfer(false);
  addClusterEnabledCacheManager(c);
  log.tracef("Starting the cache on the joiner");
  final AdvancedCache<Object,Object> cache2=advancedCache(2);
  eventually(new Condition(){
    @Override public boolean isSatisfied() throws Exception {
      return cache0.getRpcManager().getMembers().size() == 3 && cache1.getRpcManager().getMembers().size() == 3 && cache2.getRpcManager().getMembers().size() == 3;
    }
  }
);
  CyclicBarrier beforeCache0Barrier=new CyclicBarrier(2);
  BlockingInterceptor blockingInterceptor0=new BlockingInterceptor(beforeCache0Barrier,GetKeyValueCommand.class,false);
  cache0.addInterceptorBefore(blockingInterceptor0,StateTransferInterceptor.class);
  CyclicBarrier afterCache1Barrier=new CyclicBarrier(2);
  BlockingInterceptor blockingInterceptor1=new BlockingInterceptor(afterCache1Barrier,op.getCommandClass(),false);
  cache1.addInterceptorBefore(blockingInterceptor1,StateTransferInterceptor.class);
  CyclicBarrier beforeCache2Barrier=new CyclicBarrier(2);
  BlockingInterceptor blockingInterceptor2=new BlockingInterceptor(beforeCache2Barrier,op.getCommandClass(),true);
  cache2.addInterceptorBefore(blockingInterceptor2,NonTxDistributionInterceptor.class);
  blockingRpcManager1.waitForCommandToBlock();
  final MagicKey key=getKeyForCache2();
  if (op.getPreviousValue() != null) {
    cache0.withFlags(Flag.CACHE_MODE_LOCAL).put(key,op.getPreviousValue());
    cache1.withFlags(Flag.CACHE_MODE_LOCAL).put(key,op.getPreviousValue());
  }
  Future<Object> future=fork(new Callable<Object>(){
    @Override public Object call() throws Exception {
      return op.perform(cache0,key);
    }
  }
);
  afterCache1Barrier.await(10,TimeUnit.SECONDS);
  afterCache1Barrier.await(10,TimeUnit.SECONDS);
  beforeCache2Barrier.await(10,TimeUnit.SECONDS);
  beforeCache2Barrier.await(10,TimeUnit.SECONDS);
  Object result=future.get(10,TimeUnit.SECONDS);
  assertEquals(op.getReturnValue(),result);
  log.tracef("%s operation is done",op);
  cache0.removeInterceptor(BlockingInterceptor.class);
  blockingRpcManager1.stopBlocking();
  TestingUtil.waitForRehashToComplete(cache0,cache1,cache2);
  assertEquals(op.getValue(),cache0.get(key));
  assertEquals(op.getValue(),cache1.get(key));
  assertEquals(op.getValue(),cache2.get(key));
}
