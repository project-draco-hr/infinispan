{
  DistributedExecutorService executor=new DefaultExecutorService(cache);
  ArrayList<Future<Void>> futures=new ArrayList<>();
  Deque<Class<?>> toFlush=new LinkedList<>();
  boolean replicated=cache.getAdvancedCache().getCacheConfiguration().clustering().cacheMode().isReplicated();
  for (  Class<?> indexedType : searchIntegrator.getIndexedTypes()) {
    EntityIndexBinding indexBinding=searchIntegrator.getIndexBinding(indexedType);
    IndexManager[] indexManagers=indexBinding.getIndexManagers();
    for (    IndexManager indexManager : indexManagers) {
      String indexName=indexManager.getIndexName();
      IndexWorker indexWork;
      boolean shared=isShared(indexManager);
      if (shared) {
        indexUpdater.purge(indexedType);
        indexWork=new IndexWorker(indexedType,indexName,false);
        toFlush.add(indexedType);
      }
 else {
        indexWork=new IndexWorker(indexedType,indexName,true);
      }
      DistributedTaskBuilder builder=executor.createDistributedTaskBuilder(indexWork).timeout(0,TimeUnit.NANOSECONDS);
      DistributedTask task=builder.build();
      if (replicated && shared) {
        futures.add(executor.submit(task));
      }
 else {
        futures.addAll(executor.submitEverywhere(task));
      }
    }
  }
  waitForAll(futures);
  for (  Class<?> type : toFlush) {
    indexUpdater.flush(type);
  }
}
