{
  DistributedExecutorService executor=new DefaultExecutorService(cache);
  ArrayList<Future<Void>> futures=new ArrayList<>();
  Deque<Class<?>> toFlush=new LinkedList<>();
  boolean replicated=cache.getAdvancedCache().getCacheConfiguration().clustering().cacheMode().isReplicated();
  for (  Class<?> indexedType : searchIntegrator.getIndexedTypes()) {
    EntityIndexBinding indexBinding=searchIntegrator.getIndexBinding(indexedType);
    IndexManager[] indexManagers=indexBinding.getIndexManagers();
    boolean shared=isShared(indexManagers[0]);
    boolean sharded=indexManagers.length > 1;
    IndexWorker indexWork;
    if (shared && !sharded) {
      indexUpdater.purge(indexedType);
      indexWork=new IndexWorker(indexedType,false);
      toFlush.add(indexedType);
    }
 else {
      indexWork=new IndexWorker(indexedType,true);
    }
    DistributedTask task=executor.createDistributedTaskBuilder(indexWork).timeout(0,TimeUnit.NANOSECONDS).build();
    if (replicated && shared && !sharded) {
      futures.add(executor.submit(task));
    }
 else {
      futures.addAll(executor.submitEverywhere(task));
    }
  }
  waitForAll(futures);
  for (  Class<?> type : toFlush) {
    indexUpdater.flush(type);
  }
}
