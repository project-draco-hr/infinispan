{
  List<NotifyingFuture<Void>> futures=new ArrayList<>();
  Deque<Class<?>> toFlush=new LinkedList<>();
  for (  Class<?> indexedType : searchIntegrator.getIndexedTypes()) {
    EntityIndexBinding indexBinding=searchIntegrator.getIndexBinding(indexedType);
    MassIndexStrategy strategy=calculateStrategy(indexBinding,cache.getCacheConfiguration());
    boolean workerClean=true, workerFlush=true;
    if (strategy.getCleanStrategy() == CleanExecutionMode.ONCE_BEFORE) {
      indexUpdater.purge(indexedType);
      workerClean=false;
    }
    if (strategy.getFlushStrategy() == FlushExecutionMode.ONCE_AFTER) {
      toFlush.add(indexedType);
      workerFlush=false;
    }
    IndexingExecutionMode indexingStrategy=strategy.getIndexingStrategy();
    IndexWorker indexWork=new IndexWorker(indexedType,workerFlush,workerClean,indexingStrategy == IndexingExecutionMode.PRIMARY_OWNER);
    DistributedTask<Void> task=executor.createDistributedTaskBuilder(indexWork).timeout(0,TimeUnit.NANOSECONDS).build();
    futures.addAll((List)executor.submitEverywhere(task));
  }
  return new ExecutionResult<>(futures,toFlush);
}
