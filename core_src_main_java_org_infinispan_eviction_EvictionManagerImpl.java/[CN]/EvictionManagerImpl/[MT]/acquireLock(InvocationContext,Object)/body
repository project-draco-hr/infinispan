{
  boolean shouldSkipLocking=ctx.hasFlag(Flag.SKIP_LOCKING);
  if (!ctx.hasLockedKey(key) && !shouldSkipLocking) {
    if (lockManager.lockAndRecord(key,ctx)) {
      return true;
    }
 else {
      Object owner=lockManager.getOwner(key);
      if (key instanceof MarshalledValue) {
        key=((MarshalledValue)key).get();
      }
      throw new TimeoutException("Unable to acquire lock after [" + Util.prettyPrintTime(getLockAcquisitionTimeout(ctx)) + "] on key ["+ key+ "] for requestor ["+ ctx.getLockOwner()+ "]! Lock held by ["+ owner+ "]");
    }
  }
 else {
    if (trace) {
      if (shouldSkipLocking) {
        log.trace("SKIP_LOCKING flag used!");
      }
 else {
        log.trace("Already own lock for entry");
      }
    }
  }
  return false;
}
