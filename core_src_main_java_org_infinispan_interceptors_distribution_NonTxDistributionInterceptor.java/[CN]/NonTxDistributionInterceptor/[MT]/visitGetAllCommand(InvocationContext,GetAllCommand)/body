{
  Object returnValue=invokeNextInterceptor(ctx,command);
  if (command.hasFlag(Flag.CACHE_MODE_LOCAL) || command.hasFlag(Flag.SKIP_REMOTE_LOOKUP) || command.hasFlag(Flag.IGNORE_RETURN_VALUES)|| !ctx.isOriginLocal()) {
    return returnValue;
  }
  Map<Object,Object> map=returnValue == null ? command.createMap() : (Map<Object,Object>)returnValue;
  ConsistentHash ch=command.getConsistentHash();
  Set<Object> requestedKeys=new HashSet<>();
  for (  Object key : command.getKeys()) {
    if (map.get(key) == null) {
      CacheEntry entry=ctx.lookupEntry(key);
      if (entry == null || entry.isNull()) {
        if (!isValueAvailableLocally(ch,key)) {
          requestedKeys.add(key);
        }
 else {
          if (trace) {
            log.tracef("Not doing a remote get for key %s since entry is " + "mapped to current node (%s) or is in L1. Owners are %s",toStr(key),rpcManager.getAddress(),ch.locateOwners(key));
          }
          InternalCacheEntry localEntry=localGetCacheEntry(ctx,key,false,command);
          map.put(key,command.isReturnEntries() ? localEntry : localEntry != null ? localEntry.getValue() : null);
        }
      }
    }
  }
  if (!requestedKeys.isEmpty()) {
    if (trace) {
      log.tracef("Fetching entries for keys %s from remote nodes",requestedKeys);
    }
    Map<Object,InternalCacheEntry> previouslyRetrieved=command.getRemotelyFetched();
    Map<Object,InternalCacheEntry> justRetrieved=retrieveFromRemoteSources(requestedKeys,ctx,command.getFlags());
    if (previouslyRetrieved != null) {
      previouslyRetrieved.putAll(justRetrieved);
    }
 else {
      command.setRemotelyFetched(justRetrieved);
    }
    for (    Entry<Object,InternalCacheEntry> entry : justRetrieved.entrySet()) {
      InternalCacheEntry value=entry.getValue();
      map.put(entry.getKey(),command.isReturnEntries() ? value : value != null ? value.getValue() : null);
    }
  }
  return map;
}
