{
  Map<Object,Object> originalMap=command.getMap();
  ConsistentHash ch=dm.getConsistentHash();
  Address localAddress=rpcManager.getAddress();
  if (ctx.isOriginLocal()) {
    List<NotifyingFuture<Object>> futures=new ArrayList<>(rpcManager.getMembers().size() - 1);
    RpcOptions options=rpcManager.getDefaultRpcOptions(isSynchronous(command));
    for (    Address member : rpcManager.getMembers()) {
      if (member.equals(rpcManager.getAddress())) {
        continue;
      }
      Set<Integer> segments=ch.getPrimarySegmentsForOwner(member);
      if (!segments.isEmpty()) {
        Map<Object,Object> segmentEntriesMap=new ReadOnlySegmentAwareMap<>(originalMap,ch,segments);
        if (!segmentEntriesMap.isEmpty()) {
          PutMapCommand copy=new PutMapCommand(command);
          copy.setMap(segmentEntriesMap);
          NotifyingNotifiableFuture<Object> future=new NotifyingFutureImpl<>();
          rpcManager.invokeRemotelyInFuture(Collections.singletonList(member),copy,options,future);
          futures.add(future);
        }
      }
    }
    if (futures.size() > 0) {
      CompositeNotifyingFuture<Object> compFuture=new CompositeNotifyingFuture<>(futures);
      try {
        compFuture.get(options.timeout(),TimeUnit.MILLISECONDS);
      }
 catch (      ExecutionException e) {
        throw new RemoteException("Exception while processing put on primary owner",e.getCause());
      }
catch (      TimeoutException e) {
        throw new CacheException(e);
      }
    }
  }
  if (!command.isForwarded() && ch.getNumOwners() > 1) {
    Map<Address,Set<Integer>> backupOwnerSegments=new HashMap<>();
    int segmentCount=ch.getNumSegments();
    for (int i=0; i < segmentCount; ++i) {
      Iterator<Address> iter=ch.locateOwnersForSegment(i).iterator();
      if (iter.next().equals(localAddress)) {
        while (iter.hasNext()) {
          Address backupOwner=iter.next();
          Set<Integer> segments=backupOwnerSegments.get(backupOwner);
          if (segments == null) {
            backupOwnerSegments.put(backupOwner,(segments=new HashSet<>()));
          }
          segments.add(i);
        }
      }
    }
    int backupOwnerSize=backupOwnerSegments.size();
    if (backupOwnerSize > 0) {
      List<NotifyingFuture<Object>> futures=new ArrayList<>(backupOwnerSize);
      RpcOptions options=rpcManager.getDefaultRpcOptions(isSynchronous(command));
      command.setFlags(Flag.SKIP_LOCKING);
      command.setForwarded(true);
      for (      Entry<Address,Set<Integer>> entry : backupOwnerSegments.entrySet()) {
        Set<Integer> segments=entry.getValue();
        Map<Object,Object> segmentEntriesMap=new ReadOnlySegmentAwareMap<>(originalMap,ch,segments);
        if (!segmentEntriesMap.isEmpty()) {
          PutMapCommand copy=new PutMapCommand(command);
          copy.setMap(segmentEntriesMap);
          NotifyingNotifiableFuture<Object> future=new NotifyingFutureImpl<>();
          rpcManager.invokeRemotelyInFuture(Collections.singletonList(entry.getKey()),copy,options,future);
          futures.add(future);
        }
      }
      command.setForwarded(false);
      if (futures.size() > 0) {
        CompositeNotifyingFuture<Object> compFuture=new CompositeNotifyingFuture<>(futures);
        try {
          compFuture.get(options.timeout(),TimeUnit.MILLISECONDS);
        }
 catch (        ExecutionException e) {
          throw new RemoteException("Exception while processing put on backup owner",e.getCause());
        }
catch (        TimeoutException e) {
          throw new CacheException(e);
        }
      }
    }
  }
  return invokeNextInterceptor(ctx,command);
}
