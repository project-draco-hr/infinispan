{
  Map<Object,Object> originalMap=command.getMap();
  ConsistentHash ch=dm.getConsistentHash();
  Address localAddress=rpcManager.getAddress();
  if (ctx.isOriginLocal()) {
    RpcOptions options=rpcManager.getDefaultRpcOptions(isSynchronous(command));
    Map<Address,Map<Object,Object>> primaryEntries=new HashMap<>();
    for (    Entry<Object,Object> entry : originalMap.entrySet()) {
      Object key=entry.getKey();
      Address owner=ch.locatePrimaryOwner(key);
      if (localAddress.equals(owner)) {
        continue;
      }
      Map<Object,Object> currentEntries=primaryEntries.get(owner);
      if (currentEntries == null) {
        currentEntries=new HashMap<>();
        primaryEntries.put(owner,currentEntries);
      }
      currentEntries.put(key,entry.getValue());
    }
    List<CompletableFuture<Map<Address,Response>>> futures=new ArrayList<>(rpcManager.getMembers().size() - 1);
    for (    Entry<Address,Map<Object,Object>> ownerEntry : primaryEntries.entrySet()) {
      Map<Object,Object> entries=ownerEntry.getValue();
      if (!entries.isEmpty()) {
        PutMapCommand copy=new PutMapCommand(command);
        copy.setMap(entries);
        CompletableFuture<Map<Address,Response>> future=rpcManager.invokeRemotelyAsync(Collections.singletonList(ownerEntry.getKey()),copy,options);
        futures.add(future);
      }
    }
    if (futures.size() > 0) {
      CompletableFuture[] futuresArray=new CompletableFuture[futures.size()];
      CompletableFuture<Void> compFuture=CompletableFuture.allOf(futures.toArray(futuresArray));
      try {
        compFuture.get(options.timeout(),TimeUnit.MILLISECONDS);
      }
 catch (      ExecutionException e) {
        throw new RemoteException("Exception while processing put on primary owner",e.getCause());
      }
catch (      TimeoutException e) {
        throw new CacheException(e);
      }
    }
  }
  if (!command.isForwarded() && ch.getNumOwners() > 1) {
    Map<Address,Map<Object,Object>> backupOwnerEntries=new HashMap<>();
    for (    Entry<Object,Object> entry : originalMap.entrySet()) {
      Object key=entry.getKey();
      List<Address> addresses=ch.locateOwners(key);
      if (localAddress.equals(addresses.get(0))) {
        for (int i=1; i < addresses.size(); ++i) {
          Address address=addresses.get(i);
          Map<Object,Object> entries=backupOwnerEntries.get(address);
          if (entries == null) {
            entries=new HashMap<>();
            backupOwnerEntries.put(address,entries);
          }
          entries.put(key,entry.getValue());
        }
      }
    }
    int backupOwnerSize=backupOwnerEntries.size();
    if (backupOwnerSize > 0) {
      List<CompletableFuture<Map<Address,Response>>> futures=new ArrayList<>(backupOwnerSize);
      RpcOptions options=rpcManager.getDefaultRpcOptions(isSynchronous(command));
      command.addFlag(Flag.SKIP_LOCKING);
      command.setForwarded(true);
      for (      Entry<Address,Map<Object,Object>> addressEntry : backupOwnerEntries.entrySet()) {
        PutMapCommand copy=new PutMapCommand(command);
        copy.setMap(addressEntry.getValue());
        CompletableFuture<Map<Address,Response>> future=rpcManager.invokeRemotelyAsync(Collections.singletonList(addressEntry.getKey()),copy,options);
        futures.add(future);
      }
      command.setForwarded(false);
      if (futures.size() > 0) {
        CompletableFuture[] futuresArray=new CompletableFuture[futures.size()];
        CompletableFuture<Void> compFuture=CompletableFuture.allOf(futures.toArray(futuresArray));
        try {
          compFuture.get(options.timeout(),TimeUnit.MILLISECONDS);
        }
 catch (        ExecutionException e) {
          throw new RemoteException("Exception while processing put on backup owner",e.getCause());
        }
catch (        TimeoutException e) {
          throw new CacheException(e);
        }
      }
    }
  }
  return invokeNextInterceptor(ctx,command);
}
