{
  if (ctx.hasFlag(Flag.SKIP_CACHE_STORE) || ctx.hasFlag(Flag.SKIP_CACHE_LOAD)) {
    return false;
  }
  CacheEntry e=entryFactory.wrapEntryForReading(ctx,key);
  if (e == null || e.isNull()) {
    boolean keyLocked=lockManager.acquireLock(ctx,key);
    boolean unlockOnWayOut=false;
    try {
      if (dataContainer.containsKey(key)) {
        log.trace("No need to load.  Key exists in the data container.");
        unlockOnWayOut=true;
        return true;
      }
    }
  finally {
      if (keyLocked && unlockOnWayOut) {
        lockManager.unlock(key);
      }
    }
    InternalCacheEntry loaded=loader.load(key);
    if (loaded == null) {
      if (log.isTraceEnabled()) {
        log.trace("No need to load.  Key doesn't exist in the loader.");
      }
      if (keyLocked) {
        lockManager.unlock(key);
      }
      return false;
    }
    if (!keyLocked)     lockManager.lockAndRecord(key,ctx);
    MVCCEntry n=entryFactory.wrapEntryForPut(ctx,key,null,false);
    recordLoadedEntry(ctx,key,n,loaded);
    return true;
  }
 else {
    return true;
  }
}
