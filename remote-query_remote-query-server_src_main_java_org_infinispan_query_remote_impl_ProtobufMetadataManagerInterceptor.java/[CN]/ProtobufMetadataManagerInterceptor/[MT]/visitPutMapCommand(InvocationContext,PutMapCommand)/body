{
  final Map<Object,Object> map=command.getMap();
  FileDescriptorSource source=new FileDescriptorSource();
  for (  Object key : map.keySet()) {
    final Object value=map.get(key);
    if (!(key instanceof String)) {
      throw new CacheException("The key must be a string");
    }
    if (!(value instanceof String)) {
      throw new CacheException("The value must be a string");
    }
    if (shouldIntercept(key)) {
      if (!((String)key).endsWith(PROTO_KEY_SUFFIX)) {
        throw new CacheException("The key must end with \".proto\" : " + key);
      }
      source.addProtoFile((String)key,(String)value);
    }
  }
  VisitableCommand cmd=commandsFactory.buildLockControlCommand(ERRORS_KEY_SUFFIX,EnumUtil.EMPTY_BIT_SET,null);
  invoker.invoke(ctx.clone(),cmd);
  final Object result=invokeNextInterceptor(ctx,command);
  ProgressCallback progressCallback=null;
  if (ctx.isOriginLocal()) {
    progressCallback=new ProgressCallback(ctx);
    source.withProgressCallback(progressCallback);
  }
 else {
    source.withProgressCallback(EMPTY_CALLBACK);
  }
  try {
    serializationContext.registerProtoFiles(source);
  }
 catch (  IOException|DescriptorParserException e) {
    throw new CacheException(e);
  }
  if (progressCallback != null) {
    updateGlobalErrors(ctx,progressCallback.getErrorFiles());
  }
  return result;
}
