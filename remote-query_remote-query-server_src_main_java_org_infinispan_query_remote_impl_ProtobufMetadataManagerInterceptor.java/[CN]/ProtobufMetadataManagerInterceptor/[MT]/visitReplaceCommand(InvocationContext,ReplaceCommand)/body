{
  final Object key=command.getKey();
  final Object value=command.getNewValue();
  if (ctx.isOriginLocal()) {
    if (!(key instanceof String)) {
      throw new CacheException("The key must be a string");
    }
    if (!(value instanceof String)) {
      throw new CacheException("The value must be a string");
    }
    if (!shouldIntercept(key)) {
      return ctx.continueInvocation();
    }
    if (!((String)key).endsWith(PROTO_KEY_SUFFIX)) {
      throw new CacheException("The key must end with \".proto\" : " + key);
    }
    VisitableCommand cmd=commandsFactory.buildLockControlCommand(ERRORS_KEY_SUFFIX,EnumUtil.EMPTY_BIT_SET,null);
    invoker.invoke(ctx.clone(),cmd);
    final Object result=ctx.forkInvocationSync(command);
    if (command.isSuccessful()) {
      FileDescriptorSource source=new FileDescriptorSource().addProtoFile((String)key,(String)value);
      ProgressCallback progressCallback=null;
      if (ctx.isOriginLocal()) {
        progressCallback=new ProgressCallback(ctx,command.getFlagsBitSet());
        source.withProgressCallback(progressCallback);
      }
 else {
        source.withProgressCallback(EMPTY_CALLBACK);
      }
      try {
        serializationContext.registerProtoFiles(source);
      }
 catch (      IOException|DescriptorParserException e) {
        throw new CacheException("Failed to parse proto file : " + key,e);
      }
      if (progressCallback != null) {
        updateGlobalErrors(ctx,progressCallback.getErrorFiles(),command.getFlagsBitSet());
      }
    }
    return ctx.shortCircuit(result);
  }
 else {
    return ctx.continueInvocation();
  }
}
