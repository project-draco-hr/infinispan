{
  final Object key=command.getKey();
  final Object value=command.getValue();
  if (ctx.isOriginLocal()) {
    if (!(key instanceof String)) {
      throw new CacheException("The key must be a string");
    }
    if (!(value instanceof String)) {
      throw new CacheException("The value must be a string");
    }
    if (shouldIntercept(key)) {
      if (!command.hasFlag(Flag.PUT_FOR_STATE_TRANSFER) && !command.hasFlag(Flag.SKIP_LOCKING)) {
        if (!((String)key).endsWith(PROTO_KEY_SUFFIX)) {
          throw new CacheException("The key must end with \".proto\" : " + key);
        }
        VisitableCommand cmd=commandsFactory.buildLockControlCommand(ERRORS_KEY_SUFFIX,EnumUtil.EMPTY_BIT_SET,null);
        invoker.invoke(ctx.clone(),cmd);
      }
    }
 else {
      return ctx.continueInvocation();
    }
  }
  final Object result=ctx.forkInvocationSync(command);
  if (command.isSuccessful()) {
    FileDescriptorSource source=new FileDescriptorSource().addProtoFile((String)key,(String)value);
    ProgressCallback progressCallback=null;
    if (ctx.isOriginLocal() && !command.hasFlag(Flag.PUT_FOR_STATE_TRANSFER)) {
      progressCallback=new ProgressCallback(ctx,command.getFlagsBitSet());
      source.withProgressCallback(progressCallback);
    }
 else {
      source.withProgressCallback(EMPTY_CALLBACK);
    }
    try {
      serializationContext.registerProtoFiles(source);
    }
 catch (    IOException|DescriptorParserException e) {
      throw new CacheException("Failed to parse proto file : " + key,e);
    }
    if (progressCallback != null) {
      updateGlobalErrors(ctx,progressCallback.getErrorFiles(),command.getFlagsBitSet());
    }
  }
  return ctx.shortCircuit(result);
}
