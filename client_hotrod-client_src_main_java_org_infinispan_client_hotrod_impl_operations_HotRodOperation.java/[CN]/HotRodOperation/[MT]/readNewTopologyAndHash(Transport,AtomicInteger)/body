{
  int newTopologyId=transport.readVInt();
  topologyId.set(newTopologyId);
  int numKeyOwners=transport.readUnsignedShort();
  short hashFunctionVersion=transport.readByte();
  int hashSpace=transport.readVInt();
  int clusterSize=transport.readVInt();
  if (log.isTraceEnabled()) {
    log.tracef("Topology change request: newTopologyId=%d, numKeyOwners=%d, " + "hashFunctionVersion=%d, hashSpaceSize=%d, clusterSize=%d",newTopologyId,numKeyOwners,hashFunctionVersion,hashSpace,clusterSize);
  }
  LinkedHashMap<InetSocketAddress,Integer> servers2HashCode=new LinkedHashMap<InetSocketAddress,Integer>();
  for (int i=0; i < clusterSize; i++) {
    String host=transport.readString();
    int port=transport.readUnsignedShort();
    if (log.isTraceEnabled()) {
      log.tracef("Server read: %s:%d",host,port);
    }
    int hashCode=transport.read4ByteInt();
    servers2HashCode.put(new InetSocketAddress(host,port),hashCode);
    if (log.isTraceEnabled()) {
      log.tracef("Hash code is: %d",hashCode);
    }
  }
  if (log.isInfoEnabled()) {
    log.newTopology(servers2HashCode);
  }
  transport.getTransportFactory().updateServers(servers2HashCode.keySet());
  if (hashFunctionVersion == 0) {
    if (log.isTraceEnabled())     log.trace("Not using a consistent hash function (hash function version == 0).");
  }
 else {
    transport.getTransportFactory().updateHashFunction(servers2HashCode,numKeyOwners,hashFunctionVersion,hashSpace);
  }
}
