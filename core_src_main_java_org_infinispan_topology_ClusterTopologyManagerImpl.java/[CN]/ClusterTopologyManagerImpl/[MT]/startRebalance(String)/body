{
  ClusterCacheStatus cacheStatus=cacheStatusMap.get(cacheName);
synchronized (cacheStatus) {
    CacheTopology cacheTopology=cacheStatus.getCacheTopology();
    if (cacheStatus.isRebalanceInProgress()) {
      log.tracef("Ignoring request to rebalance cache %s, there's already a rebalance in progress: %s",cacheName,cacheTopology);
      return;
    }
    List<Address> newMembers=new ArrayList<Address>(cacheStatus.getMembers());
    if (newMembers.isEmpty()) {
      log.tracef("Ignoring request to rebalance cache %s, it doesn't have any member",cacheName);
      return;
    }
    log.tracef("Rebalancing consistent hash for cache %s, members are %s",cacheName,newMembers);
    int newTopologyId=cacheTopology.getTopologyId() + 1;
    ConsistentHash currentCH=cacheTopology.getCurrentCH();
    if (currentCH == null) {
      log.tracef("Ignoring request to rebalance cache %s, it doesn't have a consistent hash",cacheName);
      return;
    }
    if (!newMembers.containsAll(currentCH.getMembers())) {
      newMembers.removeAll(currentCH.getMembers());
      log.tracef("Ignoring request to rebalance cache %s, we have new leavers: %s",cacheName,newMembers);
      return;
    }
    ConsistentHashFactory chFactory=cacheStatus.getJoinInfo().getConsistentHashFactory();
    ConsistentHash updatedMembersCH=chFactory.updateMembers(currentCH,newMembers,cacheStatus.getCapacityFactors());
    ConsistentHash balancedCH=chFactory.rebalance(updatedMembersCH);
    if (balancedCH.equals(currentCH)) {
      log.tracef("The balanced CH is the same as the current CH, not rebalancing");
      return;
    }
    CacheTopology newTopology=new CacheTopology(newTopologyId,currentCH,balancedCH,cacheStatus.isMissingData());
    log.tracef("Updating cache %s topology for rebalance: %s",cacheName,newTopology);
    newTopology.logRoutingTableInformation();
    cacheStatus.startRebalance(newTopology);
  }
  rebalancePolicy.updateCacheStatus(cacheName,cacheStatus);
  broadcastRebalanceStart(cacheName,cacheStatus);
}
