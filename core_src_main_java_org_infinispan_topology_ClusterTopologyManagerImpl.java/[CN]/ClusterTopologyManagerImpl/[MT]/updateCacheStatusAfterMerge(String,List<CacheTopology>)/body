{
  log.tracef("Initializing rebalance policy for cache %s, pre-existing partitions are %s",cacheName,partitionTopologies);
  ClusterCacheStatus cacheStatus=cacheStatusMap.get(cacheName);
  if (partitionTopologies.isEmpty())   return;
  int unionTopologyId=0;
  ConsistentHash currentCHUnion=null;
  ConsistentHash pendingCHUnion=null;
  ConsistentHashFactory chFactory=cacheStatus.getJoinInfo().getConsistentHashFactory();
  for (  CacheTopology topology : partitionTopologies) {
    if (topology.getTopologyId() > unionTopologyId) {
      unionTopologyId=topology.getTopologyId();
    }
    if (currentCHUnion == null) {
      currentCHUnion=topology.getCurrentCH();
    }
 else {
      currentCHUnion=chFactory.union(currentCHUnion,topology.getCurrentCH());
    }
    if (pendingCHUnion == null) {
      pendingCHUnion=topology.getPendingCH();
    }
 else {
      if (topology.getPendingCH() != null)       pendingCHUnion=chFactory.union(pendingCHUnion,topology.getPendingCH());
    }
  }
  List<Address> members=cacheStatus.getMembers();
  if (currentCHUnion != null) {
    currentCHUnion=chFactory.updateMembers(currentCHUnion,members);
  }
  if (pendingCHUnion != null) {
    pendingCHUnion=chFactory.updateMembers(pendingCHUnion,members);
  }
  unionTopologyId+=2;
  CacheTopology cacheTopology=new CacheTopology(unionTopologyId,currentCHUnion,pendingCHUnion);
  boolean wasRebalanceInProgress=pendingCHUnion != null;
synchronized (cacheStatus) {
    cacheStatus.setMembers(cacheTopology.getMembers());
    if (wasRebalanceInProgress) {
      cacheStatus.startRebalance(cacheTopology);
    }
 else {
      cacheStatus.updateCacheTopology(cacheTopology);
    }
  }
  broadcastConsistentHashUpdate(cacheName,cacheStatus);
  if (wasRebalanceInProgress) {
    broadcastRebalanceStart(cacheName,cacheStatus);
  }
 else {
    triggerRebalance(cacheName);
  }
}
