{
  if (newViewId <= viewId) {
    log.tracef("Ignoring old cluster view notification: %s",newViewId);
    return;
  }
  log.tracef("Received new cluster view: %s",newViewId);
  boolean becameCoordinator=!isCoordinator && transport.isCoordinator();
  isCoordinator=transport.isCoordinator();
  if ((isCoordinator && mergeView) || becameCoordinator) {
    try {
      Map<String,List<CacheTopology>> clusterCacheMap=recoverClusterStatus();
      for (      Map.Entry<String,List<CacheTopology>> e : clusterCacheMap.entrySet()) {
        String cacheName=e.getKey();
        List<CacheTopology> topologyList=e.getValue();
        updateCacheStatusAfterMerge(cacheName,topologyList);
      }
    }
 catch (    InterruptedException e) {
      log.tracef("Cluster state recovery interrupted because the coordinator is shutting down");
      return;
    }
catch (    Exception e) {
      log.failedToRecoverClusterState(e);
    }
  }
 else   if (isCoordinator) {
    try {
      updateClusterMembers(newMembers);
    }
 catch (    Exception e) {
      log.errorUpdatingMembersList(e);
    }
  }
synchronized (viewUpdateLock) {
    viewId=newViewId;
    viewUpdateLock.notifyAll();
  }
}
