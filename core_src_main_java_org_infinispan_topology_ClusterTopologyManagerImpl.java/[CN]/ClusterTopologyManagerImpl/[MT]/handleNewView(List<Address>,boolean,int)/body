{
synchronized (viewHandlingLock) {
    if (newViewId <= viewId) {
      log.tracef("Ignoring old cluster view notification: %s",newViewId);
      return;
    }
    boolean becameCoordinator=!isCoordinator && transport.isCoordinator();
    isCoordinator=transport.isCoordinator();
    log.tracef("Received new cluster view: %s, isCoordinator = %s, becameCoordinator = %s",newViewId,isCoordinator,becameCoordinator);
    if ((isCoordinator && mergeView) || becameCoordinator) {
      try {
        Map<String,List<CacheTopology>> clusterCacheMap=recoverClusterStatus(newViewId);
        for (        Map.Entry<String,List<CacheTopology>> entry : clusterCacheMap.entrySet()) {
          String cacheName=entry.getKey();
          List<CacheTopology> topologyList=entry.getValue();
          try {
            updateCacheStatusAfterMerge(cacheName,transport.getMembers(),topologyList);
          }
 catch (          Exception e) {
            log.failedToRecoverCacheState(cacheName,e);
          }
        }
      }
 catch (      InterruptedException e) {
        log.tracef("Cluster state recovery interrupted because the coordinator is shutting down");
        return;
      }
catch (      Exception e) {
        log.failedToRecoverClusterState(e);
      }
    }
 else     if (isCoordinator) {
      try {
        updateClusterMembers(transport.getMembers());
      }
 catch (      Exception e) {
        log.errorUpdatingMembersList(e);
      }
    }
synchronized (viewUpdateLock) {
      viewId=newViewId;
      viewUpdateLock.notifyAll();
    }
  }
}
