{
  Future<Map<Address,Response>> remoteFuture=asyncTransportExecutor.submit(new Callable<Map<Address,Response>>(){
    @Override public Map<Address,Response> call() throws Exception {
      Map<Address,Response> rspList=transport.invokeRemotely(null,command,ResponseMode.SYNCHRONOUS_IGNORE_LEAVERS,timeout,true,null);
      return rspList;
    }
  }
);
  Future<Object> localFuture=asyncTransportExecutor.submit(new Callable<Object>(){
    @Override public Object call() throws Exception {
      gcr.wireDependencies(command);
      try {
        return command.perform(null);
      }
 catch (      Throwable t) {
        throw new Exception(t);
      }
    }
  }
);
  Map<Address,Response> responseMap=remoteFuture.get(timeout,TimeUnit.MILLISECONDS);
  Map<Address,Object> responseValues=new HashMap<Address,Object>(transport.getMembers().size());
  for (  Map.Entry<Address,Response> entry : responseMap.entrySet()) {
    Address address=entry.getKey();
    Response response=entry.getValue();
    if (!response.isSuccessful()) {
      Throwable cause=response instanceof ExceptionResponse ? ((ExceptionResponse)response).getException() : null;
      throw new CacheException("Unsuccessful response received from node " + address + ": "+ response,cause);
    }
    responseValues.put(address,((SuccessfulResponse)response).getResponseValue());
  }
  Response localResponse=(Response)localFuture.get(timeout,TimeUnit.MILLISECONDS);
  if (!localResponse.isSuccessful()) {
    throw new CacheException("Unsuccessful local response");
  }
  responseValues.put(transport.getAddress(),((SuccessfulResponse)localResponse).getResponseValue());
  return responseValues;
}
