{
synchronized (cacheStatus) {
    ConsistentHashFactory consistentHashFactory=cacheStatus.getJoinInfo().getConsistentHashFactory();
    int topologyId=cacheStatus.getCacheTopology().getTopologyId();
    ConsistentHash currentCH=cacheStatus.getCacheTopology().getCurrentCH();
    ConsistentHash pendingCH=cacheStatus.getCacheTopology().getPendingCH();
    if (!cacheStatus.needConsistentHashUpdate()) {
      log.tracef("Cache %s members list was updated, but the cache topology doesn't need to change: %s",cacheName,cacheStatus.getCacheTopology());
      return false;
    }
    List<Address> newCurrentMembers=cacheStatus.pruneInvalidMembers(currentCH.getMembers());
    if (newCurrentMembers.isEmpty()) {
      CacheTopology newTopology=new CacheTopology(topologyId + 1,null,null);
      cacheStatus.updateCacheTopology(newTopology);
      log.tracef("Initial topology installed for cache %s: %s",cacheName,newTopology);
      return false;
    }
    ConsistentHash newCurrentCH=consistentHashFactory.updateMembers(currentCH,newCurrentMembers);
    ConsistentHash newPendingCH=null;
    if (pendingCH != null) {
      List<Address> newPendingMembers=cacheStatus.pruneInvalidMembers(pendingCH.getMembers());
      newPendingCH=consistentHashFactory.updateMembers(pendingCH,newPendingMembers);
    }
    CacheTopology newTopology=new CacheTopology(topologyId + 1,newCurrentCH,newPendingCH);
    cacheStatus.updateCacheTopology(newTopology);
    log.tracef("Cache %s topology updated: %s",cacheName,newTopology);
    newTopology.logRoutingTableInformation();
    return true;
  }
}
