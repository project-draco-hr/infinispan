{
  if (trace)   log.tracef("Attempting to lock %s with acquisition timeout of %s millis",key,lockTimeout);
  if (ctx.isInTxScope()) {
    final long startNanos=System.nanoTime();
    final long timeoutNanoTime=TimeUnit.NANOSECONDS.convert(lockTimeout,MILLISECONDS) + startNanos;
    DldGlobalTransaction thisTx=(DldGlobalTransaction)ctx.getLockOwner();
    thisTx.setLockIntention(key);
    if (trace)     log.tracef("Setting lock intention to %s for %s (%s)",key,thisTx,System.identityHashCode(thisTx));
    while (System.nanoTime() < timeoutNanoTime) {
      if (lockContainer.acquireLock(ctx.getLockOwner(),key,spinDuration,MILLISECONDS) != null) {
        thisTx.setLockIntention(null);
        if (trace)         log.tracef("Successfully acquired lock on %s on behalf of %s.",key,ctx.getLockOwner());
        return true;
      }
 else {
        Object owner=getOwner(key);
        if (!(owner instanceof DldGlobalTransaction)) {
          if (trace)           log.tracef("Not running deadlock detection as lock owner (%s) is not transactional",owner);
          cannotRunDld.incrementAndGet();
          continue;
        }
        DldGlobalTransaction lockOwnerTx=(DldGlobalTransaction)owner;
        if (trace)         log.tracef("Could not acquire lock as %s is locked by %s (%s)",key,owner,System.identityHashCode(owner));
        if (isDeadlockAndIAmLoosing(lockOwnerTx,thisTx,key)) {
          updateStats(thisTx);
          String message=String.format("Deadlock found and we (%s) shall not continue. Other tx is %s",thisTx,lockOwnerTx);
          log.trace(message);
          throw new DeadlockDetectedException(message);
        }
      }
    }
  }
 else {
    return super.lockAndRecord(key,ctx,lockTimeout);
  }
  return false;
}
