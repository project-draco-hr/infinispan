{
  TxInvocationContext remoteTxContext=(TxInvocationContext)ctx;
  Address origin=remoteTxContext.getGlobalTransaction().getAddress();
  DeadlockDetectingGlobalTransaction remoteGlobalTransaction=(DeadlockDetectingGlobalTransaction)ctx.getLockOwner();
  boolean thisShouldInterrupt=remoteGlobalTransaction.thisWillInterrupt(lockOwnerTx);
  if (trace)   log.trace("Should I interrupt other transaction ? " + thisShouldInterrupt);
  boolean isDeadLock=(configuration.getCacheMode().isReplicated() || lockOwnerTx.isReplicatingTo(origin)) && !lockOwnerTx.isRemote();
  if (thisShouldInterrupt && isDeadLock) {
    lockOwnerTx.interruptProcessingThread();
    if (exposeJmxStats) {
      detectedRemoteDeadlocks.incrementAndGet();
      locallyInterruptedTransactions.incrementAndGet();
    }
    return lockForTheRemainingTime(key,lockTimeout,start,now);
  }
 else   if (!isDeadLock) {
    return lockForTheRemainingTime(key,lockTimeout,start,now);
  }
 else {
    if (trace)     log.trace("Not trying to acquire lock anymore, as we're in deadlock and this will be rollback at origin");
    if (exposeJmxStats) {
      detectedRemoteDeadlocks.incrementAndGet();
    }
    remoteGlobalTransaction.setMarkedForRollback(true);
    throw new DeadlockDetectedException("Deadlock situation detected on tx: " + remoteTxContext.getLockOwner());
  }
}
