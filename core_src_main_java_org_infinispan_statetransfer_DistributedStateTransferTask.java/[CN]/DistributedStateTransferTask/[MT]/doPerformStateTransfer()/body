{
  if (!stateTransferManager.startStateTransfer(newViewId,members,initialView))   return;
  if (log.isDebugEnabled())   log.debugf("Commencing rehash %d on node: %s. Before start, data container had %d entries",newViewId,self,dataContainer.size());
  newCacheSet=Collections.emptySet();
  oldCacheSet=Collections.emptySet();
  keysToRemove=new ArrayList<Object>();
  stateTransferLock.blockNewTransactions(newViewId);
  if (trace)   log.tracef("Rebalancing: chOld = %s, chNew = %s",chOld,chNew);
  int numOwners=configuration.clustering().hash().numOwners();
  if (configuration.clustering().stateTransfer().fetchInMemoryState() && !initialView) {
    cacheNotifier.notifyDataRehashed(oldCacheSet,newCacheSet,newViewId,true);
    final Map<Address,Collection<InternalCacheEntry>> states=new HashMap<Address,Collection<InternalCacheEntry>>();
    for (    InternalCacheEntry ice : dataContainer) {
      rebalance(ice.getKey(),ice,numOwners,chOld,chNew,null,states,keysToRemove);
    }
    checkIfCancelled();
    CacheStore cacheStore=stateTransferManager.getCacheStoreForStateTransfer();
    if (cacheStore != null) {
      for (      Object key : cacheStore.loadAllKeys(new ReadOnlyDataContainerBackedKeySet(dataContainer))) {
        rebalance(key,null,numOwners,chOld,chNew,cacheStore,states,keysToRemove);
      }
    }
 else {
      if (trace)       log.trace("No cache store or cache store is shared, not rebalancing stored keys");
    }
    checkIfCancelled();
    for (    Map.Entry<Address,Collection<InternalCacheEntry>> entry : states.entrySet()) {
      pushPartialState(Collections.singleton(entry.getKey()),entry.getValue(),null);
    }
    if (transactionTable != null) {
      log.debug("Starting lock migration");
      Map<Address,Collection<LockInfo>> locksToMigrate=new HashMap<Address,Collection<LockInfo>>();
      rebalanceLocks(numOwners,locksToMigrate,transactionTable.getRemoteTransactions());
      rebalanceLocks(numOwners,locksToMigrate,transactionTable.getLocalTransactions());
      for (      Map.Entry<Address,Collection<LockInfo>> e : locksToMigrate.entrySet()) {
        pushPartialState(Collections.singleton(e.getKey()),null,e.getValue());
      }
    }
    finishPushingState();
  }
 else   if (initialView) {
    CacheStore cacheStore=stateTransferManager.getCacheStoreForStateTransfer();
    if (cacheStore != null) {
      if (trace)       log.trace("Non-shared cache store, cleaning up persisted entries that we don't own after we joined the cache");
      for (      Object key : cacheStore.loadAllKeys(new ReadOnlyDataContainerBackedKeySet(dataContainer))) {
        if (!chNew.isKeyLocalToNode(self,key)) {
          keysToRemove.add(key);
        }
      }
    }
    checkIfCancelled();
    if (trace)     log.trace("Cleaning up preloaded entries (if preloading) that we don't own after we joined the cache");
    for (    InternalCacheEntry ice : dataContainer) {
      if (!chNew.isKeyLocalToNode(self,ice.getKey())) {
        keysToRemove.add(ice.getKey());
      }
    }
    if (trace)     log.tracef("Keys to remove after join is complete: %s",keysToRemove.size());
  }
 else {
    if (trace)     log.trace("Rehash not enabled, so not pushing state");
  }
}
