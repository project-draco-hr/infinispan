{
  if (!stateTransferManager.startStateTransfer(newViewId,members,initialView))   return;
  long start=System.currentTimeMillis();
  if (log.isDebugEnabled())   log.debugf("Commencing rehash %d on node: %s. Before start, data container had %d entries",newViewId,self,dataContainer.size());
  Collection<Address> oldCacheSet=Collections.emptySet(), newCacheSet=Collections.emptySet();
  List<Object> keysToRemove=new ArrayList<Object>();
  boolean unblockTransactions=true;
  try {
    stateTransferLock.blockNewTransactions();
    dm.setConsistentHash(chNew);
    if (trace) {
      log.tracef("Rebalancing: chOld = %s, chNew = %s",chOld,chNew);
    }
    if (configuration.isRehashEnabled() && !initialView) {
      oldCacheSet=Immutables.immutableCollectionWrap(chOld.getCaches());
      newCacheSet=Immutables.immutableCollectionWrap(chNew.getCaches());
      cacheNotifier.notifyDataRehashed(oldCacheSet,newCacheSet,newViewId,true);
      int numOwners=configuration.getNumOwners();
      final Map<Address,Collection<InternalCacheEntry>> states=new HashMap<Address,Collection<InternalCacheEntry>>();
      for (      InternalCacheEntry ice : dataContainer) {
        rebalance(ice.getKey(),ice,numOwners,chOld,chNew,null,states,keysToRemove);
      }
      CacheStore cacheStore=stateTransferManager.getCacheStoreForStateTransfer();
      if (cacheStore != null) {
        for (        Object key : cacheStore.loadAllKeys(new ReadOnlyDataContainerBackedKeySet(dataContainer))) {
          rebalance(key,null,numOwners,chOld,chNew,cacheStore,states,keysToRemove);
        }
      }
 else {
        if (trace)         log.trace("No cache store or cache store is shared, not rebalancing stored keys");
      }
      pushState(states);
    }
 else {
      if (!initialView)       log.trace("Rehash not enabled, so not pushing state");
    }
    stateTransferManager.signalPushCompleted(newViewId);
    if (configuration.isRehashEnabled() && !initialView) {
      stateTransferManager.invalidateKeys(keysToRemove,newViewId);
      cacheNotifier.notifyDataRehashed(oldCacheSet,newCacheSet,newViewId,false);
    }
  }
 catch (  PendingStateTransferException e) {
    log.debugf("Another rehash is pending, keeping the transactions blocked");
    unblockTransactions=false;
  }
catch (  SuspectException e) {
    log.debugf("A member left during rehash, keeping the transactions blocked");
    unblockTransactions=false;
  }
 finally {
    boolean isLastView=stateTransferManager.isLastViewId(newViewId);
    if (unblockTransactions && isLastView) {
      try {
        stateTransferLock.unblockNewTransactions();
      }
 catch (      Exception e) {
        log.errorUnblockingTransactions(e);
      }
      stateTransferManager.endStateTransfer();
    }
  }
  log.debugf("Node %s completed rehash for view %d in %s!",self,newViewId,Util.prettyPrintTime(System.currentTimeMillis() - start));
}
