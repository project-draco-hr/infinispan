{
  List<Address> oldOwners=chOld.locate(key,numOwners);
  List<Address> newOwners=chNew.locate(key,numOwners);
  if (oldOwners.equals(newOwners))   return;
  Address pushingOwner=null;
  for (int i=oldOwners.size() - 1; i >= 0; i--) {
    Address server=oldOwners.get(i);
    if (chNew.getCaches().contains(server)) {
      pushingOwner=server;
      break;
    }
  }
  if (trace)   log.tracef("Rebalancing key %s from %s to %s, pushing owner is %s",key,oldOwners,newOwners,pushingOwner);
  if (self.equals(pushingOwner)) {
    if (value == null) {
      try {
        value=cacheStore.load(key);
      }
 catch (      CacheLoaderException e) {
        log.failedLoadingValueFromCacheStore(key);
      }
    }
    for (    Address server : newOwners) {
      if (!oldOwners.contains(server)) {
        Collection<InternalCacheEntry> stateForANode=states.get(server);
        if (stateForANode == null) {
          stateForANode=new ArrayList<InternalCacheEntry>();
          states.put(server,stateForANode);
        }
        if (value != null)         stateForANode.add(value);
        if (stateForANode.size() >= stateTransferChunkSize) {
          pushPartialState(Collections.singleton(server),stateForANode,null);
          states.remove(server);
        }
      }
    }
  }
  if (!newOwners.contains(self)) {
    keysToRemove.add(key);
  }
}
