{
  ConfigurationBuilder cb=new ConfigurationBuilder();
  cb.clustering().invocationBatching().enable().clustering().cacheMode(CacheMode.DIST_SYNC).clustering().stateTransfer().timeout(10000).versioning().enable().scheme(VersioningScheme.SIMPLE).locking().lockAcquisitionTimeout(200).writeSkewCheck(true).isolationLevel(IsolationLevel.REPEATABLE_READ);
  Configuration configuration=cb.build();
  List<Address> members1=new ArrayList<Address>();
  for (int i=0; i < 6; i++) {
    members1.add(new TestAddress(i));
  }
  List<Address> members2=new ArrayList<Address>(members1);
  members2.remove(new TestAddress(5));
  members2.add(new TestAddress(6));
  DefaultConsistentHashFactory chf=new DefaultConsistentHashFactory();
  DefaultConsistentHash ch1=chf.create(new MurmurHash3(),2,4,members1);
  DefaultConsistentHash ch2=chf.updateMembers(ch1,members2);
  log.debug(ch1.dump());
  log.debug(ch2.dump());
  StateTransferManager stateTransferManager=mock(StateTransferManager.class);
  CacheNotifier cacheNotifier=mock(CacheNotifier.class);
  ExecutorService executorService2=mock(ExecutorService.class);
  RpcManager rpcManager=mock(RpcManager.class);
  CommandsFactory commandsFactory=mock(CommandsFactory.class);
  CacheLoaderManager cacheLoaderManager=mock(CacheLoaderManager.class);
  DataContainer dataContainer=mock(DataContainer.class);
  TransactionTable transactionTable=mock(TransactionTable.class);
  StateTransferLock stateTransferLock=mock(StateTransferLock.class);
  InterceptorChain interceptorChain=mock(InterceptorChain.class);
  InvocationContextContainer icc=mock(InvocationContextContainer.class);
  when(executorService2.submit(any(Runnable.class))).thenAnswer(new Answer<Future<?>>(){
    @Override public Future<?> answer(    InvocationOnMock invocation){
      return null;
    }
  }
);
  when(commandsFactory.buildStateRequestCommand(any(StateRequestCommand.Type.class),any(Address.class),anyInt(),any(Set.class))).thenAnswer(new Answer<StateRequestCommand>(){
    @Override public StateRequestCommand answer(    InvocationOnMock invocation){
      return new StateRequestCommand("cache1",(StateRequestCommand.Type)invocation.getArguments()[0],(Address)invocation.getArguments()[1],(Integer)invocation.getArguments()[2],(Set)invocation.getArguments()[3]);
    }
  }
);
  when(rpcManager.getAddress()).thenReturn(new TestAddress(0));
  when(rpcManager.invokeRemotely(any(Collection.class),any(ReplicableCommand.class),any(ResponseMode.class),anyLong())).thenAnswer(new Answer<Map<Address,Response>>(){
    @Override public Map<Address,Response> answer(    InvocationOnMock invocation){
      Collection<Address> recipients=(Collection<Address>)invocation.getArguments()[0];
      ReplicableCommand rpcCommand=(ReplicableCommand)invocation.getArguments()[1];
      if (rpcCommand instanceof StateRequestCommand) {
        StateRequestCommand cmd=(StateRequestCommand)rpcCommand;
        Map<Address,Response> results=new HashMap<Address,Response>();
        if (cmd.getType().equals(StateRequestCommand.Type.GET_TRANSACTIONS)) {
          for (          Address recipient : recipients) {
            results.put(recipient,SuccessfulResponse.create(new ArrayList<TransactionInfo>()));
          }
        }
 else         if (cmd.getType().equals(StateRequestCommand.Type.START_STATE_TRANSFER) || cmd.getType().equals(StateRequestCommand.Type.CANCEL_STATE_TRANSFER)) {
          for (          Address recipient : recipients) {
            results.put(recipient,SuccessfulResponse.SUCCESSFUL_EMPTY_RESPONSE);
          }
        }
        return results;
      }
      return Collections.emptyMap();
    }
  }
);
  StateConsumerImpl stateConsumer=new StateConsumerImpl(stateTransferManager,cacheNotifier,interceptorChain,icc,configuration,rpcManager,commandsFactory,cacheLoaderManager,dataContainer,transactionTable,stateTransferLock);
  final List<InternalCacheEntry> cacheEntries=new ArrayList<InternalCacheEntry>();
  Object key1=new TestKey("key1",0,ch1);
  Object key2=new TestKey("key2",0,ch1);
  cacheEntries.add(new ImmortalCacheEntry(key1,"value1"));
  cacheEntries.add(new ImmortalCacheEntry(key2,"value2"));
  when(dataContainer.iterator()).thenAnswer(new Answer<Iterator<InternalCacheEntry>>(){
    @Override public Iterator<InternalCacheEntry> answer(    InvocationOnMock invocation){
      return cacheEntries.iterator();
    }
  }
);
  when(transactionTable.getLocalTransactions()).thenReturn(Collections.<LocalTransaction>emptyList());
  when(transactionTable.getRemoteTransactions()).thenReturn(Collections.<RemoteTransaction>emptyList());
  Set<Integer> segments=new HashSet<Integer>(Arrays.asList(0,1,2,3,4));
  Set<Integer> seg=new HashSet<Integer>(Arrays.asList(0));
  assertFalse(stateConsumer.isStateTransferInProgress());
  stateConsumer.onTopologyUpdate(1,ch1,ch1);
  assertTrue(stateConsumer.isStateTransferInProgress());
  stateConsumer.onTopologyUpdate(2,ch1,ch2);
  stateConsumer.shutdown();
  assertFalse(stateConsumer.isStateTransferInProgress());
}
