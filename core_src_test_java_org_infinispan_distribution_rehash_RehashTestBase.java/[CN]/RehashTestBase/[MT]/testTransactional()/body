{
  final List<MagicKey> keys=init();
  final CountDownLatch l=new CountDownLatch(1);
  final AtomicBoolean rollback=new AtomicBoolean(false);
  StateTransferFunctionalTest.MergedViewListener mergedViewListener=new StateTransferFunctionalTest.MergedViewListener();
  cacheManagers.get(0).addListener(mergedViewListener);
  cacheManagers.get(1).addListener(mergedViewListener);
  cacheManagers.get(2).addListener(mergedViewListener);
  cacheManagers.get(3).addListener(mergedViewListener);
  Thread th=new Thread("Updater"){
    @Override public void run(){
      try {
        TransactionManager t1=TestingUtil.getTransactionManager(c1);
        t1.begin();
        c1.put(keys.get(0),"transactionally_replaced");
        Transaction tx=t1.getTransaction();
        tx.enlistResource(new XAResourceAdapter(){
          public int prepare(          Xid id){
            try {
              l.await();
            }
 catch (            InterruptedException e) {
            }
            return XAResource.XA_OK;
          }
        }
);
        t1.commit();
      }
 catch (      Exception e) {
        rollback.set(true);
        throw new RuntimeException(e);
      }
    }
  }
;
  th.start();
  log.info("Invoking rehash event");
  performRehashEvent(true);
  l.countDown();
  th.join();
  log.info("Rehash complete");
  additionalWait();
  if (!rollback.get()) {
    assertOnAllCaches(keys.get(0),"transactionally_replaced");
    assertOnAllCaches(keys.get(1),"v" + 2);
    assertOnAllCaches(keys.get(2),"v" + 3);
    assertOnAllCaches(keys.get(3),"v" + 4);
    if (!mergedViewListener.merged) {
      RehashWaiter.waitForRehashToComplete(new ArrayList<Cache>(caches));
      assertOwnershipAndNonOwnership(keys.get(0));
      assertOwnershipAndNonOwnership(keys.get(1));
      assertOwnershipAndNonOwnership(keys.get(3));
    }
    assertProperConsistentHashOnAllCaches();
  }
}
