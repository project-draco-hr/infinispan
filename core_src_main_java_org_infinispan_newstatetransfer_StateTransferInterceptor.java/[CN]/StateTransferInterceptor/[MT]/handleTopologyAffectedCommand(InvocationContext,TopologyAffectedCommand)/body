{
  Set<Address> newTargets=null;
  stateTransferLock.commandsSharedLock();
  CacheTopology cacheTopology=stateTransferManager.getCacheTopology();
  final int topologyId=cacheTopology.getTopologyId();
  final ConsistentHash rCh=cacheTopology.getReadConsistentHash();
  final ConsistentHash wCh=cacheTopology.getWriteConsistentHash();
  try {
    final boolean isTxCommand=command instanceof TransactionBoundaryCommand;
    if (isTxCommand) {
      stateTransferLock.transactionsSharedLock();
    }
    try {
      if (command.getTopologyId() < topologyId) {
        Object readKey=null;
        if (command instanceof GetKeyValueCommand) {
          readKey=((GetKeyValueCommand)command).getKey();
        }
 else         if (command instanceof ClusteredGetCommand) {
          readKey=((ClusteredGetCommand)command).getKey();
        }
        if (readKey != null) {
          if (!rCh.isKeyLocalToNode(rpcManager.getAddress(),readKey)) {
            return null;
          }
        }
 else         if (command instanceof PrepareCommand || command instanceof LockControlCommand || command instanceof WriteCommand) {
          Set<Object> affectedKeys=getAffectedKeys(ctx,command);
          newTargets=new HashSet<Address>();
          boolean localExecutionNeeded=false;
          for (          Object key : affectedKeys) {
            if (wCh.isKeyLocalToNode(rpcManager.getAddress(),key)) {
              localExecutionNeeded=true;
            }
 else {
              newTargets.addAll(wCh.locateOwners(key));
            }
          }
          if (localExecutionNeeded) {
            return invokeNextInterceptor(ctx,command);
          }
        }
 else         if (command instanceof CommitCommand || command instanceof RollbackCommand) {
          try {
            return invokeNextInterceptor(ctx,command);
          }
  finally {
            newTargets=new HashSet<Address>();
            Set<Object> affectedKeys=((TxInvocationContext)ctx).getAffectedKeys();
            for (            Object key : affectedKeys) {
              if (!wCh.isKeyLocalToNode(rpcManager.getAddress(),key)) {
                newTargets.addAll(wCh.locateOwners(key));
              }
            }
          }
        }
      }
 else       if (command.getTopologyId() > topologyId) {
      }
 else {
      }
      return invokeNextInterceptor(ctx,command);
    }
  finally {
      if (isTxCommand) {
        stateTransferLock.transactionsSharedUnlock();
      }
    }
  }
  finally {
    stateTransferLock.commandsSharedUnlock();
    if (newTargets != null && !newTargets.isEmpty()) {
      command.setTopologyId(topologyId);
      rpcManager.invokeRemotely(newTargets,command,true);
    }
  }
}
