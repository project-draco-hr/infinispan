{
  if (trace)   log.tracef("Replication task sending %s to addresses %s with response mode %s",command,dests,mode);
  boolean rsvp=isRsvpCommand(command);
  RspList<Object> retval=null;
  Buffer buf;
  if (deliverOrder == DeliverOrder.TOTAL) {
    buf=marshallCall(marshaller,command);
    Message message=constructMessage(buf,new AnycastAddress(dests),mode,rsvp,deliverOrder);
    retval=card.castMessage(dests,message,new RequestOptions(mode,timeout,false,filter));
  }
 else   if (broadcast || FORCE_MCAST) {
    buf=marshallCall(marshaller,command);
    RequestOptions opts=new RequestOptions(mode,timeout,false,filter);
    opts.setExclusionList(card.getChannel().getAddress());
    retval=card.castMessage(dests,constructMessage(buf,null,mode,rsvp,deliverOrder),opts);
  }
 else {
    RequestOptions opts=new RequestOptions(mode,timeout);
    opts.setExclusionList(card.getChannel().getAddress());
    if (dests.isEmpty())     return new RspList<>();
    buf=marshallCall(marshaller,command);
    if (filter != null) {
      FutureCollator futureCollator=new FutureCollator(filter,dests.size(),timeout,card.timeService);
      for (      Address a : dests) {
        NotifyingFuture<Object> f=card.sendMessageWithFuture(constructMessage(buf,a,mode,rsvp,deliverOrder),opts);
        futureCollator.watchFuture(f,a);
      }
      retval=futureCollator.getResponseList();
    }
 else     if (mode == ResponseMode.GET_ALL) {
      Map<Address,Future<Object>> futures=new HashMap<>(dests.size());
      for (      Address dest : dests)       futures.put(dest,card.sendMessageWithFuture(constructMessage(buf,dest,mode,rsvp,deliverOrder),opts));
      retval=new RspList<>();
      for (      Map.Entry<Address,Future<Object>> entry : futures.entrySet()) {
        Address target=entry.getKey();
        try {
          retval.addRsp(target,entry.getValue().get(timeout,MILLISECONDS));
        }
 catch (        java.util.concurrent.TimeoutException te) {
          throw new TimeoutException(formatString("Timed out after %s waiting for a response from %s",prettyPrintTime(timeout),target));
        }
catch (        ExecutionException e) {
          if (ignoreLeavers && e.getCause() instanceof SuspectedException) {
            log.tracef(formatString("Ignoring node %s that left during the remote call",target));
          }
 else {
            throw wrapThrowableInException(e.getCause());
          }
        }
      }
    }
 else     if (mode == ResponseMode.GET_NONE) {
      for (      Address dest : dests)       card.sendMessage(constructMessage(buf,dest,mode,rsvp,deliverOrder),opts);
    }
  }
  if (mode != ResponseMode.GET_NONE) {
    if (trace)     log.tracef("Responses: %s",retval);
    if (retval == null)     throw new NotSerializableException("RpcDispatcher returned a null.  This is most often caused by args for " + command.getClass().getSimpleName() + " not being serializable.");
  }
  return retval;
}
