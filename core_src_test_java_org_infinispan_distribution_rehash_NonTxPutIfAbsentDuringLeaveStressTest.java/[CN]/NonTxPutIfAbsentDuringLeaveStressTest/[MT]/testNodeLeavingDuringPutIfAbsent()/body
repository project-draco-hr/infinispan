{
  Future[] futures=new Future[NUM_WRITERS];
  for (int i=0; i < NUM_WRITERS; i++) {
    final int writerIndex=i;
    futures[i]=fork(new Callable(){
      @Override public Object call() throws Exception {
        while (!stop) {
          for (int j=0; j < NUM_KEYS; j++) {
            Cache<Object,Object> cache=cache(writerIndex % NUM_ORIGINATORS);
            putRetryOnSuspect(cache,"key_" + j,"value_" + j + "_"+ writerIndex);
          }
        }
        return null;
      }
      private void putRetryOnSuspect(      Cache<Object,Object> cache,      String key,      String value){
        try {
          Object oldValue=cache.putIfAbsent(key,value);
          Object newValue=cache.get(key);
          if (oldValue == null) {
            log.tracef("Successfully inserted value %s for key %s",value,key);
            assertEquals(value,newValue);
            assertNull(insertedValues.putIfAbsent(key,value));
          }
 else {
            assertEquals(oldValue,newValue);
          }
        }
 catch (        CacheException e) {
          Throwable ce=e;
          while (ce instanceof RemoteException) {
            ce=ce.getCause();
          }
          if (!(ce instanceof OutdatedTopologyException) && !(ce instanceof SuspectException))           throw e;
          putRetryOnSuspect(cache,key,value);
        }
      }
    }
);
  }
  killMember(4);
  waitForClusterToForm();
  killMember(3);
  waitForClusterToForm();
  stop=true;
  for (int i=0; i < NUM_WRITERS; i++) {
    futures[i].get(10,TimeUnit.SECONDS);
    for (int j=0; j < NUM_KEYS; j++) {
      for (int k=0; k < caches().size(); k++) {
        String key="key_" + j;
        assertEquals(insertedValues.get(key),cache(k).get(key));
      }
    }
  }
}
