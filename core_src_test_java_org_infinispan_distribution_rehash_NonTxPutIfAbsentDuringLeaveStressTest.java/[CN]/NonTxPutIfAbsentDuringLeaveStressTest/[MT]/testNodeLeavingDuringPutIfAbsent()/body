{
  Future[] futures=new Future[NUM_WRITERS];
  for (int i=0; i < NUM_WRITERS; i++) {
    final int writerIndex=i;
    futures[i]=fork(new Callable(){
      @Override public Object call() throws Exception {
        while (!stop) {
          for (int j=0; j < NUM_KEYS; j++) {
            Cache<Object,Object> cache=cache(writerIndex % NUM_ORIGINATORS);
            doPut(cache,"key_" + j,"value_" + j + "_"+ writerIndex);
          }
        }
        return null;
      }
      private void doPut(      Cache<Object,Object> cache,      String key,      String value){
        Object oldValue=cache.putIfAbsent(key,value);
        Object newValue=cache.get(key);
        if (oldValue == null) {
          log.tracef("Successfully inserted value %s for key %s",value,key);
          assertEquals(value,newValue);
          assertNull(insertedValues.putIfAbsent(key,value));
        }
 else {
          assertEquals(oldValue,newValue);
        }
      }
    }
);
  }
  killMember(4);
  TestingUtil.waitForRehashToComplete(caches());
  killMember(3);
  TestingUtil.waitForRehashToComplete(caches());
  stop=true;
  for (int i=0; i < NUM_WRITERS; i++) {
    futures[i].get(10,TimeUnit.SECONDS);
    for (int j=0; j < NUM_KEYS; j++) {
      for (int k=0; k < caches().size(); k++) {
        String key="key_" + j;
        assertEquals(insertedValues.get(key),cache(k).get(key));
      }
    }
  }
}
