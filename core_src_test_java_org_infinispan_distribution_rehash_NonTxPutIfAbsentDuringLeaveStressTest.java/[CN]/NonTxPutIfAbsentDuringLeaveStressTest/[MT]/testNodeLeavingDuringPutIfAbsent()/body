{
  Future[] futures=new Future[NUM_WRITERS];
  for (int i=0; i < NUM_WRITERS; i++) {
    final int finalI=i;
    futures[i]=fork(new Callable(){
      @Override public Object call() throws Exception {
        for (int j=0; j < NUM_KEYS; j++) {
          Cache<Object,Object> cache=cache(finalI % NUM_ORIGINATORS);
          putRetryOnSuspect(cache,"key_" + finalI + "_"+ j,"value_" + finalI + "_"+ j);
        }
        return null;
      }
      private void putRetryOnSuspect(      Cache<Object,Object> cache,      String key,      String value){
        try {
          cache.putIfAbsent(key,value);
        }
 catch (        CacheException e) {
          Throwable ce=e;
          while (ce instanceof RemoteException) {
            ce=ce.getCause();
          }
          if (!(ce instanceof OutdatedTopologyException) && !(ce instanceof SuspectException))           throw e;
          putRetryOnSuspect(cache,key,value);
        }
      }
    }
);
  }
  killMember(4);
  waitForClusterToForm();
  killMember(3);
  waitForClusterToForm();
  TimeUnit.MILLISECONDS.sleep(NUM_KEYS * NUM_WRITERS);
  for (int i=0; i < NUM_WRITERS; i++) {
    futures[i].get(10,TimeUnit.SECONDS);
    for (int j=0; j < NUM_KEYS; j++) {
      for (int k=0; k < caches().size(); k++) {
        assertEquals("value_" + i + "_"+ j,cache(k).get("key_" + i + "_"+ j));
      }
    }
  }
}
