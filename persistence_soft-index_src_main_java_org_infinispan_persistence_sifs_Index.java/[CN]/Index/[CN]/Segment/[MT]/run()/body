{
  try {
    int counter=0;
    while (true) {
      if (++counter % 30000 == 0) {
        log.debug("Queue size is " + indexQueue.size());
      }
      final IndexRequest request=indexQueue.take();
      if (trace)       log.trace("Indexing " + request);
      IndexNode.OverwriteHook overwriteHook;
      IndexNode.RecordChange recordChange;
switch (request.getType()) {
case CLEAR:
        IndexRequest cleared;
      while ((cleared=indexQueue.poll()) != null) {
        cleared.setResult(false);
      }
    CountDownLatch pause=new CountDownLatch(1);
  request.setResult(pause);
log.debug("Waiting for cleared");
pause.await();
continue;
case DELETE_FILE:
if (request.countDown()) {
fileProvider.deleteFile(request.getFile());
compactor.releaseStats(request.getFile());
}
continue;
case STOP:
return;
case GET_SIZE:
request.setResult(size.get());
continue;
case MOVED:
recordChange=IndexNode.RecordChange.MOVE;
overwriteHook=new IndexNode.OverwriteHook(){
@Override public boolean check(int oldFile,int oldOffset){
return oldFile == request.getPrevFile() && oldOffset == request.getPrevOffset();
}
@Override public void setOverwritten(boolean overwritten,int prevFile,int prevOffset){
if (overwritten && request.getOffset() < 0 && request.getPrevOffset() >= 0) {
size.decrementAndGet();
}
}
}
;
break;
case UPDATE:
recordChange=IndexNode.RecordChange.INCREASE;
overwriteHook=new IndexNode.OverwriteHook(){
@Override public void setOverwritten(boolean overwritten,int prevFile,int prevOffset){
request.setResult(overwritten);
if (request.getOffset() >= 0 && prevOffset < 0) {
size.incrementAndGet();
}
 else if (request.getOffset() < 0 && prevOffset >= 0) {
size.decrementAndGet();
}
}
}
;
break;
case DROPPED:
recordChange=IndexNode.RecordChange.DECREASE;
overwriteHook=new IndexNode.OverwriteHook(){
@Override public void setOverwritten(boolean overwritten,int prevFile,int prevOffset){
if (request.getPrevFile() == prevFile && request.getPrevOffset() == prevOffset) {
size.decrementAndGet();
}
}
}
;
break;
case FOUND_OLD:
recordChange=IndexNode.RecordChange.INCREASE_FOR_OLD;
overwriteHook=IndexNode.OverwriteHook.NOOP;
break;
default :
throw new IllegalArgumentException(request.toString());
}
try {
IndexNode.setPosition(root,request.getSerializedKey(),request.getFile(),request.getOffset(),request.getSize(),overwriteHook,recordChange);
}
 catch (IllegalStateException e) {
throw new IllegalStateException(request.toString(),e);
}
temporaryTable.removeConditionally(request.getKey(),request.getFile(),request.getOffset());
}
}
 catch (IOException e) {
throw new RuntimeException(e);
}
catch (InterruptedException e) {
throw new RuntimeException(e);
}
catch (Throwable e) {
log.error("Error in indexer thread",e);
}
 finally {
try {
indexFile.close();
indexFileFile.delete();
}
 catch (IOException e) {
log.error("Failed to close/delete the index",e);
}
}
}
