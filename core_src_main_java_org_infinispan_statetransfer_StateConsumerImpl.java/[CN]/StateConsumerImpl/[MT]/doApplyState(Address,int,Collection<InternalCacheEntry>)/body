{
  if (trace)   log.tracef("Applying new state chunk for segment %d of cache %s from node %s: received %d cache entries",segmentId,cacheName,sender,cacheEntries.size());
  EnumSet<Flag> flags=EnumSet.of(PUT_FOR_STATE_TRANSFER,CACHE_MODE_LOCAL,IGNORE_RETURN_VALUES,SKIP_REMOTE_LOOKUP,SKIP_SHARED_CACHE_STORE,SKIP_OWNERSHIP_CHECK,SKIP_XSITE_BACKUP);
  for (  InternalCacheEntry e : cacheEntries) {
    try {
      InvocationContext ctx;
      if (transactionManager != null) {
        transactionManager.begin();
        ctx=icf.createInvocationContext(transactionManager.getTransaction(),true);
        ((TxInvocationContext)ctx).getCacheTransaction().setStateTransferFlag(PUT_FOR_STATE_TRANSFER);
      }
 else {
        ctx=icf.createSingleKeyNonTxInvocationContext();
      }
      PutKeyValueCommand put=commandsFactory.buildPutKeyValueCommand(e.getKey(),e.getValue(),e.getMetadata(),flags);
      boolean success=false;
      try {
        ctx.setLockOwner(put.getLockOwner());
        interceptorChain.invoke(ctx,put);
        success=true;
      }
  finally {
        if (ctx.isInTxScope()) {
          if (success) {
            try {
              transactionManager.commit();
            }
 catch (            Throwable ex) {
              log.errorf(ex,"Could not commit transaction created by state transfer of key %s",e.getKey());
              if (transactionManager.getTransaction() != null) {
                transactionManager.rollback();
              }
            }
          }
 else {
            transactionManager.rollback();
          }
        }
      }
    }
 catch (    Exception ex) {
      log.problemApplyingStateForKey(ex.getMessage(),e.getKey(),ex);
    }
  }
  if (trace)   log.tracef("Finished applying chunk of segment %d of cache %s",segmentId,cacheName);
}
