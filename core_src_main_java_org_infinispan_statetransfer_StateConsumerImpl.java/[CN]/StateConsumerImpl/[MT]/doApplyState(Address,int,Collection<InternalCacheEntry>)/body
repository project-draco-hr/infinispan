{
  log.debugf("Applying new state for segment %d from %s: received %d cache entries",segmentId,sender,cacheEntries.size());
  if (trace) {
    List<Object> keys=new ArrayList<Object>(cacheEntries.size());
    for (    InternalCacheEntry e : cacheEntries) {
      keys.add(e.getKey());
    }
    log.tracef("Received keys: %s",keys);
  }
  EnumSet<Flag> flags=EnumSet.of(CACHE_MODE_LOCAL,SKIP_LOCKING,IGNORE_RETURN_VALUES,SKIP_SHARED_CACHE_STORE,SKIP_OWNERSHIP_CHECK,SKIP_XSITE_BACKUP);
  for (  InternalCacheEntry e : cacheEntries) {
    InvocationContext ctx=icc.createRemoteInvocationContext(sender);
    try {
      PutKeyValueCommand put=useVersionedPut ? commandsFactory.buildVersionedPutKeyValueCommand(e.getKey(),e.getValue(),e.getLifespan(),e.getMaxIdle(),e.getVersion(),flags) : commandsFactory.buildPutKeyValueCommand(e.getKey(),e.getValue(),e.getLifespan(),e.getMaxIdle(),flags);
      put.setPutIfAbsent(true);
      interceptorChain.invoke(ctx,put);
    }
 catch (    Exception ex) {
      log.problemApplyingStateForKey(ex.getMessage(),e.getKey());
    }
  }
}
