{
  findSources(segments,sources,excludedSources);
  boolean seenFailures=false;
  while (true) {
    Set<Integer> failedSegments=new HashSet<Integer>();
    int topologyId=cacheTopology.getTopologyId();
    for (    Map.Entry<Address,Set<Integer>> sourceEntry : sources.entrySet()) {
      Address source=sourceEntry.getKey();
      Set<Integer> segmentsFromSource=sourceEntry.getValue();
      try {
        List<TransactionInfo> transactions=getTransactions(source,segmentsFromSource,topologyId);
        applyTransactions(source,transactions,topologyId);
      }
 catch (      SuspectException e) {
        log.debugf("Node %s left the cluster before sending transaction information",source);
        failedSegments.addAll(segmentsFromSource);
        excludedSources.add(source);
      }
catch (      CacheException e) {
        log.failedToRetrieveTransactionsForSegments(segments,cacheName,source,e);
        failedSegments.addAll(segmentsFromSource);
      }
    }
    if (failedSegments.isEmpty()) {
      break;
    }
    seenFailures=true;
    sources.clear();
    findSources(failedSegments,sources,excludedSources);
  }
  if (seenFailures) {
    sources.clear();
  }
}
