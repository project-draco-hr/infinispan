{
  final boolean wasMember=ownsData;
  final boolean isMember=cacheTopology.getMembers().contains(rpcManager.getAddress());
  if (trace)   log.tracef("Received new topology for cache %s, isRebalance = %b, isMember = %b, topology = %s",cacheName,isRebalance,isMember,cacheTopology);
  if (!ownsData && isMember) {
    ownsData=true;
  }
  if (isRebalance) {
    stateTransferTopologyId.compareAndSet(NO_REBALANCE_IN_PROGRESS,cacheTopology.getTopologyId());
    cacheNotifier.notifyDataRehashed(cacheTopology.getCurrentCH(),cacheTopology.getPendingCH(),cacheTopology.getUnionCH(),cacheTopology.getTopologyId(),true);
    if (isTotalOrder) {
      if (log.isTraceEnabled()) {
        log.trace("State Transfer in Total Order cache. Waiting for remote transactions to finish");
      }
      try {
        for (        TotalOrderLatch block : totalOrderManager.notifyStateTransferStart(cacheTopology.getTopologyId())) {
          block.awaitUntilUnBlock();
        }
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new CacheException(e);
      }
      if (log.isTraceEnabled()) {
        log.trace("State Transfer in Total Order cache. All remote transactions are finished. Moving on...");
      }
    }
    if (log.isTraceEnabled()) {
      log.tracef("Lock State Transfer in Progress for topology ID %s",cacheTopology.getTopologyId());
    }
  }
  waitingForState.set(false);
  final ConsistentHash newReadCh=cacheTopology.getReadConsistentHash();
  final ConsistentHash newWriteCh=cacheTopology.getWriteConsistentHash();
  final ConsistentHash previousReadCh=this.cacheTopology != null ? this.cacheTopology.getReadConsistentHash() : null;
  final ConsistentHash previousWriteCh=this.cacheTopology != null ? this.cacheTopology.getWriteConsistentHash() : null;
  stateTransferLock.acquireExclusiveTopologyLock();
  this.cacheTopology=cacheTopology;
  if (isRebalance) {
    if (trace)     log.tracef("Start keeping track of keys for rebalance");
    commitManager.startTrack(PUT_FOR_STATE_TRANSFER);
  }
  stateTransferLock.releaseExclusiveTopologyLock();
  stateTransferLock.notifyTopologyInstalled(cacheTopology.getTopologyId());
  try {
    if (isTransactional || isFetchEnabled) {
      Set<Integer> addedSegments;
      if (previousWriteCh == null) {
        addedSegments=getOwnedSegments(newWriteCh);
        Collection<DistributedCallable> callables=getClusterListeners(cacheTopology);
        for (        DistributedCallable callable : callables) {
          callable.setEnvironment(cache,null);
          try {
            callable.call();
          }
 catch (          Exception e) {
            log.clusterListenerInstallationFailure(e);
          }
        }
        if (trace) {
          log.tracef("On cache %s we have: added segments: %s",cacheName,addedSegments);
        }
      }
 else {
        Set<Integer> previousSegments=getOwnedSegments(previousWriteCh);
        Set<Integer> newSegments=getOwnedSegments(newWriteCh);
        Set<Integer> removedSegments=new HashSet<Integer>(previousSegments);
        removedSegments.removeAll(newSegments);
        addedSegments=new HashSet<Integer>(newSegments);
        addedSegments.removeAll(previousSegments);
        if (trace) {
          log.tracef("On cache %s we have: new segments: %s; old segments: %s; removed segments: %s; added segments: %s",cacheName,removedSegments,newSegments,previousSegments,addedSegments);
        }
        cancelTransfers(removedSegments);
        restartBrokenTransfers(cacheTopology,addedSegments);
      }
      if (!addedSegments.isEmpty()) {
        addTransfers(addedSegments);
      }
    }
    int rebalanceTopologyId=stateTransferTopologyId.get();
    log.tracef("Topology update processed, stateTransferTopologyId = %s, isRebalance = %s, pending CH = %s",rebalanceTopologyId,isRebalance,cacheTopology.getPendingCH());
    if (rebalanceTopologyId != NO_REBALANCE_IN_PROGRESS) {
      if (!isRebalance && cacheTopology.getPendingCH() == null) {
        boolean changed=stateTransferTopologyId.compareAndSet(rebalanceTopologyId,NO_REBALANCE_IN_PROGRESS);
        if (changed) {
          stopApplyingState();
          cacheNotifier.notifyDataRehashed(previousReadCh,cacheTopology.getCurrentCH(),previousWriteCh,cacheTopology.getTopologyId(),false);
          if (log.isTraceEnabled()) {
            log.tracef("Unlock State Transfer in Progress for topology ID %s",cacheTopology.getTopologyId());
          }
          if (isTotalOrder) {
            totalOrderManager.notifyStateTransferEnd();
          }
        }
      }
    }
  }
  finally {
    stateTransferLock.notifyTransactionDataReceived(cacheTopology.getTopologyId());
    remoteCommandsExecutor.checkForReadyTasks();
    if (stateTransferTopologyId.get() != NO_REBALANCE_IN_PROGRESS) {
      waitingForState.set(true);
    }
    notifyEndOfRebalanceIfNeeded(cacheTopology.getTopologyId());
    if (transactionTable != null) {
      transactionTable.cleanupStaleTransactions(cacheTopology);
    }
    if (isMember) {
      Set<Integer> removedSegments;
      if (wasMember) {
        removedSegments=new HashSet<>(previousWriteCh.getSegmentsForOwner(rpcManager.getAddress()));
      }
 else {
        removedSegments=new HashSet<Integer>(newWriteCh.getNumSegments());
        for (int i=0; i < newWriteCh.getNumSegments(); i++) {
          removedSegments.add(i);
        }
      }
      Set<Integer> newSegments=newWriteCh.getSegmentsForOwner(rpcManager.getAddress());
      removedSegments.removeAll(newSegments);
      Set<Integer> staleL1Segments=computeStaleL1Segments(newSegments,newWriteCh,previousWriteCh);
      try {
        removeStaleData(removedSegments,staleL1Segments);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new CacheException(e);
      }
    }
  }
}
