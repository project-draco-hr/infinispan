{
  if (trace)   log.tracef("Received new topology for cache %s, isRebalance = %b, topology = %s",cacheName,isRebalance,cacheTopology);
  activeTopologyUpdates.incrementAndGet();
  if (isRebalance) {
    if (!ownsData && cacheTopology.getMembers().contains(rpcManager.getAddress())) {
      ownsData=true;
    }
    rebalanceInProgress.set(true);
    waitingForState.set(true);
    cacheNotifier.notifyDataRehashed(cacheTopology.getCurrentCH(),cacheTopology.getPendingCH(),cacheTopology.getTopologyId(),true);
    if (configuration.transaction().transactionProtocol().isTotalOrder()) {
      if (log.isTraceEnabled()) {
        log.trace("State Transfer in Total Order cache. Waiting for remote transactions to finish");
      }
      try {
        for (        TotalOrderLatch block : totalOrderManager.notifyStateTransferStart(cacheTopology.getTopologyId())) {
          block.awaitUntilUnBlock();
        }
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new CacheException(e);
      }
      if (log.isTraceEnabled()) {
        log.trace("State Transfer in Total Order cache. All remote transactions are finished. Moving on...");
      }
    }
    if (log.isTraceEnabled()) {
      log.tracef("Lock State Transfer in Progress for topology ID %s",cacheTopology.getTopologyId());
    }
  }
 else {
    if (cacheTopology.getMembers().size() == 1 && cacheTopology.getMembers().get(0).equals(rpcManager.getAddress())) {
      ownsData=true;
    }
  }
  final ConsistentHash previousReadCh=this.cacheTopology != null ? this.cacheTopology.getReadConsistentHash() : null;
  final ConsistentHash previousWriteCh=this.cacheTopology != null ? this.cacheTopology.getWriteConsistentHash() : null;
  stateTransferLock.acquireExclusiveTopologyLock();
  this.cacheTopology=cacheTopology;
  if (isRebalance) {
    updatedKeys=new ConcurrentHashSet<Object>();
  }
  stateTransferLock.releaseExclusiveTopologyLock();
  stateTransferLock.notifyTopologyInstalled(cacheTopology.getTopologyId());
  try {
    if (isTransactional || isFetchEnabled) {
      Set<Integer> addedSegments;
      if (previousWriteCh == null) {
        addedSegments=getOwnedSegments(cacheTopology.getWriteConsistentHash());
        if (trace) {
          log.tracef("On cache %s we have: added segments: %s",cacheName,addedSegments);
        }
      }
 else {
        Set<Integer> previousSegments=getOwnedSegments(previousWriteCh);
        Set<Integer> newSegments=getOwnedSegments(cacheTopology.getWriteConsistentHash());
        Set<Integer> removedSegments=new HashSet<Integer>(previousSegments);
        removedSegments.removeAll(newSegments);
        addedSegments=new HashSet<Integer>(newSegments);
        addedSegments.removeAll(previousSegments);
        if (trace) {
          log.tracef("On cache %s we have: removed segments: %s; new segments: %s; old segments: %s; added segments: %s",cacheName,removedSegments,newSegments,previousSegments,addedSegments);
        }
        cancelTransfers(removedSegments);
        invalidateSegments(newSegments,removedSegments);
        Set<Address> members=new HashSet<Address>(cacheTopology.getReadConsistentHash().getMembers());
synchronized (this) {
          for (Iterator<Address> it=transfersBySource.keySet().iterator(); it.hasNext(); ) {
            Address source=it.next();
            if (!members.contains(source)) {
              if (trace) {
                log.tracef("Removing inbound transfers from source %s for cache %s",source,cacheName);
              }
              List<InboundTransferTask> inboundTransfers=transfersBySource.get(source);
              it.remove();
              for (              InboundTransferTask inboundTransfer : inboundTransfers) {
                if (trace) {
                  log.tracef("Removing inbound transfers for segments %s from source %s for cache %s",inboundTransfer.getSegments(),source,cacheName);
                }
                taskQueue.remove(inboundTransfer);
                inboundTransfer.terminate();
                transfersBySegment.keySet().removeAll(inboundTransfer.getSegments());
                addedSegments.addAll(inboundTransfer.getUnfinishedSegments());
              }
            }
          }
          addedSegments.removeAll(transfersBySegment.keySet());
        }
      }
      if (!addedSegments.isEmpty()) {
        addTransfers(addedSegments);
      }
    }
    log.tracef("Topology update processed, rebalanceInProgress = %s, isRebalance = %s, pending CH = %s",rebalanceInProgress.get(),isRebalance,cacheTopology.getPendingCH());
    if (rebalanceInProgress.get()) {
      if (!isRebalance && cacheTopology.getPendingCH() == null) {
        boolean changed=rebalanceInProgress.compareAndSet(true,false);
        if (changed) {
          cacheNotifier.notifyDataRehashed(previousReadCh,cacheTopology.getCurrentCH(),cacheTopology.getTopologyId(),false);
          if (log.isTraceEnabled()) {
            log.tracef("Unlock State Transfer in Progress for topology ID %s",cacheTopology.getTopologyId());
          }
          totalOrderManager.notifyStateTransferEnd();
        }
      }
    }
  }
  finally {
    stateTransferLock.notifyTransactionDataReceived(cacheTopology.getTopologyId());
    if (activeTopologyUpdates.decrementAndGet() == 0) {
      notifyEndOfTopologyUpdate(cacheTopology.getTopologyId());
    }
    if (transactionTable != null) {
      transactionTable.cleanupStaleTransactions(cacheTopology);
    }
  }
}
