{
  if (trace)   log.tracef("Received new CH %s for cache %s",cacheTopology.getWriteConsistentHash(),cacheName);
  activeTopologyUpdates.incrementAndGet();
  if (isRebalance) {
    rebalanceInProgress.set(true);
  }
  final ConsistentHash previousCh=this.cacheTopology != null ? this.cacheTopology.getWriteConsistentHash() : null;
  stateTransferLock.acquireExclusiveTopologyLock();
  this.cacheTopology=cacheTopology;
  stateTransferLock.releaseExclusiveTopologyLock();
  stateTransferLock.notifyTopologyInstalled(cacheTopology.getTopologyId());
  try {
    Set<Integer> addedSegments;
    if (previousCh == null) {
      addedSegments=getOwnedSegments(cacheTopology.getWriteConsistentHash());
      if (trace) {
        log.tracef("On cache %s we have: added segments: %s",cacheName,addedSegments);
      }
    }
 else {
      Set<Integer> previousSegments=getOwnedSegments(previousCh);
      Set<Integer> newSegments=getOwnedSegments(cacheTopology.getWriteConsistentHash());
      Set<Integer> removedSegments=new HashSet<Integer>(previousSegments);
      removedSegments.removeAll(newSegments);
      addedSegments=new HashSet<Integer>(newSegments);
      addedSegments.removeAll(previousSegments);
      Set<Integer> invalidL1Segments=new HashSet<Integer>();
      for (int segment=0; segment < cacheTopology.getCurrentCH().getNumSegments(); segment++) {
        if (!previousSegments.contains(segment) && newSegments.contains(segment)) {
          List<Address> previousOwners=previousCh.locateOwnersForSegment(segment);
          List<Address> newOwners=cacheTopology.getWriteConsistentHash().locateOwnersForSegment(segment);
          if (!newOwners.containsAll(previousOwners)) {
            invalidL1Segments.add(segment);
          }
        }
      }
      if (trace) {
        log.tracef("On cache %s we have: removed segments: %s; new segments: %s; old segments: %s; added segments: %s",cacheName,removedSegments,newSegments,previousSegments,addedSegments);
      }
      cancelTransfers(removedSegments);
      invalidateSegments(removedSegments,invalidL1Segments);
      Set<Address> members=new HashSet<Address>(cacheTopology.getReadConsistentHash().getMembers());
synchronized (this) {
        for (Iterator<Address> it=transfersBySource.keySet().iterator(); it.hasNext(); ) {
          Address source=it.next();
          if (!members.contains(source)) {
            if (trace) {
              log.tracef("Removing inbound transfers from source %s for cache %s",source,cacheName);
            }
            List<InboundTransferTask> inboundTransfers=transfersBySource.get(source);
            it.remove();
            for (            InboundTransferTask inboundTransfer : inboundTransfers) {
              if (trace) {
                log.tracef("Removing inbound transfers for segments %s from source %s for cache %s",inboundTransfer.getSegments(),source,cacheName);
              }
              transfersBySegment.keySet().removeAll(inboundTransfer.getSegments());
            }
          }
        }
        addedSegments.removeAll(transfersBySegment.keySet());
      }
    }
    if (!addedSegments.isEmpty()) {
      addTransfers(addedSegments);
    }
  }
  finally {
    stateTransferLock.notifyTransactionDataReceived(cacheTopology.getTopologyId());
    if (activeTopologyUpdates.decrementAndGet() == 0) {
      notifyEndOfTopologyUpdate(cacheTopology.getTopologyId());
    }
  }
}
