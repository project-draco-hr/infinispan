{
  if (trace)   log.tracef("Received new CH: %s",cacheTopology.getWriteConsistentHash());
  activeTopologyUpdates.incrementAndGet();
  if (isRebalance) {
    rebalanceInProgress.set(true);
  }
  ConsistentHash previousCh=this.cacheTopology != null ? this.cacheTopology.getWriteConsistentHash() : null;
  stateTransferLock.acquireExclusiveTopologyLock();
  this.cacheTopology=cacheTopology;
  stateTransferLock.releaseExclusiveTopologyLock();
  stateTransferLock.topologyInstalled(cacheTopology.getTopologyId());
  try {
    Set<Integer> addedSegments;
    if (previousCh == null) {
      addedSegments=getOwnedSegments(cacheTopology.getWriteConsistentHash());
    }
 else {
      Set<Integer> previousSegments=getOwnedSegments(previousCh);
      Set<Integer> newSegments=getOwnedSegments(cacheTopology.getWriteConsistentHash());
      Set<Integer> removedSegments=new HashSet<Integer>(previousSegments);
      removedSegments.removeAll(newSegments);
      if (trace) {
        log.tracef("Discarding removed segments: %s; new segments: %s; old segments: %s",removedSegments,newSegments,previousSegments);
      }
      discardSegments(removedSegments);
      Set<Integer> currentSegments=getOwnedSegments(cacheTopology.getReadConsistentHash());
      addedSegments=new HashSet<Integer>(newSegments);
      addedSegments.removeAll(currentSegments);
      Set<Address> members=new HashSet<Address>(cacheTopology.getReadConsistentHash().getMembers());
synchronized (this) {
        for (        Address source : transfersBySource.keySet()) {
          if (!members.contains(source)) {
            List<InboundTransferTask> inboundTransfers=transfersBySource.remove(source);
            if (inboundTransfers != null) {
              for (              InboundTransferTask inboundTransfer : inboundTransfers) {
                transfersBySegment.keySet().removeAll(inboundTransfer.getSegments());
              }
            }
          }
        }
      }
    }
    if (addedSegments != null && !addedSegments.isEmpty()) {
      addTransfers(addedSegments);
    }
  }
  finally {
    stateTransferLock.transactionDataReceived(cacheTopology.getTopologyId());
    if (activeTopologyUpdates.decrementAndGet() == 0 && !isStateTransferInProgress()) {
      notifyEndOfTopologyUpdate(cacheTopology.getTopologyId());
    }
  }
}
