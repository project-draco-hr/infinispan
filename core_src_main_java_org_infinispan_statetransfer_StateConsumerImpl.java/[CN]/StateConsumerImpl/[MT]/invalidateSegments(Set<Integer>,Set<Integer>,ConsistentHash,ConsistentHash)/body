{
  if (keyInvalidationListener != null) {
    keyInvalidationListener.beforeInvalidation(newSegments,segmentsToL1);
  }
  final ConcurrentHashSet<Object> keysToL1=new ConcurrentHashSet<Object>();
  final ConcurrentHashSet<Object> keysToRemove=new ConcurrentHashSet<Object>();
  for (  InternalCacheEntry ice : dataContainer) {
    Object key=ice.getKey();
    int keySegment=getSegment(key);
    if (segmentsToL1.contains(keySegment)) {
      keysToL1.add(key);
    }
 else     if (!newSegments.contains(keySegment)) {
      keysToRemove.add(key);
    }
  }
  try {
    CollectionKeyFilter filter=new CollectionKeyFilter(new ReadOnlyDataContainerBackedKeySet(dataContainer));
    persistenceManager.processOnAllStores(filter,new AdvancedCacheLoader.CacheLoaderTask(){
      @Override public void processEntry(      MarshalledEntry marshalledEntry,      AdvancedCacheLoader.TaskContext taskContext) throws InterruptedException {
        Object key=marshalledEntry.getKey();
        int keySegment=getSegment(key);
        if (segmentsToL1.contains(keySegment)) {
          keysToL1.add(key);
        }
 else         if (!newSegments.contains(keySegment)) {
          keysToRemove.add(key);
        }
      }
    }
,false,false,true);
  }
 catch (  CacheException e) {
    log.failedLoadingKeysFromCacheStore(e);
  }
  if (log.isDebugEnabled()) {
    log.debugf("Removing state for segments %s of cache %s",segmentsToL1,cacheName);
  }
  if (!keysToL1.isEmpty()) {
    try {
      InvalidateCommand invalidateCmd=commandsFactory.buildInvalidateFromL1Command(true,EnumSet.of(CACHE_MODE_LOCAL,SKIP_LOCKING),keysToL1);
      InvocationContext ctx=icf.createNonTxInvocationContext();
      interceptorChain.invoke(ctx,invalidateCmd);
      log.debugf("Invalidated %d keys, data container now has %d keys",keysToL1.size(),dataContainer.size());
      if (trace)       log.tracef("Invalidated keys: %s",keysToL1);
    }
 catch (    CacheException e) {
      log.failedToInvalidateKeys(e);
    }
  }
  log.debugf("Removing state for segments not in %s or %s for cache %s",newSegments,segmentsToL1,cacheName);
  if (!keysToRemove.isEmpty()) {
    try {
      InvalidateCommand invalidateCmd=commandsFactory.buildInvalidateCommand(EnumSet.of(CACHE_MODE_LOCAL,SKIP_LOCKING),keysToRemove.toArray());
      InvocationContext ctx=icf.createNonTxInvocationContext();
      interceptorChain.invoke(ctx,invalidateCmd);
      log.debugf("Invalidated %d keys, data container of cache %s now has %d keys",keysToRemove.size(),cacheName,dataContainer.size());
      if (trace)       log.tracef("Invalidated keys: %s",keysToRemove);
    }
 catch (    CacheException e) {
      log.failedToInvalidateKeys(e);
    }
  }
}
