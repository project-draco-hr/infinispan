{
  ConsistentHash wCh=cacheTopology.getWriteConsistentHash();
  if (!wCh.getMembers().contains(rpcManager.getAddress())) {
    if (trace) {
      log.tracef("Ignoring received state because we are no longer a member of cache %s",cacheName);
    }
    return;
  }
  int rebalanceTopologyId=stateTransferTopologyId.get();
  if (rebalanceTopologyId == NO_REBALANCE_IN_PROGRESS) {
    log.debugf("Discarding state response with topology id %d for cache %s, we don't have a state transfer in progress",topologyId,cacheName);
    return;
  }
  if (topologyId < rebalanceTopologyId) {
    log.debugf("Discarding state response with old topology id %d for cache %s, state transfer request topology was %d",(Object)topologyId,cacheName,waitingForState.get());
    return;
  }
  if (trace) {
    log.tracef("Before applying the received state the data container of cache %s has %d keys",cacheName,dataContainer.size());
  }
  final Set<Integer> mySegments=wCh.getSegmentsForOwner(rpcManager.getAddress());
  final CountDownLatch countDownLatch=new CountDownLatch(stateChunks.size());
  for (  final StateChunk stateChunk : stateChunks) {
    stateTransferExecutor.submit(new Callable<Void>(){
      @Override public Void call() throws Exception {
        applyChunk(sender,mySegments,stateChunk);
        countDownLatch.countDown();
        return null;
      }
    }
);
  }
  try {
    countDownLatch.await(timeout,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    throw new CacheException(e);
  }
  if (trace) {
    log.tracef("After applying the received state the data container of cache %s has %d keys",cacheName,dataContainer.size());
synchronized (transferMapsLock) {
      log.tracef("Segments not received yet for cache %s: %s",cacheName,transfersBySource);
    }
  }
}
