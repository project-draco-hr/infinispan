{
  if (trace) {
    log.tracef("Before applying the received state the data container of cache %s has %d keys",cacheName,dataContainer.size());
  }
  for (  StateChunk stateChunk : stateChunks) {
    if (!cacheTopology.getWriteConsistentHash().getSegmentsForOwner(rpcManager.getAddress()).contains(stateChunk.getSegmentId())) {
      log.warnf("Discarding received cache entries for segment %d of cache %s because they do not belong to this node.",stateChunk.getSegmentId(),cacheName);
      continue;
    }
    InboundTransferTask inboundTransfer;
synchronized (this) {
      inboundTransfer=transfersBySegment.get(stateChunk.getSegmentId());
    }
    if (inboundTransfer != null) {
      if (stateChunk.getCacheEntries() != null) {
        doApplyState(sender,stateChunk.getSegmentId(),stateChunk.getCacheEntries());
      }
      inboundTransfer.onStateReceived(stateChunk.getSegmentId(),stateChunk.isLastChunk());
    }
 else {
      log.warnf("Received unsolicited state from node %s for segment %d of cache %s",sender,stateChunk.getSegmentId(),cacheName);
    }
  }
  if (trace) {
    log.tracef("After applying the received state the data container of cache %s has %d keys",cacheName,dataContainer.size());
synchronized (this) {
      log.tracef("Segments not received yet for cache %s: %s",cacheName,transfersBySource);
    }
  }
}
