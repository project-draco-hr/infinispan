{
  if (tce.isPre()) {
    ConsistentHash consistentHashAtStart=tce.getConsistentHashAtStart();
    if (consistentHashAtStart != null) {
      List<Address> leavers=MembershipArithmetic.getMembersLeft(consistentHashAtStart.getMembers(),tce.getConsistentHashAtEnd().getMembers());
      if (!leavers.isEmpty()) {
        log.tracef("Saw %d leavers - kicking off a lock breaking task",leavers.size());
        cleanTxForWhichTheOwnerLeft(leavers);
      }
    }
    return;
  }
  if (!isDistributed) {
    return;
  }
  Address self=transactionTable.rpcManager.getAddress();
  ConsistentHash chOld=tce.getConsistentHashAtStart();
  ConsistentHash chNew=tce.getConsistentHashAtEnd();
  log.tracef("Unlocking keys for which we are no longer an owner");
  for (  RemoteTransaction remoteTx : transactionTable.getRemoteTransactions()) {
    GlobalTransaction gtx=remoteTx.getGlobalTransaction();
    List<Object> keys=new ArrayList<Object>();
    boolean txHasLocalKeys=false;
    for (    Object key : remoteTx.getLockedKeys()) {
      boolean wasLocal=chOld.isKeyLocalToNode(self,key);
      boolean isLocal=chNew.isKeyLocalToNode(self,key);
      if (wasLocal && !isLocal) {
        keys.add(key);
      }
      txHasLocalKeys|=isLocal;
    }
    for (    Object key : remoteTx.getBackupLockedKeys()) {
      boolean isLocal=chNew.isKeyLocalToNode(self,key);
      txHasLocalKeys|=isLocal;
    }
    if (keys.size() > 0) {
      log.tracef("Unlocking keys %s for remote transaction %s as we are no longer an owner",keys,gtx);
      Set<Flag> flags=EnumSet.of(Flag.CACHE_MODE_LOCAL);
      LockControlCommand unlockCmd=new LockControlCommand(keys,cacheName,flags,gtx);
      unlockCmd.init(invoker,transactionTable.icc,transactionTable);
      unlockCmd.setUnlock(true);
      try {
        unlockCmd.perform(null);
        log.tracef("Unlocking moved keys for %s complete.",gtx);
      }
 catch (      Throwable t) {
        log.unableToUnlockRebalancedKeys(gtx,keys,self,t);
      }
    }
    if (!txHasLocalKeys) {
      log.tracef("Killing remote transaction without any local keys %s",gtx);
      RollbackCommand rc=new RollbackCommand(cacheName,gtx);
      rc.init(invoker,transactionTable.icc,transactionTable);
      try {
        rc.perform(null);
        log.tracef("Rollback of transaction %s complete.",gtx);
      }
 catch (      Throwable e) {
        log.unableToRollbackGlobalTx(gtx,e);
      }
 finally {
        transactionTable.removeRemoteTransaction(gtx);
      }
    }
  }
  log.trace("Finished cleaning locks for keys that are no longer local");
}
