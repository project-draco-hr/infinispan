{
  Cassandra.Iface cassandraClient=null;
  try {
    cassandraClient=pool.getConnection();
    Set<InternalCacheEntry> s=new HashSet<InternalCacheEntry>();
    SlicePredicate slicePredicate=new SlicePredicate();
    slicePredicate.setSlice_range(new SliceRange(entryColumnPath.getColumn(),emptyByteArray,false,1));
    String startKey="";
    int sliceSize=Math.min(SLICE_SIZE,numEntries);
    for (boolean complete=false; !complete; ) {
      KeyRange keyRange=new KeyRange(sliceSize);
      keyRange.setStart_token(startKey);
      keyRange.setEnd_token("");
      List<KeySlice> keySlices=cassandraClient.get_range_slices(config.keySpace,entryColumnParent,slicePredicate,keyRange,ConsistencyLevel.ONE);
      for (      KeySlice keySlice : keySlices) {
        String key=unhashKey(keySlice.getKey());
        List<ColumnOrSuperColumn> columns=keySlice.getColumns();
        if (columns.size() > 0) {
          if (log.isDebugEnabled()) {
            log.debug("Loading {0}",key);
          }
          byte[] value=columns.get(0).getColumn().getValue();
          InternalCacheEntry ice=unmarshall(value,key);
          s.add(ice);
        }
 else         if (log.isDebugEnabled()) {
          log.debug("Skipping empty key {0}",key);
        }
      }
      if (keySlices.size() < sliceSize) {
        complete=true;
      }
 else {
        sliceSize=Math.min(SLICE_SIZE,numEntries - s.size());
        if (sliceSize == 0) {
          complete=true;
        }
 else {
          startKey=keySlices.get(keySlices.size() - 1).getKey();
        }
      }
    }
    return s;
  }
 catch (  Exception e) {
    throw new CacheLoaderException(e);
  }
 finally {
    pool.release(cassandraClient);
  }
}
