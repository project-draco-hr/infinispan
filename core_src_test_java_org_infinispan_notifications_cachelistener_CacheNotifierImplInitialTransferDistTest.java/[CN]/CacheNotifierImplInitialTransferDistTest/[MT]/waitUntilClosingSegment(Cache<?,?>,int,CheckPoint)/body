{
  ClusterCacheNotifier realNotifier=TestingUtil.extractComponent(cache,ClusterCacheNotifier.class);
  ConcurrentMap<UUID,QueueingSegmentListener> listeningMap=new ConcurrentHashMap(){
    @Override public Object putIfAbsent(    Object key,    Object value){
      final Answer<Object> listenerAnswer=AdditionalAnswers.delegatesTo(value);
      final AtomicBoolean wasLastSegment=new AtomicBoolean(false);
      QueueingSegmentListener mockListener=mock(QueueingSegmentListener.class,withSettings().defaultAnswer(listenerAnswer));
      doAnswer(new Answer(){
        @Override public Object answer(        InvocationOnMock invocation) throws Throwable {
          wasLastSegment.set(true);
          return listenerAnswer.answer(invocation);
        }
      }
).when(mockListener).segmentTransferred(Mockito.eq(segment),Mockito.eq(true));
      doAnswer(new Answer(){
        @Override public Object answer(        InvocationOnMock invocation) throws Throwable {
          checkPoint.trigger("pre_complete_segment_invoked");
          checkPoint.awaitStrict("pre_complete_segment_released",10,TimeUnit.SECONDS);
          return listenerAnswer.answer(invocation);
        }
      }
).when(mockListener).segmentTransferred(Mockito.eq(segment),Mockito.eq(false));
      doAnswer(new Answer(){
        @Override public Object answer(        InvocationOnMock invocation) throws Throwable {
          if (wasLastSegment.compareAndSet(true,false)) {
            checkPoint.trigger("pre_complete_segment_invoked");
            checkPoint.awaitStrict("pre_complete_segment_released",10,TimeUnit.SECONDS);
          }
          return listenerAnswer.answer(invocation);
        }
      }
).when(mockListener).notifiedKey(Mockito.any());
      return super.putIfAbsent(key,mockListener);
    }
  }
;
  CacheNotifierImpl notifier=new CacheNotifierImpl(listeningMap);
  TestingUtil.replaceComponent(cache,CacheNotifier.class,notifier,true);
  TestingUtil.replaceComponent(cache,ClusterCacheNotifier.class,notifier,true);
  return realNotifier;
}
