{
  boolean checkForPendingLocks=false;
  if (!ctx.isInTxScope()) {
    lockManager.acquireLock(ctx,key);
    return;
  }
  TxInvocationContext txContext=(TxInvocationContext)ctx;
  int transactionViewId=-1;
  if (clustered) {
    transactionViewId=txContext.getCacheTransaction().getViewId();
    if (transactionViewId != TransactionTable.CACHE_STOPPED_VIEW_ID) {
      checkForPendingLocks=transactionViewId > txTable.getMinViewId();
    }
  }
  if (checkForPendingLocks) {
    getLog().tracef("Checking for pending locks and then locking key %s",key);
    long expectedEndTime=nowMillis() + cacheConfiguration.locking().lockAcquisitionTimeout();
    for (    CacheTransaction ct : txTable.getLocalTransactions()) {
      if (ct.getViewId() < transactionViewId) {
        long remaining=expectedEndTime - nowMillis();
        if (remaining < 0 || !ct.waitForLockRelease(key,remaining))         throw newTimeoutException(key,txContext);
      }
    }
    for (    CacheTransaction ct : txTable.getRemoteTransactions()) {
      if (ct.getViewId() < transactionViewId) {
        long remaining=expectedEndTime - nowMillis();
        if (remaining < 0 || !ct.waitForLockRelease(key,remaining))         throw newTimeoutException(key,txContext);
      }
    }
    final long remaining=expectedEndTime - nowMillis();
    if (remaining <= 0) {
      throw newTimeoutException(key,txContext);
    }
 else {
      getLog().tracef("Finished waiting for other potential lockers, trying to acquire the lock on %s",key);
      lockManager.acquireLock(ctx,key,remaining);
    }
  }
 else {
    getLog().tracef("Locking key %s, no need to check for pending locks.",key);
    lockManager.acquireLock(ctx,key);
  }
}
