{
  boolean checkForPendingLocks=false;
  if (!ctx.isInTxScope()) {
    lockManager.acquireLock(ctx,key);
    return;
  }
  TxInvocationContext txContext=(TxInvocationContext)ctx;
  final int transactionViewId=txContext.getCacheTransaction().getViewId();
  if (clustered) {
    if (transactionViewId != TransactionTable.CACHE_STOPPED_VIEW_ID) {
      checkForPendingLocks=transactionViewId > txTable.getMinViewId();
    }
  }
  if (checkForPendingLocks) {
    getLog().tracef("Checking for pending locks and then locking key %s",key);
    Set<CacheTransaction> tx=txTable.getTransactionsStartedBefore(transactionViewId);
    long expectedEndTime=nowMillis() + configuration.getLockAcquisitionTimeout();
    for (    CacheTransaction ct : tx) {
      long remaining=expectedEndTime - nowMillis();
      if (remaining < 0 || !ct.waitForLockRelease(key,remaining))       throw newTimeoutException(key,txContext);
    }
    final long remaining=expectedEndTime - nowMillis();
    if (remaining <= 0) {
      throw newTimeoutException(key,txContext);
    }
 else {
      getLog().tracef("Finished waiting for other potential lockers, trying to acquire the lock on %s",key);
      lockManager.acquireLock(ctx,key,remaining);
    }
  }
 else {
    getLog().tracef("Locking key %s, no need to check for pending locks.",key);
    lockManager.acquireLock(ctx,key);
  }
}
