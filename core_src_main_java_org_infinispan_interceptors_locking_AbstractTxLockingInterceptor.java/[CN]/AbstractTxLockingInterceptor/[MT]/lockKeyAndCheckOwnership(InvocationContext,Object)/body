{
  boolean checkForPendingLocks=false;
  if (!ctx.isInTxScope()) {
    lockManager.acquireLock(ctx,key);
    return;
  }
  TxInvocationContext txContext=(TxInvocationContext)ctx;
  final Integer viewId=txContext.getCacheTransaction().getViewId();
  if (viewId != null) {
    checkForPendingLocks=viewId > txTable.getMinViewId();
  }
  log.tracef("Locking key %s, checking for pending locks? %s",key,checkForPendingLocks);
  if (!checkForPendingLocks) {
    lockManager.acquireLock(ctx,key);
  }
 else {
    Set<CacheTransaction> tx=txTable.getTransactionsStartedBefore(viewId);
    long expectedEndTime=nowMillis() + configuration.getLockAcquisitionTimeout();
    for (    CacheTransaction ct : tx) {
      long remaining=expectedEndTime - nowMillis();
      if (remaining < 0 || !ct.waitForLockRelease(key,remaining))       throw newTimeoutException(key,txContext);
    }
    final long remaining=expectedEndTime - nowMillis();
    if (remaining < 0) {
      throw newTimeoutException(key,txContext);
    }
 else {
      log.tracef("Finished waiting for other potential lockers, trying to acquire the lock on %s",key);
      lockManager.acquireLock(ctx,key,remaining);
    }
  }
}
