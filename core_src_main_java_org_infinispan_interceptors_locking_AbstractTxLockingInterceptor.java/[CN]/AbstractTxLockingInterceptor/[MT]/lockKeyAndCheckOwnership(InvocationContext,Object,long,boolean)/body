{
  if (!ctx.isInTxScope()) {
    lockManager.acquireLock(ctx,key,lockTimeout,skipLocking);
    return;
  }
  TxInvocationContext txContext=(TxInvocationContext)ctx;
  int transactionTopologyId=-1;
  boolean useStrictComparison=true;
  boolean checkForPendingLocks=false;
  if (clustered) {
    transactionTopologyId=txContext.getCacheTransaction().getTopologyId();
    if (transactionTopologyId != TransactionTable.CACHE_STOPPED_TOPOLOGY_ID) {
      useStrictComparison=txTable.useStrictTopologyIdComparison();
      checkForPendingLocks=isFromOlderTopology(txTable.getMinTopologyId(),transactionTopologyId,useStrictComparison);
    }
  }
  if (checkForPendingLocks) {
    getLog().tracef("Checking for pending locks and then locking key %s",key);
    final long expectedEndTime=nowMillis() + cacheConfiguration.locking().lockAcquisitionTimeout();
    waitForTransactionsToComplete(txContext,txTable.getLocalTransactions(),key,transactionTopologyId,useStrictComparison,expectedEndTime);
    waitForTransactionsToComplete(txContext,txTable.getRemoteTransactions(),key,transactionTopologyId,useStrictComparison,expectedEndTime);
    final long remaining=expectedEndTime - nowMillis();
    if (remaining <= 0) {
      throw newTimeoutException(key,txContext);
    }
 else {
      getLog().tracef("Finished waiting for other potential lockers, trying to acquire the lock on %s",key);
      lockManager.acquireLock(ctx,key,remaining,skipLocking);
    }
  }
 else {
    getLog().tracef("Locking key %s, no need to check for pending locks.",key);
    lockManager.acquireLock(ctx,key,lockTimeout,skipLocking);
  }
}
