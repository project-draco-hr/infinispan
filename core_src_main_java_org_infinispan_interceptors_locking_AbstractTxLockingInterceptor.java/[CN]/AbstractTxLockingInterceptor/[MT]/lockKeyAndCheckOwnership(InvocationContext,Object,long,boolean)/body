{
  TxInvocationContext txContext=(TxInvocationContext)ctx;
  int transactionTopologyId=-1;
  boolean checkForPendingLocks=false;
  if (clustered) {
    CacheTransaction tx=txContext.getCacheTransaction();
    boolean isFromStateTransfer=txContext.isOriginLocal() && ((LocalTransaction)tx).isFromStateTransfer();
    if (!isFromStateTransfer) {
      transactionTopologyId=tx.getTopologyId();
      if (transactionTopologyId != TransactionTable.CACHE_STOPPED_TOPOLOGY_ID) {
        checkForPendingLocks=txTable.getMinTopologyId() < transactionTopologyId;
      }
    }
  }
  Log log=getLog();
  boolean trace=log.isTraceEnabled();
  if (checkForPendingLocks) {
    if (trace)     log.tracef("Checking for pending locks and then locking key %s",toStr(key));
    final long expectedEndTime=timeService.expectedEndTime(cacheConfiguration.locking().lockAcquisitionTimeout(),TimeUnit.MILLISECONDS);
    waitForTransactionsToComplete(txContext,txTable.getLocalTransactions(),key,transactionTopologyId,expectedEndTime);
    waitForTransactionsToComplete(txContext,txTable.getRemoteTransactions(),key,transactionTopologyId,expectedEndTime);
    final long remaining=timeService.remainingTime(expectedEndTime,TimeUnit.MILLISECONDS);
    if (remaining <= 0) {
      throw newTimeoutException(key,txContext);
    }
 else {
      if (trace)       log.tracef("Finished waiting for other potential lockers, trying to acquire the lock on %s",toStr(key));
      lockManager.acquireLock(ctx,key,remaining,skipLocking);
    }
  }
 else {
    if (trace)     log.tracef("Locking key %s, no need to check for pending locks.",toStr(key));
    lockManager.acquireLock(ctx,key,lockTimeout,skipLocking);
  }
}
