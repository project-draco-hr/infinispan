{
  boolean isFirstMember;
  CacheTopology topologyBeforeRebalance;
synchronized (this) {
    isFirstMember=getCurrentTopology() == null;
    boolean memberJoined=addMember(joiner,joinInfo);
    if (!memberJoined) {
      if (trace)       log.tracef("Trying to add node %s to cache %s, but it is already a member: " + "members = %s, joiners = %s",joiner,cacheName,expectedMembers,joiners);
      return new CacheStatusResponse(null,currentTopology,stableTopology,availabilityMode);
    }
    if (isFirstMember) {
      List<Address> initialMembers=getExpectedMembers();
      ConsistentHash initialCH=joinInfo.getConsistentHashFactory().create(joinInfo.getHashFunction(),joinInfo.getNumOwners(),joinInfo.getNumSegments(),initialMembers,getCapacityFactors());
      CacheTopology initialTopology=new CacheTopology(0,0,initialCH,null);
      setCurrentTopology(initialTopology);
      setStableTopology(initialTopology);
      clusterTopologyManager.broadcastStableTopologyUpdate(cacheName,initialTopology,isTotalOrder(),isDistributed());
    }
    topologyBeforeRebalance=getCurrentTopology();
    availabilityStrategy.onJoin(this,joiner);
  }
  return new CacheStatusResponse(null,topologyBeforeRebalance,stableTopology,availabilityMode);
}
