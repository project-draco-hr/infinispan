{
  try {
    return invokeNextInterceptor(ctx,command);
  }
  finally {
    boolean originatorMissing=!ctx.isOriginLocal() && !rpcManager.getTransport().getMembers().contains(command.getOrigin());
    boolean alreadyCompleted=!ctx.isOriginLocal() && txTable.isTransactionCompleted(command.getGlobalTransaction()) && !cacheConfiguration.transaction().transactionProtocol().isTotalOrder();
    log.tracef("invokeNextInterceptorAndVerifyTransaction :: originatorMissing=%s, alreadyCompleted=%s",originatorMissing,alreadyCompleted);
    if (alreadyCompleted || originatorMissing) {
      log.tracef("Rolling back remote transaction %s because either already completed(%s) or originator no longer in the cluster(%s).",command.getGlobalTransaction(),alreadyCompleted,originatorMissing);
      RollbackCommand rollback=new RollbackCommand(command.getCacheName(),command.getGlobalTransaction());
      try {
        invokeNextInterceptor(ctx,rollback);
      }
  finally {
        RemoteTransaction remoteTx=(RemoteTransaction)ctx.getCacheTransaction();
        remoteTx.markForRollback(true);
        txTable.removeRemoteTransaction(command.getGlobalTransaction());
      }
    }
  }
}
