{
  locks.computeIfPresent(key,new EquivalentConcurrentHashMapV8.BiFun<Object,L,L>(){
    @Override public L apply(    Object key,    L lock){
      Log log=getLog();
      if (log.isTraceEnabled())       log.tracef("Unlocking lock instance for key %s",toStr(key));
      unlock(lock,lockOwner);
      int refCount=lock.getReferenceCounter().decrementAndGet();
      boolean remove=refCount == 0;
      if (refCount < 0) {
        throw new IllegalStateException("Negative reference count for lock " + key + ": "+ lock);
      }
      return remove ? null : lock;
    }
  }
);
}
