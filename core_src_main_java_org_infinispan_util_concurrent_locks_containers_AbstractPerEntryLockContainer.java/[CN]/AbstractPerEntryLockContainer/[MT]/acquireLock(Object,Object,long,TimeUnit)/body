{
  final ByRef<Boolean> lockAcquired=ByRef.create(Boolean.FALSE);
  L lock=locks.compute(key,new ConcurrentHashMapV8.BiFun<Object,L,L>(){
    @Override public L apply(    Object key,    L lock){
      if (lock == null) {
        getLog().tracef("Creating and acquiring new lock instance for key %s",key);
        lock=newLock();
        lock(lock,lockOwner);
        lockAcquired.set(Boolean.TRUE);
        return lock;
      }
      int refCount=lock.getReferenceCounter().incrementAndGet();
      if (refCount <= 1) {
        throw new IllegalStateException("Lock " + key + " acquired although it should have been removed: "+ lock);
      }
      return lock;
    }
  }
);
  if (!lockAcquired.get()) {
    lockAcquired.set(tryLock(lock,timeout,unit,lockOwner));
  }
  if (lockAcquired.get())   return lock;
 else {
    getLog().tracef("Timed out attempting to acquire lock for key %s after %s",key,Util.prettyPrintTime(timeout,unit));
    locks.computeIfPresent(key,new ConcurrentHashMapV8.BiFun<Object,L,L>(){
      @Override public L apply(      Object key,      L lock){
        boolean remove=lock.getReferenceCounter().decrementAndGet() == 0;
        return remove ? null : lock;
      }
    }
);
    return null;
  }
}
