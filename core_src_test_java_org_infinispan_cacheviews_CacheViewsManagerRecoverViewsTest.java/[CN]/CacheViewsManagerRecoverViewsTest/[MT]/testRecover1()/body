{
  Transport mockTransport=createStrictMock(Transport.class);
  makeThreadSafe(mockTransport,true);
  CacheViewListener mockListener=createStrictMock(CacheViewListener.class);
  makeThreadSafe(mockListener,true);
  List<Address> members1_1=Arrays.asList(a1);
  CacheView v1_1=new CacheView(1,members1_1);
  List<Address> members1_2=Arrays.asList(a2,a3,a4);
  CacheView v1_2=new CacheView(3,members1_2);
  List<Address> members2=Arrays.asList(a1,a2,a3,a4);
  CacheView v2=new CacheView(4,members2);
  Map<Address,Response> noResponse=new HashMap<Address,Response>();
  Map<Address,Response> nullResponses=buildMap(Arrays.asList(a2,a3,a4),Arrays.<Response>asList(null,null,null));
  expect(mockTransport.getAddress()).andReturn(a1);
  expect(mockTransport.getMembers()).andReturn(members1_1);
  expect(mockTransport.getCoordinator()).andReturn(a1);
  expect(mockTransport.isCoordinator()).andReturn(true);
  mockListener.prepareView(v1_1,CacheView.EMPTY_CACHE_VIEW);
  expect(mockTransport.invokeRemotely(eq(members1_1),isA(CacheViewControlCommand.class),eq(ResponseMode.SYNCHRONOUS),anyLong(),anyBoolean(),EasyMock.<ResponseFilter>isNull(),eq(false))).andReturn(noResponse);
  mockListener.updateLeavers(Collections.<Address>emptySet());
  mockListener.commitView(v1_1.getViewId());
  expect(mockTransport.invokeRemotely(eq(members1_1),isA(CacheViewControlCommand.class),eq(ResponseMode.SYNCHRONOUS_IGNORE_LEAVERS),anyLong(),anyBoolean(),EasyMock.<ResponseFilter>isNull(),eq(false))).andReturn(noResponse);
  expect(mockTransport.getCoordinator()).andReturn(a1);
  expect(mockTransport.isCoordinator()).andReturn(true);
  Map<Address,Response> recoveredViews=buildMap(Arrays.asList(a2,a3,a4),Arrays.<Response>asList(new SuccessfulResponse(Collections.singletonMap("cache",v1_2)),new SuccessfulResponse(Collections.singletonMap("cache",v1_2)),new SuccessfulResponse(Collections.singletonMap("cache",v1_2))));
  expect(mockTransport.invokeRemotely(EasyMock.<Collection>isNull(),isA(CacheViewControlCommand.class),eq(ResponseMode.SYNCHRONOUS_IGNORE_LEAVERS),anyLong(),anyBoolean(),EasyMock.<ResponseFilter>isNull(),eq(false))).andReturn(recoveredViews);
  mockListener.rollbackView(v1_1.getViewId());
  expect(mockTransport.invokeRemotely(eq(members1_2),isA(CacheViewControlCommand.class),eq(ResponseMode.SYNCHRONOUS_IGNORE_LEAVERS),anyLong(),anyBoolean(),EasyMock.<ResponseFilter>isNull(),eq(false))).andReturn(nullResponses);
  mockListener.prepareView(v2,v1_1);
  expect(mockTransport.invokeRemotely(eq(members1_2),isA(CacheViewControlCommand.class),eq(ResponseMode.SYNCHRONOUS),anyLong(),anyBoolean(),EasyMock.<ResponseFilter>isNull(),eq(false))).andReturn(nullResponses);
  mockListener.updateLeavers(Collections.<Address>emptySet());
  mockListener.commitView(v2.getViewId());
  expect(mockTransport.invokeRemotely(eq(members1_2),isA(CacheViewControlCommand.class),eq(ResponseMode.SYNCHRONOUS_IGNORE_LEAVERS),anyLong(),anyBoolean(),EasyMock.<ResponseFilter>isNull(),eq(false))).andReturn(nullResponses);
  replay(mockTransport,mockListener);
  CacheManagerNotifierImpl notifier=new CacheManagerNotifierImpl();
  notifier.start();
  ExecutorService asyncTransportExecutor=new WithinThreadExecutor();
  GlobalConfiguration gc=new GlobalConfiguration();
  CacheViewsManagerImpl cvm=new CacheViewsManagerImpl();
  cvm.init(notifier,mockTransport,asyncTransportExecutor,gc);
  cvm.start();
  try {
    cvm.join("cache",mockListener);
    Thread.sleep(1000);
    notifier.notifyMerge(members2,members1_1,a1,3,Arrays.asList(members1_1,members1_2));
    Thread.sleep(1000);
    verify(mockTransport,mockListener);
  }
  finally {
    cvm.stop();
  }
}
