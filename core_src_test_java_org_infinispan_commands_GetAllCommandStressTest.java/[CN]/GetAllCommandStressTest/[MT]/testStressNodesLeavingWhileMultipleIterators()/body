{
  final Map<Integer,Integer> masterValues=new HashMap<Integer,Integer>();
  final Set<Integer>[] keys=new Set[THREAD_WORKER_COUNT];
  for (int i=0; i < keys.length; ++i) {
    keys[i]=new HashSet<Integer>();
  }
  for (int i=0; i < CACHE_ENTRY_COUNT; ++i) {
    masterValues.put(i,i);
    keys[i % THREAD_WORKER_COUNT].add(i);
  }
  cache(0,CACHE_NAME).putAll(masterValues);
  for (int i=0; i < keys.length; ++i) {
    keys[i]=Collections.unmodifiableSet(keys[i]);
  }
  final AtomicBoolean complete=new AtomicBoolean(false);
  final Exchanger<Throwable> exchanger=new Exchanger<Throwable>();
  Future<Void>[] futures=new Future[THREAD_WORKER_COUNT + 1];
  for (int j=0; j < THREAD_MULTIPLIER; ++j) {
    for (int i=0; i < CACHE_COUNT - 1; ++i) {
      final int offset=j * (CACHE_COUNT - 1) + i;
      final Cache<Integer,Integer> cache=cache(i,CACHE_NAME);
      futures[i + j * (CACHE_COUNT - 1)]=fork(new Callable<Void>(){
        @Override public Void call() throws Exception {
          Set<Integer> keysToUse=keys[offset];
          try {
            int iteration=0;
            while (!complete.get()) {
              log.tracef("Starting iteration %s",iteration);
              Map<Integer,Integer> results=cache.getAdvancedCache().getAll(keysToUse);
              assertEquals(keysToUse.size(),results.size());
              for (              Integer key : keysToUse) {
                assertEquals(key,results.get(key));
              }
              iteration++;
            }
            System.out.println(Thread.currentThread() + " finished " + iteration+ " iterations!");
            return null;
          }
 catch (          Throwable e) {
            complete.set(true);
            exchanger.exchange(e);
            throw e;
          }
        }
      }
);
    }
  }
  futures[futures.length - 1]=fork(new Callable<Void>(){
    @Override public Void call() throws Exception {
      TestResourceTracker.testThreadStarted(GetAllCommandStressTest.this);
      try {
        Cache<?,?> cacheToKill=cache(CACHE_COUNT - 1);
        while (!complete.get()) {
          Thread.sleep(1000);
          if (cacheManagers.remove(cacheToKill.getCacheManager())) {
            log.trace("Killing cache to force rehash");
            cacheToKill.getCacheManager().stop();
            List<Cache<Object,Object>> caches=caches(CACHE_NAME);
            if (caches.size() > 0) {
              TestingUtil.blockUntilViewsReceived(60000,false,caches);
              TestingUtil.waitForRehashToComplete(caches);
            }
          }
 else {
            throw new IllegalStateException("Cache Manager " + cacheToKill.getCacheManager() + " wasn't found for some reason!");
          }
          log.trace("Adding new cache again to force rehash");
          cacheToKill=createClusteredCaches(1,CACHE_NAME,builderUsed).get(0);
          log.trace("Added new cache again to force rehash");
        }
        return null;
      }
 catch (      Exception e) {
        complete.set(true);
        exchanger.exchange(e);
        throw e;
      }
    }
  }
);
  try {
    Throwable e=exchanger.exchange(null,1,TimeUnit.MINUTES);
    fail("Found an throwable in at least 1 thread" + e);
  }
 catch (  TimeoutException e) {
  }
  complete.set(true);
  for (int i=0; i < futures.length; ++i) {
    try {
      futures[i].get(20,TimeUnit.MINUTES);
    }
 catch (    TimeoutException e) {
      System.err.println("Future " + i + " did not complete in time allotted.");
      throw e;
    }
  }
}
