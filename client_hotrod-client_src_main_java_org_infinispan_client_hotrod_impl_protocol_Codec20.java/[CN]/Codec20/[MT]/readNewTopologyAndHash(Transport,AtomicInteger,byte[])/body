{
  final Log localLog=getLog();
  int newTopologyId=transport.readVInt();
  topologyId.set(newTopologyId);
  int clusterSize=transport.readVInt();
  SocketAddress[] addresses=new SocketAddress[clusterSize];
  for (int i=0; i < clusterSize; i++) {
    String host=transport.readString();
    int port=transport.readUnsignedShort();
    addresses[i]=new InetSocketAddress(host,port);
  }
  short hashFunctionVersion=transport.readByte();
  int numSegments=transport.readVInt();
  SocketAddress[][] segmentOwners=new SocketAddress[numSegments][];
  for (int i=0; i < numSegments; i++) {
    short numOwners=transport.readByte();
    segmentOwners[i]=new SocketAddress[numOwners];
    for (int j=0; j < numOwners; j++) {
      int memberIndex=transport.readVInt();
      segmentOwners[i][j]=addresses[memberIndex];
    }
  }
  List<SocketAddress> addressList=Arrays.asList(addresses);
  if (localLog.isInfoEnabled()) {
    localLog.newTopology(transport.getRemoteSocketAddress(),newTopologyId,addresses.length,new HashSet<SocketAddress>(addressList));
  }
  transport.getTransportFactory().updateServers(addressList,cacheName);
  if (hashFunctionVersion == 0) {
    if (trace)     localLog.trace("Not using a consistent hash function (hash function version == 0).");
  }
 else {
    transport.getTransportFactory().updateHashFunction(segmentOwners,numSegments,hashFunctionVersion,cacheName);
  }
}
