{
  if (isCancelled())   throw new CancellationException("Task already cancelled");
  V response=null;
  try {
    long taskTimeout=getOwningTask().timeout();
    long futureTimeout=TimeUnit.MILLISECONDS.convert(timeout,unit);
    long actualTimeout=0;
    if (taskTimeout > 0 && futureTimeout > 0) {
      actualTimeout=Math.min(taskTimeout,futureTimeout);
    }
 else {
      actualTimeout=Math.max(taskTimeout,futureTimeout);
    }
    if (actualTimeout > 0) {
      response=retrieveResult(f.get(actualTimeout,TimeUnit.MILLISECONDS));
    }
 else {
      response=retrieveResult(f.get());
    }
  }
 catch (  TimeoutException te) {
    throw te;
  }
catch (  Exception e) {
    boolean canFailover=failedOverCount++ < getOwningTask().getTaskFailoverPolicy().maxFailoverAttempts();
    if (canFailover) {
      try {
        response=failoverExecution(e,timeout,unit);
      }
 catch (      Exception failedOver) {
        throw wrapIntoExecutionException(failedOver);
      }
    }
 else {
      throw wrapIntoExecutionException(e);
    }
  }
  return response;
}
