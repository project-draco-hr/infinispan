{
  if (isCancelled())   throw new CancellationException("Task already cancelled");
  long timeoutNanos=computeTimeoutNanos(timeout,unit);
  long endNanos=System.nanoTime() + timeoutNanos;
  V response;
  try {
    if (timeoutNanos > 0) {
      response=retrieveResult(f.get(timeoutNanos,TimeUnit.NANOSECONDS));
    }
 else {
      response=retrieveResult(f.get());
    }
  }
 catch (  TimeoutException te) {
    throw te;
  }
catch (  Exception e) {
    long remainingNanos=timeoutNanos > 0 ? endNanos - System.nanoTime() : timeoutNanos;
    if (timeoutNanos > 0 && remainingNanos <= 0) {
      if (trace)       log.tracef("Distributed task timed out, throwing a TimeoutException and ignoring exception",e);
      throw new TimeoutException();
    }
    boolean canFailover=failedOverCount++ < getOwningTask().getTaskFailoverPolicy().maxFailoverAttempts();
    if (canFailover) {
      try {
        response=failoverExecution(e,timeoutNanos,TimeUnit.NANOSECONDS);
      }
 catch (      Exception failedOver) {
        throw wrapIntoExecutionException(failedOver);
      }
    }
 else {
      throw wrapIntoExecutionException(e);
    }
  }
  return response;
}
