{
  final PathAddress address=getCacheContainerAddressFromOperation(operation);
  final String name=address.getLastElement().getValue();
  final ServiceTarget target=context.getServiceTarget();
  ModelNode resolvedValue=null;
  final String defaultCache=(resolvedValue=CacheContainerResource.DEFAULT_CACHE.resolveModelAttribute(context,containerModel)).isDefined() ? resolvedValue.asString() : null;
  final String jndiName=(resolvedValue=CacheContainerResource.JNDI_NAME.resolveModelAttribute(context,containerModel)).isDefined() ? resolvedValue.asString() : null;
  final String listenerExecutor=(resolvedValue=CacheContainerResource.LISTENER_EXECUTOR.resolveModelAttribute(context,containerModel)).isDefined() ? resolvedValue.asString() : null;
  final String asyncExecutor=(resolvedValue=CacheContainerResource.ASYNC_EXECUTOR.resolveModelAttribute(context,containerModel)).isDefined() ? resolvedValue.asString() : null;
  String expirationExecutor=(resolvedValue=CacheContainerResource.EXPIRATION_EXECUTOR.resolveModelAttribute(context,containerModel)).isDefined() ? resolvedValue.asString() : null;
  if (expirationExecutor == null) {
    expirationExecutor=(resolvedValue=CacheContainerResource.EVICTION_EXECUTOR.resolveModelAttribute(context,containerModel)).isDefined() ? resolvedValue.asString() : null;
  }
  final String replicationQueueExecutor=(resolvedValue=CacheContainerResource.REPLICATION_QUEUE_EXECUTOR.resolveModelAttribute(context,containerModel)).isDefined() ? resolvedValue.asString() : null;
  final String stateTransferExecutor=(resolvedValue=CacheContainerResource.STATE_TRANSFER_EXECUTOR.resolveModelAttribute(context,containerModel)).isDefined() ? resolvedValue.asString() : null;
  final ServiceController.Mode initialMode=StartMode.valueOf(CacheContainerResource.START.resolveModelAttribute(context,containerModel).asString()).getMode();
  final boolean statistics=CacheContainerResource.STATISTICS.resolveModelAttribute(context,containerModel).asBoolean();
  ServiceName[] aliases=null;
  if (containerModel.hasDefined(ModelKeys.ALIASES)) {
    List<ModelNode> list=operation.get(ModelKeys.ALIASES).asList();
    aliases=new ServiceName[list.size()];
    for (int i=0; i < list.size(); i++) {
      aliases[i]=EmbeddedCacheManagerService.getServiceName(list.get(i).asString());
    }
  }
  final ModuleIdentifier moduleId=(resolvedValue=CacheContainerResource.CACHE_CONTAINER_MODULE.resolveModelAttribute(context,containerModel)).isDefined() ? ModuleIdentifier.fromString(resolvedValue.asString()) : null;
  final Transport transportConfig=containerModel.hasDefined(ModelKeys.TRANSPORT) && containerModel.get(ModelKeys.TRANSPORT).hasDefined(ModelKeys.TRANSPORT_NAME) ? new Transport() : null;
  String stack=null;
  String transportExecutor=null;
  String totalOrderExecutor=null;
  String remoteCommandExecutor=null;
  Collection<ServiceController<?>> controllers=new LinkedList<ServiceController<?>>();
  if (transportConfig != null) {
    ModelNode transport=containerModel.get(ModelKeys.TRANSPORT,ModelKeys.TRANSPORT_NAME);
    stack=(resolvedValue=TransportResource.STACK.resolveModelAttribute(context,transport)).isDefined() ? resolvedValue.asString() : null;
    final String cluster=(resolvedValue=TransportResource.CLUSTER.resolveModelAttribute(context,transport)).isDefined() ? resolvedValue.asString() : name;
    long lockTimeout=TransportResource.LOCK_TIMEOUT.resolveModelAttribute(context,transport).asLong();
    transportExecutor=(resolvedValue=TransportResource.EXECUTOR.resolveModelAttribute(context,transport)).isDefined() ? resolvedValue.asString() : null;
    totalOrderExecutor=(resolvedValue=TransportResource.TOTAL_ORDER_EXECUTOR.resolveModelAttribute(context,transport)).isDefined() ? resolvedValue.asString() : null;
    remoteCommandExecutor=(resolvedValue=TransportResource.REMOTE_COMMAND_EXECUTOR.resolveModelAttribute(context,transport)).isDefined() ? resolvedValue.asString() : null;
    final boolean strictPeerToPeer=TransportResource.STRICT_PEER_TO_PEER.resolveModelAttribute(context,transport).asBoolean();
    transportConfig.setStrictPeerToPeer(strictPeerToPeer);
    transportConfig.setLockTimeout(lockTimeout);
    controllers.add(this.installChannelService(target,name,cluster,stack));
    for (    ChannelDependentServiceProvider provider : ServiceFinder.load(ChannelDependentServiceProvider.class,ChannelDependentServiceProvider.class.getClassLoader())) {
      controllers.add(provider.install(target,name));
    }
  }
  Authorization authorizationConfig=null;
  if (containerModel.hasDefined(ModelKeys.SECURITY) && containerModel.get(ModelKeys.SECURITY).hasDefined(ModelKeys.SECURITY_NAME)) {
    ModelNode securityModel=containerModel.get(ModelKeys.SECURITY,ModelKeys.SECURITY_NAME);
    if (securityModel.hasDefined(ModelKeys.AUTHORIZATION) && securityModel.get(ModelKeys.AUTHORIZATION).hasDefined(ModelKeys.AUTHORIZATION_NAME)) {
      ModelNode authzModel=securityModel.get(ModelKeys.AUTHORIZATION,ModelKeys.AUTHORIZATION_NAME);
      authorizationConfig=new Authorization();
      authorizationConfig.setPrincipalMapper((resolvedValue=CacheContainerAuthorizationResource.MAPPER.resolveModelAttribute(context,authzModel)).isDefined() ? resolvedValue.asString() : null);
      for (      ModelNode roleNode : authzModel.get(ModelKeys.ROLE).asList()) {
        ModelNode role=roleNode.get(0);
        String roleName=AuthorizationRoleResource.NAME.resolveModelAttribute(context,role).asString();
        List<String> permissions=new ArrayList<String>();
        for (        ModelNode permission : AuthorizationRoleResource.PERMISSIONS.resolveModelAttribute(context,role).asList()) {
          permissions.add(permission.asString());
        }
        authorizationConfig.getRoles().put(roleName,permissions);
      }
    }
  }
  controllers.add(this.installContainerConfigurationService(target,name,defaultCache,statistics,moduleId,stack,transportConfig,authorizationConfig,transportExecutor,totalOrderExecutor,remoteCommandExecutor,listenerExecutor,asyncExecutor,expirationExecutor,replicationQueueExecutor,stateTransferExecutor));
  controllers.add(this.installContainerService(target,name,aliases,transportConfig,initialMode));
  controllers.add(this.installJndiService(target,name,InfinispanJndiName.createCacheContainerJndiName(jndiName,name)));
  controllers.add(this.installKeyAffinityServiceFactoryService(target,name));
  log.debugf("%s cache container installed",name);
  return controllers;
}
