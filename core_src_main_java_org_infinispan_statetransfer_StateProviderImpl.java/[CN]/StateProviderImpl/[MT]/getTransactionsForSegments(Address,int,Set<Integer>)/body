{
  if (trace) {
    log.tracef("Received request for transactions from node %s for segments %s with topology id %d",destination,segments,topologyId);
  }
  if (readCh == null) {
    throw new IllegalStateException("No cache topology received yet");
  }
  if (topologyId != this.topolopyId) {
    log.warnf("Transactions were requested by a node with topology (%d) that does not match local topology (%d).",topologyId,this.topolopyId);
  }
  Set<Integer> ownedSegments=readCh.getSegmentsForOwner(rpcManager.getAddress());
  if (!ownedSegments.containsAll(segments)) {
    segments.removeAll(ownedSegments);
    throw new IllegalArgumentException("Segments " + segments + " are not owned by "+ rpcManager.getAddress());
  }
  List<TransactionInfo> transactions=new ArrayList<TransactionInfo>();
  if (configuration.transaction().transactionMode().isTransactional()) {
    stateTransferLock.transactionsExclusiveLock();
    try {
      collectTransactionsToTransfer(transactions,transactionTable.getRemoteTransactions(),segments);
      collectTransactionsToTransfer(transactions,transactionTable.getLocalTransactions(),segments);
      if (trace) {
        log.tracef("Found %d transaction(s) to transfer",transactions.size());
      }
    }
  finally {
      stateTransferLock.transactionsExclusiveUnlock();
    }
  }
  return transactions;
}
