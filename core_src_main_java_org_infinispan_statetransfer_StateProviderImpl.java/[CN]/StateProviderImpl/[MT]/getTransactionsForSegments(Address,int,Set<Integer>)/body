{
  if (trace) {
    log.tracef("Received request for transactions from node %s for segments %s of cache %s with topology id %d",destination,segments,cacheName,requestTopologyId);
  }
  final CacheTopology cacheTopology=stateConsumer.getCacheTopology();
  if (cacheTopology == null) {
    throw new IllegalStateException("No cache topology received yet");
  }
  final ConsistentHash readCh=cacheTopology.getReadConsistentHash();
  final int topologyId=cacheTopology.getTopologyId();
  if (requestTopologyId < topologyId) {
    log.warnf("Transactions were requested by node %s with topology %d, smaller than the local " + "topology (%d)",destination,requestTopologyId,topologyId);
  }
 else   if (requestTopologyId > topologyId) {
    if (trace) {
      log.tracef("Transactions were requested by node %s with topology %d, greater than the local " + "topology (%d). Waiting for topology %d to be installed locally.",destination,requestTopologyId,topologyId,requestTopologyId);
    }
    stateTransferLock.waitForTopology(requestTopologyId);
  }
  Set<Integer> ownedSegments=readCh.getSegmentsForOwner(rpcManager.getAddress());
  if (!ownedSegments.containsAll(segments)) {
    segments.removeAll(ownedSegments);
    throw new IllegalArgumentException("Segments " + segments + " are not owned by "+ rpcManager.getAddress());
  }
  List<TransactionInfo> transactions=new ArrayList<TransactionInfo>();
  if (configuration.transaction().transactionMode().isTransactional()) {
    collectTransactionsToTransfer(transactions,transactionTable.getRemoteTransactions(),segments,readCh);
    collectTransactionsToTransfer(transactions,transactionTable.getLocalTransactions(),segments,readCh);
    if (trace) {
      log.tracef("Found %d transaction(s) to transfer",transactions.size());
    }
  }
  return transactions;
}
