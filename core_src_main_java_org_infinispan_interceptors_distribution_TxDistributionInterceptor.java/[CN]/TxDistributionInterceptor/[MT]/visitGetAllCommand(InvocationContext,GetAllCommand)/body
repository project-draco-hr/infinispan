{
  Map<Object,Object> map=(Map<Object,Object>)invokeNextInterceptor(ctx,command);
  int commandTopologyId=command.getTopologyId();
  int currentTopologyId=stateTransferManager.getCacheTopology().getTopologyId();
  boolean topologyChanged=currentTopologyId != commandTopologyId && commandTopologyId != -1;
  if (topologyChanged) {
    if (trace) {
      log.tracef("Command topology id is %d, after topology id is %d",commandTopologyId,currentTopologyId);
    }
    Iterator<Entry<Object,Object>> valueIterator=map.entrySet().iterator();
    while (valueIterator.hasNext()) {
      Entry<Object,Object> entry=valueIterator.next();
      if (entry.getValue() == null) {
        valueIterator.remove();
      }
    }
  }
  if (command.hasFlag(Flag.CACHE_MODE_LOCAL) || command.hasFlag(Flag.SKIP_REMOTE_LOOKUP) || command.hasFlag(Flag.IGNORE_RETURN_VALUES)|| !ctx.isOriginLocal()) {
    return map;
  }
  boolean missingRemoteValues=false;
  Set<Object> requestedKeys=new HashSet<>(command.getKeys().size());
  for (  Object key : command.getKeys()) {
    if (!map.containsKey(key)) {
      CacheEntry entry=ctx.lookupEntry(key);
      boolean skipRemoteGet=entry != null && entry.skipLookup();
      if (!skipRemoteGet) {
        boolean shouldFetchFromRemote=false;
        if (entry == null || entry.isNull()) {
          ConsistentHash ch=stateTransferManager.getCacheTopology().getReadConsistentHash();
          shouldFetchFromRemote=!isValueAvailableLocally(ch,key);
          if (!shouldFetchFromRemote && trace) {
            getLog().tracef("Not performing remote lookup of key %s as we own it" + " now, we didn't when we looked - will have to retry command after",key);
          }
        }
        if (shouldFetchFromRemote) {
          requestedKeys.add(key);
        }
 else         if (!ctx.isEntryRemovedInContext(key)) {
          Object localValue=localGet(ctx,key,false,command,command.isReturnEntries());
          if (localValue != null) {
            map.put(key,localValue);
          }
 else {
            missingRemoteValues=true;
          }
        }
      }
    }
  }
  if (!requestedKeys.isEmpty()) {
    if (trace) {
      log.tracef("Fetching entries for keys %s from remote nodes",requestedKeys);
    }
    Map<Object,InternalCacheEntry> justRetrieved=retrieveFromRemoteSources(requestedKeys,ctx,command.getFlags());
    Map<Object,InternalCacheEntry> previouslyRetrieved=command.getRemotelyFetched();
    if (previouslyRetrieved != null) {
      previouslyRetrieved.putAll(justRetrieved);
    }
 else {
      command.setRemotelyFetched(justRetrieved);
    }
    for (    Object key : requestedKeys) {
      if (!justRetrieved.containsKey(key)) {
        missingRemoteValues=true;
      }
 else {
        InternalCacheEntry value=justRetrieved.get(key);
        if (useClusteredWriteSkewCheck && ctx.isInTxScope()) {
          ((TxInvocationContext)ctx).getCacheTransaction().putLookedUpRemoteVersion(key,value.getMetadata().version());
        }
        if (!ctx.replaceValue(key,value)) {
          ctx.putLookedUpEntry(key,value);
          if (ctx.isInTxScope()) {
            ((TxInvocationContext)ctx).getCacheTransaction().replaceVersionRead(key,value.getMetadata().version());
          }
        }
        map.put(key,command.isReturnEntries() ? value : value != null ? value.getValue() : null);
      }
    }
  }
  if (missingRemoteValues) {
    throw new OutdatedTopologyException("Remote values are missing because of a topology change");
  }
  return map;
}
