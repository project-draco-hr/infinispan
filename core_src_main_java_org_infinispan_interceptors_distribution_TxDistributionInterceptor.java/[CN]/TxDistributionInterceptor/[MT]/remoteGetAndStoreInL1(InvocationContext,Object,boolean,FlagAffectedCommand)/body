{
  DataLocality locality=dm.getReadConsistentHash().isKeyLocalToNode(rpcManager.getAddress(),key) ? DataLocality.LOCAL : DataLocality.NOT_LOCAL;
  if (ctx.isOriginLocal() && !locality.isLocal() && isNotInL1(key)) {
    if (trace)     log.tracef("Doing a remote get for key %s",key);
    boolean acquireRemoteLock=false;
    if (ctx.isInTxScope()) {
      TxInvocationContext txContext=(TxInvocationContext)ctx;
      acquireRemoteLock=isWrite && isPessimisticCache && !txContext.getAffectedKeys().contains(key);
    }
    InternalCacheEntry ice=dm.retrieveFromRemoteSource(key,ctx,acquireRemoteLock,command);
    if (acquireRemoteLock) {
      ((TxInvocationContext)ctx).addAffectedKey(key);
    }
    if (ice != null) {
      if (isL1CacheEnabled) {
        List<Address> readOwners=dm.getReadConsistentHash().locateOwners(key);
        List<Address> writeOwners=dm.getWriteConsistentHash().locateOwners(key);
        if (!readOwners.equals(writeOwners)) {
          if (trace)           log.tracef("State transfer in progress for key %s, not storing to L1");
          return ice.getValue();
        }
        if (trace)         log.tracef("Caching remotely retrieved entry for key %s in L1",key);
        try {
          long l1Lifespan=cacheConfiguration.clustering().l1().lifespan();
          long lifespan=ice.getLifespan() < 0 ? l1Lifespan : Math.min(ice.getLifespan(),l1Lifespan);
          PutKeyValueCommand put=cf.buildPutKeyValueCommand(ice.getKey(),ice.getValue(),lifespan,-1,command.getFlags());
          lockAndWrap(ctx,key,ice,command);
          invokeNextInterceptor(ctx,put);
        }
 catch (        Exception e) {
          log.infof("Unable to store entry %s in L1 cache",key);
          log.debug("Inability to store in L1 caused by",e);
        }
      }
 else {
        CacheEntry ce=ctx.lookupEntry(key);
        if (ce == null || ce.isNull() || ce.isLockPlaceholder() || ce.getValue() == null) {
          if (ce != null && ce.isChanged()) {
            ce.setValue(ice.getValue());
          }
 else {
            if (isWrite)             lockAndWrap(ctx,key,ice,command);
 else             ctx.putLookedUpEntry(key,ice);
          }
        }
      }
      return ice.getValue();
    }
  }
 else {
    if (trace)     log.tracef("Not doing a remote get for key %s since entry is mapped to current node (%s), or is in L1.  Owners are %s",key,rpcManager.getAddress(),dm.locate(key));
  }
  return null;
}
