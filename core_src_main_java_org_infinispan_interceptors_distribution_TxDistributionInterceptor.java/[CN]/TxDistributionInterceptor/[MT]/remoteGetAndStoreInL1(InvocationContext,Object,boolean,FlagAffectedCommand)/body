{
  boolean isKeyLocalToNode=dm.getReadConsistentHash().isKeyLocalToNode(rpcManager.getAddress(),key);
  if (ctx.isOriginLocal() && !isKeyLocalToNode && isNotInL1(key) || dm.isAffectedByRehash(key) && !dataContainer.containsKey(key)) {
    if (trace)     log.tracef("Doing a remote get for key %s",key);
    boolean acquireRemoteLock=false;
    if (ctx.isInTxScope()) {
      TxInvocationContext txContext=(TxInvocationContext)ctx;
      acquireRemoteLock=isWrite && isPessimisticCache && !txContext.getAffectedKeys().contains(key);
    }
    InternalCacheEntry ice=retrieveFromRemoteSource(key,ctx,acquireRemoteLock,command);
    if (acquireRemoteLock) {
      ((TxInvocationContext)ctx).addAffectedKey(key);
    }
    if (ice != null) {
      if (useClusteredWriteSkewCheck && ctx.isInTxScope()) {
        ((TxInvocationContext)ctx).getCacheTransaction().putLookedUpRemoteVersion(key,ice.getMetadata().version());
      }
      if (isL1CacheEnabled) {
        if (dm.isAffectedByRehash(key)) {
          if (trace)           log.tracef("State transfer in progress for key %s, not storing to L1");
          return ice.getValue();
        }
        if (trace)         log.tracef("Caching remotely retrieved entry for key %s in L1",key);
        try {
          long l1Lifespan=cacheConfiguration.clustering().l1().lifespan();
          long lifespan=ice.getLifespan() < 0 ? l1Lifespan : Math.min(ice.getLifespan(),l1Lifespan);
          Metadata newMetadata=ice.getMetadata().builder().lifespan(lifespan).maxIdle(-1).build();
          PutKeyValueCommand put=cf.buildPutKeyValueCommand(ice.getKey(),ice.getValue(),newMetadata,command.getFlags());
          lockAndWrap(ctx,key,ice,command);
          invokeNextInterceptor(ctx,put);
        }
 catch (        Exception e) {
          log.infof("Unable to store entry %s in L1 cache",key);
          log.debug("Inability to store in L1 caused by",e);
        }
      }
 else {
        if (!ctx.replaceValue(key,ice)) {
          if (isWrite)           lockAndWrap(ctx,key,ice,command);
 else           ctx.putLookedUpEntry(key,ice);
        }
      }
      return ice.getValue();
    }
  }
 else {
    if (trace)     log.tracef("Not doing a remote get for key %s since entry is mapped to current node (%s), or is in L1.  Owners are %s",key,rpcManager.getAddress(),dm.locate(key));
  }
  return null;
}
