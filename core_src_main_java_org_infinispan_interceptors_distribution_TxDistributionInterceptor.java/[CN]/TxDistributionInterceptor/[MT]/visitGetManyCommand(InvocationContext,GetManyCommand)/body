{
  Map<Object,Object> map=(Map<Object,Object>)invokeNextInterceptor(ctx,command);
  if (map == null)   map=command.createMap();
  if (command.hasFlag(Flag.CACHE_MODE_LOCAL) || command.hasFlag(Flag.SKIP_REMOTE_LOOKUP) || command.hasFlag(Flag.IGNORE_RETURN_VALUES)) {
    return map;
  }
  Set<Object> requestedKeys=new HashSet<>(command.getKeys().size());
  for (  Object key : command.getKeys()) {
    CacheEntry entry=ctx.lookupEntry(key);
    boolean skipRemoteGet=entry != null && entry.skipLookup();
    if (!skipRemoteGet && !map.containsKey(key) && ctx.isOriginLocal()) {
      boolean shouldFetchFromRemote=false;
      if (entry == null || entry.isNull()) {
        ConsistentHash ch=stateTransferManager.getCacheTopology().getReadConsistentHash();
        shouldFetchFromRemote=!isValueAvailableLocally(ch,key);
        if (!shouldFetchFromRemote && getLog().isTraceEnabled()) {
          getLog().tracef("Not doing a remote get for key %s since entry is mapped to current node (%s) or is in L1. Owners are %s",toStr(key),rpcManager.getAddress(),ch.locateOwners(key));
        }
      }
      if (shouldFetchFromRemote) {
        requestedKeys.add(key);
      }
 else       if (!ctx.isEntryRemovedInContext(key)) {
        Object localValue=localGet(ctx,key,false,command,command.isReturnEntries());
        if (localValue != null) {
          map.put(key,localValue);
        }
      }
    }
  }
  if (!requestedKeys.isEmpty()) {
    if (trace) {
      log.tracef("Fetching entries for keys %s from remote nodes",requestedKeys);
    }
    Map<Object,InternalCacheEntry> remotelyRetrieved=retrieveFromRemoteSources(requestedKeys,ctx,command.getFlags());
    command.setRemotelyFetched(remotelyRetrieved);
    for (    InternalCacheEntry entry : remotelyRetrieved.values()) {
      map.put(entry.getKey(),command.isReturnEntries() ? entry : entry.getValue());
    }
  }
  return map;
}
