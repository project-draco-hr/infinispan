{
  final GlobalTransaction globalTransaction=command.getGlobalTransaction();
  final Address origin=globalTransaction.getAddress();
  boolean originatorMissing=!rpcManager.getTransport().getMembers().contains(origin);
  boolean alreadyCompleted=txTable.isTransactionCompleted(globalTransaction) || !txTable.containRemoteTx(globalTransaction);
  boolean completedSuccessfully=alreadyCompleted && !ctx.getCacheTransaction().isMarkedForRollback();
  boolean canRollback=command instanceof PrepareCommand && !((PrepareCommand)command).isOnePhaseCommit() || command instanceof RollbackCommand || command instanceof LockControlCommand;
  if (trace) {
    log.tracef("invokeNextInterceptorAndVerifyTransaction :: originatorMissing=%s, alreadyCompleted=%s",originatorMissing,alreadyCompleted);
  }
  if (alreadyCompleted || (originatorMissing && (canRollback || partitionHandlingManager.canRollbackTransactionAfterOriginatorLeave(globalTransaction)))) {
    if (trace) {
      log.tracef("Rolling back remote transaction %s because either already completed (%s) or originator no longer in the cluster (%s).",globalTransaction,alreadyCompleted,originatorMissing);
    }
    RollbackCommand rollback=commandsFactory.buildRollbackCommand(command.getGlobalTransaction());
    try {
      ctx.forkInvocationSync(rollback);
    }
  finally {
      RemoteTransaction remoteTx=ctx.getCacheTransaction();
      remoteTx.markForRollback(true);
      txTable.removeRemoteTransaction(globalTransaction);
    }
    if (originatorMissing && !completedSuccessfully) {
      throw log.orphanTransactionRolledBack(globalTransaction);
    }
  }
}
