{
  if (!stateTransferManager.startStateTransfer(newViewId,members,initialView))   return;
  if (log.isDebugEnabled())   log.debugf("Commencing state transfer %d on node: %s. Before start, data container had %d entries",newViewId,self,dataContainer.size());
  stateTransferLock.blockNewTransactions(newViewId);
  Set<Address> joiners=chOld != null ? MembershipArithmetic.getMembersJoined(chOld.getCaches(),chNew.getCaches()) : chNew.getCaches();
  if (joiners.isEmpty()) {
    log.tracef("No joiners in view %s, skipping replication",newViewId);
  }
 else {
    log.tracef("Replicating: chOld = %s, chNew = %s",chOld,chNew);
    if (configuration.isStateTransferEnabled() && !initialView) {
      final Collection<InternalCacheEntry> state=new ArrayList<InternalCacheEntry>();
      for (      InternalCacheEntry ice : dataContainer) {
        replicate(ice.getKey(),ice,chOld,chNew,null,state);
      }
      CacheStore cacheStore=stateTransferManager.getCacheStoreForStateTransfer();
      if (cacheStore != null) {
        for (        Object key : cacheStore.loadAllKeys(new ReadOnlyDataContainerBackedKeySet(dataContainer))) {
          replicate(key,null,chOld,chNew,cacheStore,state);
        }
      }
 else {
        if (trace)         log.trace("No cache store or cache store is shared, not replicating stored keys");
      }
      final Map<Address,Collection<InternalCacheEntry>> states=new HashMap<Address,Collection<InternalCacheEntry>>();
      for (      Address joiner : joiners) {
        states.put(joiner,state);
      }
      pushState(states);
    }
 else {
      if (!initialView)       log.trace("State transfer not enabled, so not pushing state");
    }
  }
}
