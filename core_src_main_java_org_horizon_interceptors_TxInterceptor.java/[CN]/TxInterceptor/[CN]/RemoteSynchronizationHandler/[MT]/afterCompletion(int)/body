{
  if (ctx == null) {
    ctx=invocationContextContainer.get();
    setTransactionalContext(tx,gtx,transactionContext,ctx);
    if (ctx.isFlagsUninitialized() && transactionContext != null) {
      ctx.setFlags(transactionContext.getFlags());
    }
  }
  try {
    assertCanContinue();
    try {
      if (txManager.getTransaction() != null && !txManager.getTransaction().equals(tx))       txManager.resume(tx);
    }
 catch (    Exception e) {
      log.error("afterCompletion error: " + status,e);
    }
    if (trace)     log.trace("calling aftercompletion for " + gtx);
    if (transactionContext != null) {
      if (modifications == null)       modifications=transactionContext.getModifications();
      ctx.setFlags(transactionContext.getFlags());
    }
    if (tx != null)     transactions.remove(tx);
switch (status) {
case Status.STATUS_COMMITTED:
      boolean onePhaseCommit=isOnePhaseCommit();
    if (log.isDebugEnabled())     log.debug("Running commit phase.  One phase? " + onePhaseCommit);
  runCommitPhase(ctx,gtx,modifications,onePhaseCommit);
log.debug("Finished commit phase");
break;
case Status.STATUS_UNKNOWN:
log.warn("Received JTA STATUS_UNKNOWN in afterCompletion()!  XA resources may not be in sync.  The app should manually clean up resources at this point.");
case Status.STATUS_MARKED_ROLLBACK:
case Status.STATUS_ROLLEDBACK:
log.debug("Running rollback phase");
runRollbackPhase(ctx,gtx,tx);
log.debug("Finished rollback phase");
break;
default :
throw new IllegalStateException("illegal status: " + status);
}
}
 catch (Exception th) {
log.trace("Caught exception ",th);
}
 finally {
txTable.cleanup(gtx);
setTransactionalContext(null,null,null,ctx);
cleanupInternalState();
}
}
