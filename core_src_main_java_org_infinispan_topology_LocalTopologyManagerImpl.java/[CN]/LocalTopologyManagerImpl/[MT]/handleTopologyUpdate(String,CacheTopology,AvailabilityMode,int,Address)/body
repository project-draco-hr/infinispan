{
  if (!running) {
    log.tracef("Ignoring consistent hash update %s for cache %s, the local cache manager is not running",cacheTopology.getTopologyId(),cacheName);
    return;
  }
  final LocalCacheStatus cacheStatus=runningCaches.get(cacheName);
  if (cacheStatus == null) {
    log.tracef("Ignoring consistent hash update %s for cache %s that doesn't exist locally",cacheTopology.getTopologyId(),cacheName);
    return;
  }
  cacheStatus.getTopologyUpdatesCompletionService().submit(new Runnable(){
    @Override public void run(){
      doHandleTopologyUpdate(cacheName,cacheTopology,availabilityMode,viewId,sender,cacheStatus);
    }
  }
,null);
  List<? extends Future<Void>> futures=cacheStatus.getTopologyUpdatesCompletionService().drainCompletionQueue();
  boolean interrupted=false;
  for (  Future<Void> future : futures) {
    try {
      future.get();
    }
 catch (    InterruptedException e) {
      interrupted=true;
    }
catch (    ExecutionException e) {
      log.topologyUpdateError(cacheTopology.getTopologyId(),e.getCause());
    }
  }
  if (interrupted) {
    Thread.currentThread().interrupt();
  }
}
