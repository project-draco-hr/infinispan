{
  log.debugf("Node %s joining cache %s",transport.getAddress(),cacheName);
  ExecutorService topologyUpdatesExecutor=joinInfo.isTotalOrder() ? withinThreadExecutor : asyncTransportExecutor;
  LocalCacheStatus cacheStatus=new LocalCacheStatus(joinInfo,stm,phm,topologyUpdatesExecutor);
  runningCaches.put(cacheName,cacheStatus);
  long timeout=joinInfo.getTimeout();
  long endTime=timeService.expectedEndTime(timeout,TimeUnit.MILLISECONDS);
  cacheStatus.getTopologyUpdatesCompletionService().continueTaskInBackground();
  try {
    while (true) {
      int viewId=transport.getViewId();
      try {
        ReplicableCommand command=new CacheTopologyControlCommand(cacheName,CacheTopologyControlCommand.Type.JOIN,transport.getAddress(),joinInfo,viewId);
        CacheStatusResponse initialStatus=(CacheStatusResponse)executeOnCoordinator(command,timeout);
        if (initialStatus != null) {
          doHandleTopologyUpdate(cacheName,initialStatus.getCacheTopology(),initialStatus.getAvailabilityMode(),viewId,transport.getCoordinator(),cacheStatus);
          doHandleStableTopologyUpdate(cacheName,initialStatus.getStableTopology(),viewId,transport.getCoordinator(),cacheStatus);
          return initialStatus.getCacheTopology();
        }
      }
 catch (      Exception e) {
        log.debugf(e,"Error sending join request for cache %s to coordinator",cacheName);
        if (timeService.isTimeExpired(endTime)) {
          throw e;
        }
        Thread.sleep(100);
      }
    }
  }
  finally {
    cacheStatus.getTopologyUpdatesCompletionService().backgroundTaskFinished(null);
  }
}
