{
  try {
    waitForView(viewId);
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    return new ManagerStatusResponse(Collections.<String,CacheStatusResponse>emptyMap(),true);
  }
  latestStatusResponseViewId=viewId;
  Map<String,CacheStatusResponse> caches=new HashMap<String,CacheStatusResponse>();
synchronized (runningCaches) {
    for (    Map.Entry<String,LocalCacheStatus> e : runningCaches.entrySet()) {
      String cacheName=e.getKey();
      LocalCacheStatus cacheStatus=runningCaches.get(cacheName);
      caches.put(e.getKey(),new CacheStatusResponse(cacheStatus.getJoinInfo(),cacheStatus.getCurrentTopology(),cacheStatus.getStableTopology(),cacheStatus.getPartitionHandlingManager().getAvailabilityMode()));
    }
  }
  boolean rebalancingEnabled=true;
  ReplicableCommand command=new CacheTopologyControlCommand(null,CacheTopologyControlCommand.Type.POLICY_GET_STATUS,transport.getAddress(),transport.getViewId());
  try {
    gcr.wireDependencies(command);
    rebalancingEnabled=(Boolean)((SuccessfulResponse)command.perform(null)).getResponseValue();
  }
 catch (  Throwable t) {
    log.warn("Failed to obtain the rebalancing status",t);
  }
  log.debugf("Sending cluster status response for view %d",viewId);
  return new ManagerStatusResponse(caches,rebalancingEnabled);
}
