{
  Map<String,CacheStatusResponse> caches=new HashMap<String,CacheStatusResponse>();
synchronized (runningCaches) {
    for (    Map.Entry<String,LocalCacheStatus> e : runningCaches.entrySet()) {
      String cacheName=e.getKey();
      LocalCacheStatus cacheStatus=runningCaches.get(cacheName);
      AvailabilityMode availabilityMode=cacheStatus.getPartitionHandlingManager() != null ? cacheStatus.getPartitionHandlingManager().getAvailabilityMode() : null;
      caches.put(e.getKey(),new CacheStatusResponse(cacheStatus.getJoinInfo(),cacheStatus.getCurrentTopology(),cacheStatus.getStableTopology(),availabilityMode));
    }
  }
  boolean rebalancingEnabled=true;
  ReplicableCommand command=new CacheTopologyControlCommand(null,CacheTopologyControlCommand.Type.POLICY_GET_STATUS,transport.getAddress(),transport.getViewId());
  try {
    gcr.wireDependencies(command);
    rebalancingEnabled=(Boolean)((SuccessfulResponse)command.perform(null)).getResponseValue();
  }
 catch (  Throwable t) {
    log.warn("Failed to obtain the rebalancing status",t);
  }
  return new ManagerStatusResponse(caches,rebalancingEnabled);
}
