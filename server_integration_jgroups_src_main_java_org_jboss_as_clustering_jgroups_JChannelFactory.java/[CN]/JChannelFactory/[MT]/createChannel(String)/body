{
  JChannel channel=new JChannel(this);
  ProtocolStack stack=channel.getProtocolStack();
  TP transport=stack.getTransport();
  if (transport.isSingleton()) {
synchronized (transport) {
      this.init(transport);
    }
  }
 else {
    this.init(transport);
  }
  RelayConfiguration relayConfig=this.configuration.getRelay();
  if (relayConfig != null) {
    String localSite=relayConfig.getSiteName();
    List<RemoteSiteConfiguration> remoteSites=this.configuration.getRelay().getRemoteSites();
    List<String> sites=new ArrayList<>(remoteSites.size() + 1);
    sites.add(localSite);
    Map<String,RelayConfig.BridgeConfig> bridges=new HashMap<>();
    for (    final RemoteSiteConfiguration remoteSite : remoteSites) {
      String siteName=remoteSite.getName();
      sites.add(siteName);
      String clusterName=remoteSite.getClusterName();
      RelayConfig.BridgeConfig bridge=new RelayConfig.BridgeConfig(clusterName){
        @Override public JChannel createChannel() throws Exception {
          JChannel channel=(JChannel)remoteSite.getChannel();
          channel.getProtocolStack().removeProtocol(FORK.class);
          return channel;
        }
      }
;
      bridges.put(clusterName,bridge);
    }
    RELAY2 relay=new RELAY2().site(localSite);
    for (    String site : sites) {
      RelayConfig.SiteConfig siteConfig=new RelayConfig.SiteConfig(site);
      relay.addSite(site,siteConfig);
      if (site.equals(localSite)) {
        for (        RelayConfig.BridgeConfig bridge : bridges.values()) {
          siteConfig.addBridge(bridge);
        }
      }
    }
    Configurator.resolveAndAssignFields(relay,relayConfig.getProperties());
    Configurator.resolveAndInvokePropertyMethods(relay,relayConfig.getProperties());
    stack.addProtocol(relay);
    relay.init();
  }
  FORK fork=new FORK();
  stack.addProtocol(fork);
  fork.init();
  final SaslConfiguration saslConfig=this.configuration.getSasl();
  if (saslConfig != null) {
    final String clusterRole=saslConfig.getClusterRole();
    final SecurityRealm securityRealm=saslConfig.getSecurityRealm();
    final String mech=saslConfig.getMech();
    final SASL sasl=new SASL();
    sasl.setMech(mech);
    Map<String,String> props=saslConfig.getProperties();
    if (props.containsKey("client_password")) {
      String credential=props.get("client_password");
      String name=props.get("client_name");
      if (name == null) {
        sasl.setClientCallbackHandler(new SaslClientCallbackHandler(securityRealm.getName(),this.configuration.getEnvironment().getNodeName(),credential));
      }
 else       if (name.contains("@")) {
        sasl.setClientCallbackHandler(new SaslClientCallbackHandler(name,credential));
      }
 else {
        sasl.setClientCallbackHandler(new SaslClientCallbackHandler(securityRealm.getName(),name,credential));
      }
    }
 else {
      props.put("client_password","");
    }
    Map<String,String> saslProps=props.containsKey("sasl_props") ? Util.parseCommaDelimitedProps(props.get("sasl_props")) : new HashMap<String,String>();
    sasl.setServerCallbackHandler(new RealmAuthorizationCallbackHandler(securityRealm,mech,clusterRole != null ? clusterRole : id,saslProps));
    props.put("sasl_props",new PropertyConverters.StringProperties().toString(saslProps));
    Configurator.resolveAndAssignFields(sasl,props);
    Configurator.resolveAndInvokePropertyMethods(sasl,props);
    stack.insertProtocol(sasl,ProtocolStack.BELOW,GMS.class);
    sasl.init();
  }
  channel.setName(this.configuration.getEnvironment().getNodeName() + "/" + id);
  TransportConfiguration.Topology topology=this.configuration.getTransport().getTopology();
  if (topology != null) {
    channel.setAddressGenerator(new TopologyAddressGenerator(channel,topology.getSite(),topology.getRack(),topology.getMachine()));
  }
  MBeanServer server=this.configuration.getMBeanServer();
  if (server != null) {
    try {
      this.channels.put(channel,id);
      JmxConfigurator.registerChannel(channel,server,id);
    }
 catch (    Exception e) {
      ROOT_LOGGER.warn(e.getMessage(),e);
    }
    channel.addChannelListener(this);
  }
  return channel;
}
