{
  int numSegments=ch.getNumSegments();
  List<Address> nodes=ch.getMembers();
  int numNodes=nodes.size();
  int actualNumOwners=Math.min(ch.getNumOwners(),numNodes);
  OwnershipStatistics stats=new OwnershipStatistics(nodes);
  for (int i=0; i < numSegments; i++) {
    List<Address> owners=ch.locateOwnersForSegment(i);
    if (!allowExtraOwners) {
      assertEquals(owners.size(),actualNumOwners);
    }
 else {
      assertTrue(owners.size() >= actualNumOwners);
    }
    stats.incPrimaryOwned(owners.get(0));
    for (int j=0; j < owners.size(); j++) {
      Address owner=owners.get(j);
      stats.incOwned(owner);
      assertEquals(owners.indexOf(owner),j,"Found the same owner twice in the owners list");
    }
  }
  int minPrimaryOwned=numSegments / numNodes;
  int maxPrimaryOwned=(int)Math.ceil((double)numSegments / numNodes);
  int minOwned=numSegments * actualNumOwners / numNodes;
  int maxOwned=(int)Math.ceil((double)numSegments * actualNumOwners / numNodes);
  for (  Address node : nodes) {
    if (!allowExtraOwners) {
      int primaryOwned=stats.getPrimaryOwned(node);
      assertTrue(minPrimaryOwned <= primaryOwned);
      assertTrue(primaryOwned <= maxPrimaryOwned);
    }
    int owned=stats.getOwned(node);
    assertTrue(minOwned <= owned);
    if (!allowExtraOwners) {
      assertTrue(owned <= maxOwned);
    }
  }
}
