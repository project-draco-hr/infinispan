{
  boolean join=oldMembers.size() < newMembers.size();
  log.viewChangeDetected(oldMembers,newMembers);
  if (join) {
    Address joiner=MembershipArithmetic.getMemberJoined(oldMembers,newMembers);
    log.joinEvent(joiner);
  }
 else {
    Address leaver=MembershipArithmetic.getMemberLeft(oldMembers,newMembers);
    log.leaveEvent(leaver);
    try {
      if (!(consistentHash instanceof UnionConsistentHash)) {
        oldConsistentHash=consistentHash;
      }
 else {
        oldConsistentHash=((UnionConsistentHash)consistentHash).getNewConsistentHash();
      }
      addLeaverAndUpdatedConsistentHash(leaver);
    }
 catch (    Exception e) {
      log.unableToProcessLeaver(e);
      throw new CacheException(e);
    }
    List<Address> stateProviders=holdersOfLeaversState(leaver);
    List<Address> receiversOfLeaverState=receiversOfLeaverState(stateProviders);
    boolean willReceiveLeaverState=receiversOfLeaverState.contains(self);
    boolean willProvideState=stateProviders.contains(self);
    if (willReceiveLeaverState || willProvideState) {
      log.participatingInRehash(rpcManager.getTransport().getAddress(),stateProviders,receiversOfLeaverState);
      transactionLogger.enable();
      if (leaveTaskFuture != null && (!leaveTaskFuture.isCancelled() || !leaveTaskFuture.isDone())) {
        if (trace)         log.trace("Canceling running leave task!");
        leaveTaskFuture.cancel(true);
      }
      InvertedLeaveTask task=new InvertedLeaveTask(this,rpcManager,configuration,cf,dataContainer,stateProviders,receiversOfLeaverState,willReceiveLeaverState);
      leaveTaskFuture=rehashExecutor.submit(task);
    }
 else {
      if (log.isDebugEnabled())       log.debug("Not in same subspace, so ignoring leave event");
      topologyInfo.removeNodeInfo(leaver);
      removeLeaver(leaver);
    }
  }
}
