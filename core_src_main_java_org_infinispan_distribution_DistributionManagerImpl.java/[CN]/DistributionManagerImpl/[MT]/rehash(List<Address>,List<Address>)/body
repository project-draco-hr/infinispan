{
  boolean join=oldMembers.size() < newMembers.size();
  log.info("Detected a view change.  Member list changed from {0} to {1}",oldMembers,newMembers);
  if (join) {
    Address joiner=MembershipArithmetic.getMemberJoined(oldMembers,newMembers);
    log.info("This is a JOIN event!  Wait for notification from new joiner " + joiner);
  }
 else {
    Address leaver=MembershipArithmetic.getMemberLeft(oldMembers,newMembers);
    log.info("This is a LEAVE event!  Node {0} has just left",leaver);
    boolean willReceiveLeaverState=willReceiveLeaverState(leaver);
    boolean willSendLeaverState=willSendLeaverState(leaver);
    List<Address> stateProviders=holdersOfLeaversState(newMembers,leaver);
    try {
      if (!(consistentHash instanceof UnionConsistentHash))       oldConsistentHash=consistentHash;
 else       oldConsistentHash=((UnionConsistentHash)consistentHash).newCH;
      consistentHash=ConsistentHashHelper.removeAddress(consistentHash,leaver,configuration);
    }
 catch (    Exception e) {
      log.fatal("Unable to process leaver!!",e);
      throw new CacheException(e);
    }
    if (willReceiveLeaverState || willSendLeaverState) {
      log.info("I {0} am participating in rehash",rpcManager.getTransport().getAddress());
      transactionLogger.enable();
      if (leaveTaskFuture != null && (!leaveTaskFuture.isCancelled() || !leaveTaskFuture.isDone())) {
        leaveTaskFuture.cancel(true);
      }
      leavers.add(leaver);
      InvertedLeaveTask task=new InvertedLeaveTask(this,rpcManager,configuration,cf,dataContainer,leavers,stateProviders,willReceiveLeaverState);
      leaveTaskFuture=rehashExecutor.submit(task);
    }
 else {
      log.info("Not in same subspace, so ignoring leave event");
    }
  }
}
