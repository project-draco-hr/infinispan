{
  boolean join=oldMembers.size() < newMembers.size();
  log.info("Detected a view change.  Member list changed from %s to %s",oldMembers,newMembers);
  if (join) {
    Address joiner=MembershipArithmetic.getMemberJoined(oldMembers,newMembers);
    log.info("This is a JOIN event!  Wait for notification from new joiner " + joiner);
  }
 else {
    Address leaver=MembershipArithmetic.getMemberLeft(oldMembers,newMembers);
    log.info("This is a LEAVE event!  Node %s has just left",leaver);
    try {
      if (!(consistentHash instanceof UnionConsistentHash)) {
        oldConsistentHash=consistentHash;
      }
 else {
        oldConsistentHash=((UnionConsistentHash)consistentHash).getNewCH();
      }
      addLeaverAndUpdatedConsistentHash(leaver);
    }
 catch (    Exception e) {
      log.fatal("Unable to process leaver!!",e);
      throw new CacheException(e);
    }
    List<Address> stateProviders=holdersOfLeaversState(leaver);
    List<Address> receiversOfLeaverState=receiversOfLeaverState(stateProviders);
    boolean willReceiveLeaverState=receiversOfLeaverState.contains(self);
    boolean willProvideState=stateProviders.contains(self);
    if (willReceiveLeaverState || willProvideState) {
      log.info("I %s am participating in rehash, state providers %s, state receivers %s",rpcManager.getTransport().getAddress(),stateProviders,receiversOfLeaverState);
      transactionLogger.enable();
      if (leaveTaskFuture != null && (!leaveTaskFuture.isCancelled() || !leaveTaskFuture.isDone())) {
        if (log.isTraceEnabled()) {
          log.trace("Canceling running leave task!");
        }
        leaveTaskFuture.cancel(true);
      }
      InvertedLeaveTask task=new InvertedLeaveTask(this,rpcManager,configuration,cf,dataContainer,this,stateProviders,receiversOfLeaverState,willReceiveLeaverState);
      leaveTaskFuture=rehashExecutor.submit(task);
    }
 else {
      log.info("Not in same subspace, so ignoring leave event");
      topologyInfo.removeNodeInfo(leaver);
      removeLeaver(leaver);
    }
  }
}
