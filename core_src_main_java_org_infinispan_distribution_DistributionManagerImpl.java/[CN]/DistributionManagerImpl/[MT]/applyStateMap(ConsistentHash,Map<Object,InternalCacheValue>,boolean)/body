{
  Map<Object,InternalCacheValue> retry=withRetry ? new HashMap<Object,InternalCacheValue>() : null;
  waitForJoinToStart();
  for (  Map.Entry<Object,InternalCacheValue> e : state.entrySet()) {
    if (consistentHash.locate(e.getKey(),configuration.getNumOwners()).contains(getSelf())) {
      InternalCacheValue v=e.getValue();
      InvocationContext ctx=icc.createInvocationContext();
      ctx.setFlags(CACHE_MODE_LOCAL,SKIP_CACHE_LOAD,SKIP_REMOTE_LOOKUP,SKIP_SHARED_CACHE_STORE,SKIP_LOCKING,SKIP_OWNERSHIP_CHECK);
      try {
        PutKeyValueCommand put=cf.buildPutKeyValueCommand(e.getKey(),v.getValue(),v.getLifespan(),v.getMaxIdle(),ctx.getFlags());
        interceptorChain.invoke(ctx,put);
      }
 catch (      Exception ee) {
        if (withRetry) {
          if (trace)           log.tracef("Problem %s encountered when applying state for key %s. Adding entry to retry queue.",ee.getMessage(),e.getKey());
          retry.put(e.getKey(),e.getValue());
        }
 else {
          log.problemApplyingStateForKey(ee.getMessage(),e.getKey());
        }
      }
    }
 else {
      log.warnf("Received a key that doesn't map to this node: %s, mapped to %s",e.getKey(),consistentHash.locate(e.getKey(),configuration.getNumOwners()));
    }
  }
  return retry;
}
