{
  boolean hasNext;
  boolean interrupted=false;
  long targetTime=timeService.expectedEndTime(timeout,unit);
  nextLock.lock();
  try {
    while (!(hasNext=!queue.isEmpty()) && !completed) {
      try {
        if (!nextCondition.await(timeService.remainingTime(targetTime,TimeUnit.NANOSECONDS),TimeUnit.NANOSECONDS)) {
          if (log.isTraceEnabled()) {
            log.tracef("Did not retrieve entries in allotted timeout: %s units: unit",timeout,unit);
          }
          throw new TimeoutException("Did not retrieve entries in allotted timeout: " + timeout + " units: "+ unit);
        }
      }
 catch (      InterruptedException e) {
        interrupted=true;
      }
    }
  }
  finally {
    nextLock.unlock();
  }
  if (interrupted) {
    Thread.currentThread().interrupt();
  }
  return hasNext;
}
