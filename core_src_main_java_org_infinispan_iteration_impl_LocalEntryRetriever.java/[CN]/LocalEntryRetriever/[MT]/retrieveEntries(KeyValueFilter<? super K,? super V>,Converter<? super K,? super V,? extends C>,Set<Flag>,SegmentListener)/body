{
  final boolean filterAndConvert;
  final Converter<? super K,? super V,? extends C> usedConverter;
  if (filter instanceof KeyValueFilterConverter && (filter == converter || converter == null)) {
    filterAndConvert=true;
    usedConverter=null;
    if (trace) {
      log.tracef("User supplied a KeyValueFilterConverter for both filter and converter, so ignoring converter");
    }
  }
 else {
    filterAndConvert=false;
    usedConverter=converter;
  }
  wireFilterAndConverterDependencies(filter,usedConverter);
  if (flags != null && flags.contains(Flag.SKIP_CACHE_LOAD) || !cache.getCacheConfiguration().persistence().usingStores()) {
    if ((flags == null || !flags.contains(Flag.CACHE_MODE_LOCAL)) && partitionListener.currentMode != AvailabilityMode.AVAILABLE) {
      throw log.partitionDegraded();
    }
    final Iterator<InternalCacheEntry<K,V>> iterator=dataContainer.iterator();
    return new DataContainerIterator<>(iterator,filter,usedConverter,filterAndConvert);
  }
  final Itr<C> iterator=new Itr<C>(batchSize);
  registerIterator(iterator,flags);
  final ItrQueuerHandler<C> handler=new ItrQueuerHandler<C>(iterator);
  executorService.submit(new Runnable(){
    @Override public void run(){
      try {
        final Set<K> processedKeys=CollectionFactory.makeSet(keyEquivalence);
        Queue<CacheEntry<K,C>> queue=new ArrayDeque<CacheEntry<K,C>>(batchSize){
          @Override public boolean add(          CacheEntry<K,C> kcEntry){
            processedKeys.add(kcEntry.getKey());
            return super.add(kcEntry);
          }
        }
;
        MapAction<C> action=new MapAction<>(batchSize,usedConverter,queue,handler);
        PassivationListener<K,V> listener=null;
        long currentTime=timeService.wallClockTime();
        try {
          int interruptCheck=0;
          for (          InternalCacheEntry<K,V> entry : dataContainer) {
            if (!entry.isExpired(currentTime)) {
              InternalCacheEntry<K,V> clone=entryFactory.create(unwrapMarshalledvalue(entry.getKey()),unwrapMarshalledvalue(entry.getValue()),entry);
              K key=clone.getKey();
              if (filter != null) {
                if (filterAndConvert) {
                  C converted=((KeyValueFilterConverter<K,V,C>)filter).filterAndConvert(key,clone.getValue(),clone.getMetadata());
                  if (converted != null) {
                    clone.setValue((V)converted);
                  }
 else {
                    continue;
                  }
                }
 else                 if (!filter.accept(key,clone.getValue(),clone.getMetadata())) {
                  continue;
                }
              }
              action.accept(key,clone);
              if (interruptCheck++ % batchSize == 0) {
                if (Thread.interrupted()) {
                  throw new CacheException("Entry Iterator was interrupted!");
                }
              }
            }
          }
          if (shouldUseLoader(flags) && persistenceManager.getStoresAsString().size() > 0) {
            if (passivationEnabled) {
              listener=new PassivationListener<K,V>();
              cache.addListener(listener);
            }
            KeyFilter<K> loaderFilter;
            if (filter == null || filterAndConvert) {
              loaderFilter=new CollectionKeyFilter<K>(processedKeys);
            }
 else {
              loaderFilter=new CompositeKeyFilter<K>(new CollectionKeyFilter<K>(processedKeys),new KeyValueFilterAsKeyFilter<K>(filter));
            }
            if (filterAndConvert) {
              action=new MapAction<>(batchSize,(KeyValueFilterConverter<K,V,C>)filter,queue,handler);
            }
            persistenceManager.processOnAllStores(withinThreadExecutor,loaderFilter,new KeyValueActionForCacheLoaderTask(action),true,true);
          }
        }
  finally {
          if (listener != null) {
            cache.removeListener(listener);
            AdvancedCache<K,V> advancedCache=cache.getAdvancedCache();
            for (            K key : listener.activatedKeys) {
              if (!processedKeys.contains(key)) {
                CacheEntry<K,V> entry=advancedCache.getCacheEntry(key);
                if (entry != null) {
                  CacheEntry<K,V> clone=entry.clone();
                  if (filter != null) {
                    if (filterAndConvert) {
                      C converted=((KeyValueFilterConverter<K,V,C>)filter).filterAndConvert(key,clone.getValue(),clone.getMetadata());
                      if (converted != null) {
                        clone.setValue((V)converted);
                      }
 else {
                        continue;
                      }
                    }
 else                     if (!filter.accept(key,clone.getValue(),clone.getMetadata())) {
                      continue;
                    }
                  }
                  action.accept(clone.getKey(),clone);
                }
              }
            }
          }
        }
        if (trace) {
          log.trace("Completed transfer of entries from cache");
        }
        handler.handleBatch(true,queue);
        partitionListener.iterators.remove(iterator);
      }
 catch (      Throwable t) {
        CacheException e=log.exceptionProcessingEntryRetrievalValues(t);
        iterator.close(e);
      }
    }
  }
);
  return iterator;
}
