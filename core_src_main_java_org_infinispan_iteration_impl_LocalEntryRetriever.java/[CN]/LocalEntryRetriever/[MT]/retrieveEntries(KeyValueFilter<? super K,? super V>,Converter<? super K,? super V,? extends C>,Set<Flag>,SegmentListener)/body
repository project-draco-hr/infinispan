{
  final Converter<? super K,? super V,? extends C> usedConverter=checkForKeyValueFilterConverter(filter,converter);
  wireFilterAndConverterDependencies(filter,usedConverter);
  final Itr<K,C> iterator=new Itr<K,C>(batchSize);
  final ItrQueuerHandler<C> handler=new ItrQueuerHandler<C>(iterator);
  executorService.submit(new Runnable(){
    @Override public void run(){
      try {
        final Set<K> processedKeys=new ConcurrentHashSet<K>();
        Queue<CacheEntry<K,C>> queue=new ArrayDeque<CacheEntry<K,C>>(batchSize){
          @Override public boolean add(          CacheEntry<K,C> kcEntry){
            processedKeys.add(kcEntry.getKey());
            return super.add(kcEntry);
          }
        }
;
        MapAction<C> action=new MapAction(batchSize,usedConverter,queue,handler);
        PassivationListener<K,V> listener=null;
        try {
          int interruptCheck=0;
          for (          InternalCacheEntry<K,V> entry : dataContainer) {
            InternalCacheEntry<K,V> clone=entryFactory.create(unwrapMarshalledvalue(entry.getKey()),unwrapMarshalledvalue(entry.getValue()),entry);
            K key=clone.getKey();
            if (filter != null) {
              if (filter instanceof KeyValueFilterConverter && usedConverter == null) {
                C converted=((KeyValueFilterConverter<K,V,C>)filter).filterAndConvert(key,clone.getValue(),clone.getMetadata());
                if (converted != null) {
                  clone.setValue((V)converted);
                }
 else {
                  continue;
                }
              }
 else               if (!filter.accept(key,clone.getValue(),clone.getMetadata())) {
                continue;
              }
            }
            action.apply(key,clone);
            if (interruptCheck++ % batchSize == 0) {
              if (Thread.interrupted()) {
                throw new CacheException("Entry Iterator was interrupted!");
              }
            }
          }
          if (shouldUseLoader(flags) && persistenceManager.getStoresAsString().size() > 0) {
            if (passivationEnabled) {
              listener=new PassivationListener<K,V>();
              cache.addListener(listener);
            }
            KeyFilter<K> loaderFilter;
            if (filter != null) {
              loaderFilter=new CompositeKeyFilter<K>(new CollectionKeyFilter<K>(processedKeys),new KeyValueFilterAsKeyFilter<K>(filter));
            }
 else {
              loaderFilter=new CollectionKeyFilter<K>(processedKeys);
            }
            persistenceManager.processOnAllStores(withinThreadExecutor,loaderFilter,new KeyValueActionForCacheLoaderTask(action),true,true);
          }
        }
  finally {
          if (listener != null) {
            cache.removeListener(listener);
            AdvancedCache<K,V> advancedCache=cache.getAdvancedCache();
            for (            K key : listener.activatedKeys) {
              if (!processedKeys.contains(key)) {
                CacheEntry entry=advancedCache.getCacheEntry(key);
                if (entry != null) {
                  queue.add(entry);
                }
              }
            }
          }
        }
        if (log.isTraceEnabled()) {
          log.trace("Completed transfer of entries from cache");
        }
        handler.handleBatch(true,queue);
      }
 catch (      Throwable e) {
        log.exceptionProcessingEntryRetrievalValues(e);
      }
    }
  }
);
  return iterator;
}
