{
  if (ctx.isInTxScope()) {
    throw new CacheException("Attempted execution of non-transactional write command in a transactional invocation context");
  }
  RecipientGenerator recipientGenerator=new SingleKeyRecipientGenerator(command.getKey());
  remoteGetBeforeWrite(ctx,command,recipientGenerator);
  if (isLocalModeForced(command)) {
    return invokeNextInterceptor(ctx,command);
  }
  boolean isSync=isSynchronous(command);
  Address primaryOwner=cdl.getPrimaryOwner(command.getKey());
  int commandTopologyId=command.getTopologyId();
  int currentTopologyId=stateTransferManager.getCacheTopology().getTopologyId();
  if (isSync && currentTopologyId != commandTopologyId && commandTopologyId != -1) {
    log.tracef("Cache topology changed while the command was executing: expected %d, got %d",commandTopologyId,currentTopologyId);
    throw new OutdatedTopologyException("Cache topology changed while the command was executing: expected " + commandTopologyId + ", got "+ currentTopologyId);
  }
  if (!ctx.isOriginLocal()) {
    Object returnValue=invokeNextInterceptor(ctx,command);
    if (primaryOwner.equals(rpcManager.getAddress())) {
      if (!command.isSuccessful()) {
        log.tracef("Skipping the replication of the conditional command as it did not succeed on primary owner (%s).",command);
        return returnValue;
      }
      command.setIgnorePreviousValue(true);
      rpcManager.invokeRemotely(recipientGenerator.generateRecipients(),command,rpcManager.getDefaultRpcOptions(isSync));
    }
    return returnValue;
  }
 else {
    if (primaryOwner.equals(rpcManager.getAddress())) {
      Object result=invokeNextInterceptor(ctx,command);
      if (!command.isSuccessful()) {
        log.tracef("Skipping the replication of the command as it did not succeed on primary owner (%s).",command);
        return result;
      }
      List<Address> recipients=recipientGenerator.generateRecipients();
      log.tracef("I'm the primary owner, sending the command to all the backups (%s) in order to be applied.",recipients);
      boolean isSingleOwnerAndLocal=cacheConfiguration.clustering().hash().numOwners() == 1;
      if (!isSingleOwnerAndLocal) {
        command.setIgnorePreviousValue(true);
        rpcManager.invokeRemotely(recipients,command,rpcManager.getDefaultRpcOptions(isSync));
      }
      return result;
    }
 else {
      log.tracef("I'm not the primary owner, so sending the command to the primary owner(%s) in order to be forwarded",primaryOwner);
      Object localResult=invokeNextInterceptor(ctx,command);
      boolean isSyncForwarding=isSync || isNeedReliableReturnValues(command);
      Map<Address,Response> addressResponseMap;
      try {
        addressResponseMap=rpcManager.invokeRemotely(Collections.singletonList(primaryOwner),command,rpcManager.getDefaultRpcOptions(isSyncForwarding));
      }
 catch (      RemoteException e) {
        Throwable ce=e;
        while (ce instanceof RemoteException) {
          ce=ce.getCause();
        }
        if (ce instanceof OutdatedTopologyException) {
          command.setIgnorePreviousValue(true);
        }
        throw e;
      }
      if (!isSyncForwarding)       return localResult;
      return getResponseFromPrimaryOwner(primaryOwner,addressResponseMap);
    }
  }
}
