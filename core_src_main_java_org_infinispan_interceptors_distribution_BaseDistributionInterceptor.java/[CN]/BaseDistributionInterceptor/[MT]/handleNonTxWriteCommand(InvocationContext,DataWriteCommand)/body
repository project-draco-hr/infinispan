{
  if (ctx.isInTxScope()) {
    throw new CacheException("Attempted execution of non-transactional write command in a transactional invocation context");
  }
  RecipientGenerator recipientGenerator=new SingleKeyRecipientGenerator(command.getKey());
  remoteGetBeforeWrite(ctx,command,recipientGenerator);
  if (isLocalModeForced(command)) {
    return invokeNextInterceptor(ctx,command);
  }
  boolean isSync=isSynchronous(command);
  if (!ctx.isOriginLocal()) {
    Object returnValue=invokeNextInterceptor(ctx,command);
    Address primaryOwner=cdl.getPrimaryOwner(command.getKey());
    if (primaryOwner.equals(rpcManager.getAddress())) {
      if (command.isConditional() && !command.isSuccessful()) {
        log.tracef("Skipping the replication of the conditional command as it did not succeed on primary owner (%s).",command);
        return returnValue;
      }
      rpcManager.invokeRemotely(recipientGenerator.generateRecipients(),command,rpcManager.getDefaultRpcOptions(isSync));
    }
    return returnValue;
  }
 else {
    Address primaryOwner=cdl.getPrimaryOwner(command.getKey());
    if (primaryOwner.equals(rpcManager.getAddress())) {
      Object result=invokeNextInterceptor(ctx,command);
      if (command.isConditional() && !command.isSuccessful()) {
        log.tracef("Skipping the replication of the conditional command as it did not succeed on primary owner (%s).",command);
        return result;
      }
      List<Address> recipients=recipientGenerator.generateRecipients();
      log.tracef("I'm the primary owner, sending the command to all (%s) the recipients in order to be applied.",recipients);
      boolean isSingleOwnerAndLocal=cacheConfiguration.clustering().hash().numOwners() == 1 && recipients != null && recipients.size() == 1 && recipients.get(0).equals(rpcManager.getTransport().getAddress());
      if (!isSingleOwnerAndLocal) {
        rpcManager.invokeRemotely(recipients,command,rpcManager.getDefaultRpcOptions(isSync));
      }
      return result;
    }
 else {
      log.tracef("I'm not the primary owner, so sending the command to the primary owner(%s) in order to be forwarded",primaryOwner);
      Object localResult=invokeNextInterceptor(ctx,command);
      boolean isSyncForwarding=isSync || isNeedReliableReturnValues(command);
      Map<Address,Response> addressResponseMap=rpcManager.invokeRemotely(Collections.singletonList(primaryOwner),command,rpcManager.getDefaultRpcOptions(isSyncForwarding));
      if (!isSyncForwarding)       return localResult;
      return getResponseFromPrimaryOwner(primaryOwner,addressResponseMap);
    }
  }
}
