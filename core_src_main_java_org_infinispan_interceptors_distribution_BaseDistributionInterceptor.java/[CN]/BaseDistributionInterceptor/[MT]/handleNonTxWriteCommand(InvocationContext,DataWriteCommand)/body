{
  if (ctx.isInTxScope()) {
    throw new CacheException("Attempted execution of non-transactional write command in a transactional invocation context");
  }
  RecipientGenerator recipientGenerator=new SingleKeyRecipientGenerator(command.getKey());
  if (needValuesFromPreviousOwners(ctx,command)) {
    remoteGetBeforeWrite(ctx,command,recipientGenerator);
  }
  Object localResult=invokeNextInterceptor(ctx,command);
  if (isLocalModeForced(command)) {
    return localResult;
  }
  boolean isSync=isSynchronous(command);
  Address primaryOwner=cdl.getPrimaryOwner(command.getKey());
  int commandTopologyId=command.getTopologyId();
  int currentTopologyId=stateTransferManager.getCacheTopology().getTopologyId();
  boolean topologyChanged=isSync && currentTopologyId != commandTopologyId && commandTopologyId != -1;
  log.tracef("Command topology id is %d, current topology id is %d, successful? %s",commandTopologyId,currentTopologyId,command.isSuccessful());
  if (topologyChanged) {
    throw new OutdatedTopologyException("Cache topology changed while the command was executing: expected " + commandTopologyId + ", got "+ currentTopologyId);
  }
  ValueMatcher valueMatcher=command.getValueMatcher();
  if (!ctx.isOriginLocal()) {
    if (primaryOwner.equals(rpcManager.getAddress())) {
      if (!command.isSuccessful()) {
        log.tracef("Skipping the replication of the conditional command as it did not succeed on primary owner (%s).",command);
        return localResult;
      }
      List<Address> recipients=recipientGenerator.generateRecipients();
      command.setValueMatcher(ValueMatcher.MATCH_ALWAYS);
      try {
        rpcManager.invokeRemotely(recipients,command,determineRpcOptionsForBackupReplication(rpcManager,isSync,recipients));
      }
  finally {
        command.setValueMatcher(valueMatcher.matcherForRetry());
      }
    }
    return localResult;
  }
 else {
    if (primaryOwner.equals(rpcManager.getAddress())) {
      if (!command.isSuccessful()) {
        log.tracef("Skipping the replication of the command as it did not succeed on primary owner (%s).",command);
        return localResult;
      }
      List<Address> recipients=recipientGenerator.generateRecipients();
      log.tracef("I'm the primary owner, sending the command to all the backups (%s) in order to be applied.",recipients);
      boolean isSingleOwnerAndLocal=cacheConfiguration.clustering().hash().numOwners() == 1;
      if (!isSingleOwnerAndLocal) {
        command.setValueMatcher(ValueMatcher.MATCH_ALWAYS);
        try {
          rpcManager.invokeRemotely(recipients,command,determineRpcOptionsForBackupReplication(rpcManager,isSync,recipients));
        }
  finally {
          command.setValueMatcher(valueMatcher.matcherForRetry());
        }
      }
      return localResult;
    }
 else {
      log.tracef("I'm not the primary owner, so sending the command to the primary owner(%s) in order to be forwarded",primaryOwner);
      boolean isSyncForwarding=isSync || isNeedReliableReturnValues(command);
      Map<Address,Response> addressResponseMap;
      try {
        addressResponseMap=rpcManager.invokeRemotely(Collections.singletonList(primaryOwner),command,rpcManager.getDefaultRpcOptions(isSyncForwarding));
      }
 catch (      RemoteException e) {
        Throwable ce=e;
        while (ce instanceof RemoteException) {
          ce=ce.getCause();
        }
        if (ce instanceof OutdatedTopologyException) {
          if (trace)           log.tracef("Changing the value matching policy from %s to %s (original value was %s)",command.getValueMatcher(),valueMatcher.matcherForRetry(),valueMatcher);
          command.setValueMatcher(valueMatcher.matcherForRetry());
        }
        throw e;
      }
catch (      SuspectException e) {
        if (trace)         log.tracef("Primary owner suspected - Changing the value matching policy from %s to %s " + "(original value was %s)",command.getValueMatcher(),valueMatcher.matcherForRetry(),valueMatcher);
        command.setValueMatcher(valueMatcher.matcherForRetry());
        throw e;
      }
      if (!isSyncForwarding)       return localResult;
      Object primaryResult=getResponseFromPrimaryOwner(primaryOwner,addressResponseMap);
      command.updateStatusFromRemoteResponse(primaryResult);
      return primaryResult;
    }
  }
}
