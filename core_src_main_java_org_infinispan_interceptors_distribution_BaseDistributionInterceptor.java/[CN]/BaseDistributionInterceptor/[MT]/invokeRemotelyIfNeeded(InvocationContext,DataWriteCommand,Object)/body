{
  boolean isSync=isSynchronous(command);
  Address primaryOwner=cdl.getPrimaryOwner(command.getKey());
  int commandTopologyId=command.getTopologyId();
  int currentTopologyId=stateTransferManager.getCacheTopology().getTopologyId();
  boolean topologyChanged=isSync && currentTopologyId != commandTopologyId && commandTopologyId != -1;
  if (trace) {
    log.tracef("Command topology id is %d, current topology id is %d, successful? %s",(Object)commandTopologyId,currentTopologyId,command.isSuccessful());
  }
  if (topologyChanged) {
    throw new OutdatedTopologyException("Cache topology changed while the command was executing: expected " + commandTopologyId + ", got "+ currentTopologyId);
  }
  ValueMatcher valueMatcher=command.getValueMatcher();
  if (!ctx.isOriginLocal()) {
    if (primaryOwner.equals(rpcManager.getAddress())) {
      if (!command.isSuccessful()) {
        if (trace)         log.tracef("Skipping the replication of the conditional command as it did not succeed on primary owner (%s).",command);
        return CompletableFuture.completedFuture(localResult);
      }
      List<Address> recipients=cdl.getOwners(command.getKey());
      command.setValueMatcher(ValueMatcher.MATCH_ALWAYS);
      try {
        rpcManager.invokeRemotely(recipients,command,determineRpcOptionsForBackupReplication(rpcManager,isSync,recipients));
      }
  finally {
        command.setValueMatcher(valueMatcher.matcherForRetry());
      }
    }
    return CompletableFuture.completedFuture(localResult);
  }
 else {
    if (primaryOwner.equals(rpcManager.getAddress())) {
      if (!command.isSuccessful()) {
        if (trace)         log.tracef("Skipping the replication of the command as it did not succeed on primary owner (%s).",command);
        return CompletableFuture.completedFuture(localResult);
      }
      List<Address> recipients=cdl.getOwners(command.getKey());
      if (trace)       log.tracef("I'm the primary owner, sending the command to all the backups (%s) in order to be applied.",recipients);
      boolean isSingleOwnerAndLocal=cacheConfiguration.clustering().hash().numOwners() == 1;
      if (!isSingleOwnerAndLocal) {
        command.setValueMatcher(ValueMatcher.MATCH_ALWAYS);
        try {
          rpcManager.invokeRemotely(recipients,command,determineRpcOptionsForBackupReplication(rpcManager,isSync,recipients));
        }
  finally {
          command.setValueMatcher(valueMatcher.matcherForRetry());
        }
      }
      return CompletableFuture.completedFuture(localResult);
    }
 else {
      if (trace)       log.tracef("I'm not the primary owner, so sending the command to the primary owner(%s) in order to be forwarded",primaryOwner);
      boolean isSyncForwarding=isSync || command.isReturnValueExpected();
      Map<Address,Response> addressResponseMap;
      try {
        addressResponseMap=rpcManager.invokeRemotely(Collections.singletonList(primaryOwner),command,rpcManager.getDefaultRpcOptions(isSyncForwarding));
      }
 catch (      RemoteException e) {
        Throwable ce=e;
        while (ce instanceof RemoteException) {
          ce=ce.getCause();
        }
        if (ce instanceof OutdatedTopologyException) {
          if (trace)           log.tracef("Changing the value matching policy from %s to %s (original value was %s)",command.getValueMatcher(),valueMatcher.matcherForRetry(),valueMatcher);
          command.setValueMatcher(valueMatcher.matcherForRetry());
        }
        throw e;
      }
catch (      SuspectException e) {
        if (trace)         log.tracef("Primary owner suspected - Changing the value matching policy from %s to %s " + "(original value was %s)",command.getValueMatcher(),valueMatcher.matcherForRetry(),valueMatcher);
        command.setValueMatcher(valueMatcher.matcherForRetry());
        throw e;
      }
      if (!isSyncForwarding)       return CompletableFuture.completedFuture(localResult);
      Object primaryResult=getResponseFromPrimaryOwner(primaryOwner,addressResponseMap);
      command.updateStatusFromRemoteResponse(primaryResult);
      return CompletableFuture.completedFuture(primaryResult);
    }
  }
}
