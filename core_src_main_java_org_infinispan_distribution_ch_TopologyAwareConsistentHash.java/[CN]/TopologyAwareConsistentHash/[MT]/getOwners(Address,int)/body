{
  Address realAddress=getRealAddress(address);
  int ownerHash=getNormalizedHash(getGrouping(address));
  Collection<Address> beforeOnWheel=positions.headMap(ownerHash).values();
  Collection<Address> afterOnWheel=positions.tailMap(ownerHash).values();
  ArrayList<Address> processSequence=new ArrayList<Address>(afterOnWheel);
  processSequence.addAll(beforeOnWheel);
  List<Address> result=new ArrayList<Address>();
  result.add(getRealAddress(processSequence.remove(0)));
  int level=0;
  int numNodesToReturn=Math.min(numOwners,caches.size());
  while (result.size() < numNodesToReturn && level <= 3) {
    Iterator<Address> addrIt=processSequence.iterator();
    while (addrIt.hasNext()) {
      Address a=addrIt.next();
      Address ra=getRealAddress(a);
switch (level) {
case 0:
{
          if (!isSameSite(realAddress,ra)) {
            if (trace)             log.tracef("Owner (different site) identified as %s",a);
            result.add(ra);
            addrIt.remove();
          }
          break;
        }
case 1:
{
        if (!isSameRack(realAddress,ra)) {
          if (trace)           log.tracef("Owner (different rack) identified as %s",a);
          result.add(ra);
          addrIt.remove();
        }
        break;
      }
case 2:
{
      if (!isSameMachine(realAddress,ra)) {
        if (trace)         log.tracef("Owner (different machine) identified as %s",a);
        result.add(ra);
        addrIt.remove();
      }
      break;
    }
case 3:
{
    if (trace)     log.tracef("Owner (same machine) identified as %s",a);
    result.add(ra);
    addrIt.remove();
    break;
  }
}
if (result.size() == numOwners) break;
}
level++;
}
if (result.size() != numNodesToReturn) throw new AssertionError("This should not happen!");
return result;
}
