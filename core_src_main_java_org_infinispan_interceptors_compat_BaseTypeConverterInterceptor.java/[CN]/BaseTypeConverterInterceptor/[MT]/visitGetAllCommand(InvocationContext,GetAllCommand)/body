{
  Collection<?> keys=command.getKeys();
  TypeConverter<Object,Object,Object,Object> converter=determineTypeConverter(command.getFlags());
  if (ctx.isOriginLocal()) {
    Set<Object> boxedKeys=new LinkedHashSet<>(keys.size());
    for (    Object key : keys) {
      boxedKeys.add(converter.boxKey(key));
    }
    command.setKeys(boxedKeys);
  }
  Object ret=ctx.forkInvocationSync(command);
  if (ret != null && !needsUnboxing(ctx))   return ctx.shortCircuit(ret);
  if (ret != null) {
    if (command.isReturnEntries()) {
      Map<Object,CacheEntry> map=(Map<Object,CacheEntry>)ret;
      Map<Object,Object> unboxed=command.createMap();
      for (      Entry<Object,CacheEntry> entry : map.entrySet()) {
        CacheEntry cacheEntry=entry.getValue();
        if (cacheEntry == null) {
          unboxed.put(entry.getKey(),null);
        }
 else {
          if (command.getRemotelyFetched() == null || !command.getRemotelyFetched().containsKey(entry.getKey())) {
            unboxed.put(converter.unboxKey(entry.getKey()),entryFactory.create(entry.getKey(),converter.unboxValue(cacheEntry.getValue()),cacheEntry.getMetadata(),cacheEntry.getLifespan(),cacheEntry.getMaxIdle()));
          }
 else {
            unboxed.put(converter.unboxKey(entry.getKey()),cacheEntry);
          }
        }
      }
      return ctx.shortCircuit(unboxed);
    }
 else {
      Map<Object,Object> map=(Map<Object,Object>)ret;
      Map<Object,Object> unboxed=command.createMap();
      for (      Entry<Object,Object> entry : map.entrySet()) {
        Object value=entry == null ? null : entry.getValue();
        unboxed.put(converter.unboxKey(entry.getKey()),entry == null ? null : converter.unboxValue(value));
      }
      return ctx.shortCircuit(unboxed);
    }
  }
  return ctx.shortCircuit(null);
}
