{
  List<ExpiryEntry> entries=new ArrayList<ExpiryEntry>();
  expiryEntryQueue.drainTo(entries);
  for (  ExpiryEntry entry : entries) {
    Object existing=expiryTree.insert(entry.expiry,entry.key,false);
    if (existing != null) {
      if (existing instanceof List) {
        ((List)existing).add(entry.key);
        expiryTree.insert(entry.expiry,existing,true);
      }
 else {
        List<Object> al=new ArrayList<Object>(2);
        al.add(existing);
        al.add(entry.key);
        expiryTree.insert(entry.expiry,al,true);
      }
    }
  }
  TupleBrowser browse=expiryTree.browse();
  Tuple tuple=new Tuple();
  List<Long> times=new ArrayList<Long>();
  List<Object> keys=new ArrayList<Object>();
  while (browse.getNext(tuple)) {
    Long time=(Long)tuple.getKey();
    if (time > System.currentTimeMillis())     break;
    times.add(time);
    Object key=tuple.getValue();
    if (key instanceof List)     keys.addAll((List)key);
 else     keys.add(key);
  }
  for (  Long time : times) {
    expiryTree.remove(time);
  }
  if (!keys.isEmpty())   log.debugf("purge (up to) %d entries",keys.size());
  int count=0;
  long currentTimeMillis=System.currentTimeMillis();
  for (  Object key : keys) {
    byte[] b=(byte[])tree.get(key);
    if (b == null)     continue;
    InternalCacheValue ice=(InternalCacheValue)getMarshaller().objectFromByteBuffer(b);
    if (ice.isExpired(currentTimeMillis)) {
      tree.remove(key);
      count++;
    }
  }
  if (count != 0)   log.debugf("purged %d entries",count);
  recman.commit();
}
