{
  int maxTopologyId=0;
  CacheTopology maxStableTopology=null;
  CacheTopology maxActiveTopology=null;
  Set<CacheTopology> unavailableTopologies=new HashSet<>();
  Set<CacheTopology> degradedTopologies=new HashSet<>();
  for (  CacheStatusResponse response : statusResponses) {
    CacheTopology partitionStableTopology=response.getStableTopology();
    if (partitionStableTopology == null) {
      continue;
    }
    if (maxStableTopology == null || maxStableTopology.getTopologyId() < partitionStableTopology.getTopologyId()) {
      maxStableTopology=partitionStableTopology;
    }
    CacheTopology partitionTopology=response.getCacheTopology();
    if (partitionTopology == null) {
      continue;
    }
    if (partitionTopology.getTopologyId() > maxTopologyId) {
      maxTopologyId=partitionTopology.getTopologyId();
    }
    if (response.getAvailabilityMode() == AvailabilityMode.AVAILABLE) {
      if (maxActiveTopology == null || maxActiveTopology.getTopologyId() < partitionTopology.getTopologyId()) {
        maxActiveTopology=partitionTopology;
      }
    }
 else     if (response.getAvailabilityMode() == AvailabilityMode.DEGRADED_MODE) {
      degradedTopologies.add(partitionTopology);
    }
 else     if (response.getAvailabilityMode() == AvailabilityMode.UNAVAILABLE) {
      unavailableTopologies.add(partitionTopology);
    }
 else {
      log.unexpectedAvailabilityMode(context.getAvailabilityMode(),context.getCacheName(),response.getCacheTopology());
    }
  }
  if (maxStableTopology != null) {
    log.tracef("Max stable partition topology: %s",maxStableTopology);
  }
  if (maxActiveTopology != null) {
    log.tracef("Max active partition topology: %s",maxActiveTopology);
  }
  if (!degradedTopologies.isEmpty()) {
    log.tracef("Found degraded partition topologies: %s",degradedTopologies);
  }
  if (!unavailableTopologies.isEmpty()) {
    log.tracef("Found unavailable partition topologies: %s",unavailableTopologies);
  }
  CacheTopology mergedTopology;
  AvailabilityMode mergedAvailabilityMode;
  if (!unavailableTopologies.isEmpty()) {
    log.debugf("At least one of the partitions is unavailable, staying in unavailable mode");
    mergedAvailabilityMode=AvailabilityMode.UNAVAILABLE;
    mergedTopology=unavailableTopologies.iterator().next();
  }
 else   if (maxActiveTopology != null) {
    log.debugf("One of the partitions is available, using that partition's topology");
    List<Address> newMembers=new ArrayList<>(maxActiveTopology.getMembers());
    newMembers.retainAll(context.getExpectedMembers());
    mergedAvailabilityMode=computeAvailabilityAfterMerge(context,maxStableTopology,newMembers);
    mergedTopology=maxActiveTopology;
  }
 else   if (!degradedTopologies.isEmpty()) {
    log.debugf("No active or unavailable partitions, so all the partitions must be in degraded mode.");
    List<Address> newMembers=new ArrayList<>(maxStableTopology.getMembers());
    newMembers.retainAll(context.getExpectedMembers());
    mergedAvailabilityMode=computeAvailabilityAfterMerge(context,maxStableTopology,newMembers);
    mergedTopology=maxStableTopology;
  }
 else {
    log.debugf("No current topology, recovered only joiners for cache %s",context.getCacheName());
    mergedAvailabilityMode=AvailabilityMode.AVAILABLE;
    mergedTopology=null;
  }
  if (mergedTopology != null) {
    mergedTopology=new CacheTopology(maxTopologyId + 1,mergedTopology.getRebalanceId(),mergedTopology.getCurrentCH(),null);
  }
  context.updateTopologiesAfterMerge(mergedTopology,maxStableTopology,mergedAvailabilityMode);
  if (mergedAvailabilityMode == AvailabilityMode.UNAVAILABLE) {
    log.debugf("After merge, cache %s is staying in unavailable mode",context.getCacheName());
    context.updateAvailabilityMode(AvailabilityMode.UNAVAILABLE,true);
    return;
  }
 else   if (mergedAvailabilityMode == AvailabilityMode.AVAILABLE) {
    log.debugf("After merge, cache %s has recovered and is entering available mode");
    updateMembersAndRebalance(context,context.getExpectedMembers());
  }
}
