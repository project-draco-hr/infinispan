{
  if (t.isSupportStateTransfer()) {
    long initialWaitTime=configuration.getStateRetrievalInitialRetryWaitTime();
    int waitTimeIncreaseFactor=configuration.getStateRetrievalRetryWaitTimeIncreaseFactor();
    int numRetries=configuration.getStateRetrievalNumRetries();
    List<Address> members=t.getMembers();
    if (members.size() < 2) {
      if (log.isDebugEnabled())       log.debug("We're the only member in the cluster; no one to retrieve state from. Not doing anything!");
      return;
    }
    boolean success=false;
    try {
      long wait=initialWaitTime;
      outer:       for (int i=0; i < numRetries; i++) {
        for (        Address member : members) {
          if (!member.equals(t.getAddress())) {
            try {
              if (log.isInfoEnabled())               log.tryingToFetchState(member);
              currentStateTransferSource=member;
              if (t.retrieveState(cacheName,member,timeout)) {
                if (log.isInfoEnabled())                 log.successfullyAppliedState(member);
                success=true;
                break outer;
              }
            }
 catch (            StateTransferException e) {
              if (log.isDebugEnabled())               log.debug("Error while fetching state from member " + member,e);
            }
 finally {
              currentStateTransferSource=null;
            }
          }
        }
        if (!success) {
          log.couldNotFindPeerForState();
          try {
            Thread.sleep(wait*=waitTimeIncreaseFactor);
          }
 catch (          InterruptedException e) {
            Thread.currentThread().interrupt();
          }
        }
      }
    }
  finally {
      currentStateTransferSource=null;
    }
    if (!success)     throw new StateTransferException("Unable to fetch state on startup");
  }
 else {
    throw new StateTransferException("Transport does not, or is not configured to, support state transfer.  Please disable fetching state on startup, or reconfigure your transport.");
  }
}
