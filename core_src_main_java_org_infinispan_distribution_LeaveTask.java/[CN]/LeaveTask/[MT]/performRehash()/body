{
  long start=System.currentTimeMillis();
  if (log.isDebugEnabled())   log.debug("Commencing.  Leavers' list is {0}",leavers);
  boolean completedSuccessfully=false;
  List<Address> leaversHandled=new LinkedList<Address>(leavers);
  ConsistentHash oldCH=ConsistentHashHelper.createConsistentHash(configuration,dmi.getConsistentHash().getCaches(),leaversHandled);
  int replCount=configuration.getNumOwners();
  try {
    InMemoryStateMap statemap=new InMemoryStateMap(leaversHandled,self,oldCH,dmi.getConsistentHash(),replCount);
    if (log.isTraceEnabled())     log.trace("Examining state in data container");
    for (    InternalCacheEntry ice : dataContainer) {
      List<Address> oldOwners=oldCH.locate(ice.getKey(),replCount);
      for (      Address a : oldOwners)       if (leaversHandled.contains(a))       statemap.addState(ice);
    }
    CacheStore cs=dmi.getCacheStoreForRehashing();
    if (cs != null) {
      if (log.isTraceEnabled())       log.trace("Examining state in cache store");
      for (      InternalCacheEntry ice : cs.loadAll())       if (!statemap.containsKey(ice.getKey()))       statemap.addState(ice);
    }
    Set<Future<Object>> pushFutures=new HashSet<Future<Object>>();
    for (    Map.Entry<Address,Map<Object,InternalCacheValue>> entry : statemap.getState().entrySet()) {
      if (log.isDebugEnabled())       log.debug("Pushing {0} entries to {1}",entry.getValue().size(),entry.getKey());
      RehashControlCommand push=cf.buildRehashControlCommand(self,entry.getValue());
      NotifyingNotifiableFuture<Object> f=new NotifyingFutureImpl(null);
      pushFutures.add(f);
      rpcManager.invokeRemotelyInFuture(Collections.singleton(entry.getKey()),push,true,f,configuration.getRehashRpcTimeout());
    }
    for (    Future f : pushFutures)     f.get();
    processAndDrainTxLog(oldCH,dmi.getConsistentHash(),replCount);
    completedSuccessfully=true;
    invalidateInvalidHolders(oldCH,dmi.getConsistentHash());
    if (log.isInfoEnabled())     log.info("Completed in {0}!",Util.prettyPrintTime(System.currentTimeMillis() - start));
  }
 catch (  InterruptedException ie) {
    if (log.isInfoEnabled())     log.info("Interrupted after {0}!  Completed successfully? {1}",Util.prettyPrintTime(System.currentTimeMillis() - start),completedSuccessfully);
  }
catch (  Exception e) {
    log.error("Caught exception! Completed successfully? {0}",e,completedSuccessfully);
  }
 finally {
    if (completedSuccessfully)     leavers.removeAll(leaversHandled);
  }
}
