{
  if (newMembers.equals(baseCH.getMembers()))   return baseCH;
  int numSegments=baseCH.getNumSegments();
  int[] primaryOwners=new int[numSegments];
  int[] nodeUsage=new int[newMembers.size()];
  boolean foundOrphanSegments=false;
  for (int segmentId=0; segmentId < numSegments; segmentId++) {
    Address primaryOwner=baseCH.locatePrimaryOwnerForSegment(segmentId);
    int primaryOwnerIndex=newMembers.indexOf(primaryOwner);
    primaryOwners[segmentId]=primaryOwnerIndex;
    if (primaryOwnerIndex == -1) {
      foundOrphanSegments=true;
    }
 else {
      nodeUsage[primaryOwnerIndex]++;
    }
  }
  if (foundOrphanSegments) {
    for (int i=0; i < numSegments; i++) {
      if (primaryOwners[i] == -1) {
        int leastUsed=findLeastUsedNode(nodeUsage);
        primaryOwners[i]=leastUsed;
        nodeUsage[leastUsed]++;
      }
    }
  }
  int minSegmentsPerPrimaryOwner=numSegments / newMembers.size();
  for (int node=0; node < nodeUsage.length; node++) {
    if (nodeUsage[node] < minSegmentsPerPrimaryOwner) {
      int mostUsed=findMostUsedNode(nodeUsage);
      if (Math.abs(nodeUsage[node] - nodeUsage[mostUsed]) > 1) {
        transferOwnership(mostUsed,node,primaryOwners,nodeUsage);
      }
    }
  }
  return new ReplicatedConsistentHash(baseCH.getHashFunction(),newMembers,primaryOwners);
}
