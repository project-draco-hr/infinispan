{
  RpcManager rpc=cache.getRpcManager();
  MapCombineCommand<KIn,VIn,KOut,VOut> cmd=null;
  Set<KOut> mapPhasesResult=new HashSet<KOut>();
  List<MapTaskPart<Set<KOut>>> futures=new ArrayList<MapTaskPart<Set<KOut>>>();
  if (inputTaskKeysEmpty()) {
    for (    Address target : rpc.getTransport().getMembers()) {
      if (target.equals(rpc.getAddress())) {
        cmd=buildMapCombineCommand(taskId.toString(),clone(mapper),clone(combiner),null,true,useCompositeKeys);
      }
 else {
        cmd=buildMapCombineCommand(taskId.toString(),mapper,combiner,null,true,useCompositeKeys);
      }
      MapTaskPart<Set<KOut>> part=createTaskMapPart(cmd,target,true);
      part.execute();
      futures.add(part);
    }
  }
 else {
    Map<Address,List<KIn>> keysToNodes=mapKeysToNodes(keys);
    for (    Entry<Address,List<KIn>> e : keysToNodes.entrySet()) {
      Address address=e.getKey();
      List<KIn> keys=e.getValue();
      if (address.equals(rpc.getAddress())) {
        cmd=buildMapCombineCommand(taskId.toString(),clone(mapper),clone(combiner),keys,true,useCompositeKeys);
      }
 else {
        cmd=buildMapCombineCommand(taskId.toString(),mapper,combiner,keys,true,useCompositeKeys);
      }
      MapTaskPart<Set<KOut>> part=createTaskMapPart(cmd,address,true);
      part.execute();
      futures.add(part);
    }
  }
  for (  MapTaskPart<Set<KOut>> mapTaskPart : futures) {
    mapPhasesResult.addAll(mapTaskPart.get());
  }
  return mapPhasesResult;
}
