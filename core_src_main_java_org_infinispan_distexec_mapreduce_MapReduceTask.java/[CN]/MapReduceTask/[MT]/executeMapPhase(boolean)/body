{
  RpcManager rpc=cache.getRpcManager();
  MapCombineCommand<KIn,VIn,KOut,VOut> cmd=null;
  Set<KOut> mapPhasesResult=new HashSet<KOut>();
  List<MapTaskPart<Set<KOut>>> futures=new ArrayList<MapTaskPart<Set<KOut>>>();
  if (inputTaskKeysEmpty()) {
    for (    Address target : rpc.getMembers()) {
      if (target.equals(rpc.getAddress())) {
        cmd=buildMapCombineCommand(taskId.toString(),clone(mapper),clone(combiner),null,true,useCompositeKeys);
      }
 else {
        cmd=buildMapCombineCommand(taskId.toString(),mapper,combiner,null,true,useCompositeKeys);
      }
      MapTaskPart<Set<KOut>> part=createTaskMapPart(cmd,target,true);
      part.execute();
      futures.add(part);
    }
  }
 else {
    Map<Address,? extends Collection<KIn>> keysToNodes=mapKeysToNodes(keys);
    for (    Entry<Address,? extends Collection<KIn>> e : keysToNodes.entrySet()) {
      Address address=e.getKey();
      Collection<KIn> keys=e.getValue();
      if (address.equals(rpc.getAddress())) {
        cmd=buildMapCombineCommand(taskId.toString(),clone(mapper),clone(combiner),keys,true,useCompositeKeys);
      }
 else {
        cmd=buildMapCombineCommand(taskId.toString(),mapper,combiner,keys,true,useCompositeKeys);
      }
      MapTaskPart<Set<KOut>> part=createTaskMapPart(cmd,address,true);
      part.execute();
      futures.add(part);
    }
  }
  try {
    for (    MapTaskPart<Set<KOut>> mapTaskPart : futures) {
      Set<KOut> result=null;
      try {
        result=mapTaskPart.get();
      }
 catch (      ExecutionException ee) {
        Throwable cause=ee.getCause();
        if (cause instanceof org.infinispan.util.concurrent.TimeoutException) {
          throw new ExecutionException("Map phase executing at " + mapTaskPart.getAddress() + " did not complete within "+ rpcOptionsBuilder.timeout(TimeUnit.SECONDS)+ " sec timeout",cause);
        }
 else {
          throw ee;
        }
      }
      mapPhasesResult.addAll(result);
    }
  }
  finally {
    cancellableTasks.clear();
  }
  return mapPhasesResult;
}
