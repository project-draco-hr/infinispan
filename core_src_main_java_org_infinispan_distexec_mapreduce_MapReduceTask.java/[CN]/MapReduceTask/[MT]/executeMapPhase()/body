{
  RpcManager rpc=cache.getRpcManager();
  MapCombineCommand<KIn,VIn,KOut,VOut> cmd=null;
  Set<KOut> mapPhasesResult=new HashSet<KOut>();
  List<MapTaskPart<Set<KOut>>> futures=new ArrayList<MapTaskPart<Set<KOut>>>();
  if (inputTaskKeysEmpty()) {
    for (    Address target : rpc.getMembers()) {
      if (target.equals(rpc.getAddress())) {
        cmd=buildMapCombineCommand(taskId.toString(),clone(mapper),clone(combiner),getIntermediateCacheName(),null,true,useIntermediateSharedCache());
      }
 else {
        cmd=buildMapCombineCommand(taskId.toString(),mapper,combiner,getIntermediateCacheName(),null,true,useIntermediateSharedCache());
      }
      MapTaskPart<Set<KOut>> part=createTaskMapPart(cmd,target,true);
      part.execute();
      futures.add(part);
    }
  }
 else {
    Map<Address,? extends Collection<KIn>> keysToNodes=mapKeysToNodes(keys);
    for (    Entry<Address,? extends Collection<KIn>> e : keysToNodes.entrySet()) {
      Address address=e.getKey();
      Collection<KIn> keys=e.getValue();
      if (address.equals(rpc.getAddress())) {
        cmd=buildMapCombineCommand(taskId.toString(),clone(mapper),clone(combiner),getIntermediateCacheName(),keys,true,useIntermediateSharedCache());
      }
 else {
        cmd=buildMapCombineCommand(taskId.toString(),mapper,combiner,getIntermediateCacheName(),keys,true,useIntermediateSharedCache());
      }
      MapTaskPart<Set<KOut>> part=createTaskMapPart(cmd,address,true);
      part.execute();
      futures.add(part);
    }
  }
  try {
    for (    MapTaskPart<Set<KOut>> mapTaskPart : futures) {
      Set<KOut> result=null;
      try {
        result=mapTaskPart.get();
      }
 catch (      ExecutionException ee) {
        throw new MapReduceException("Map phase failed ",ee.getCause());
      }
      mapPhasesResult.addAll(result);
    }
  }
  finally {
    cancellableTasks.clear();
  }
  return mapPhasesResult;
}
