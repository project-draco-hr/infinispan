{
  RpcManager rpc=cache.getRpcManager();
  String destCache=getIntermediateCacheName();
  Cache<Object,Object> dstCache=cache.getCacheManager().getCache(destCache);
  Map<Address,? extends Collection<KOut>> keysToNodes=mapKeysToNodes(dstCache.getAdvancedCache().getDistributionManager(),allMapPhasesResponses,useCompositeKeys);
  Map<KOut,VOut> reduceResult=new HashMap<KOut,VOut>();
  List<ReduceTaskPart<Map<KOut,VOut>>> reduceTasks=new ArrayList<ReduceTaskPart<Map<KOut,VOut>>>();
  ReduceCommand<KOut,VOut> reduceCommand=null;
  for (  Entry<Address,? extends Collection<KOut>> e : keysToNodes.entrySet()) {
    Address address=e.getKey();
    Collection<KOut> keys=e.getValue();
    if (address.equals(rpc.getAddress())) {
      reduceCommand=buildReduceCommand(resultCache,taskId.toString(),destCache,clone(reducer),keys,useCompositeKeys);
    }
 else {
      reduceCommand=buildReduceCommand(resultCache,taskId.toString(),destCache,reducer,keys,useCompositeKeys);
    }
    ReduceTaskPart<Map<KOut,VOut>> part=createReducePart(reduceCommand,address,destCache);
    part.execute();
    reduceTasks.add(part);
  }
  try {
    for (    ReduceTaskPart<Map<KOut,VOut>> reduceTaskPart : reduceTasks) {
      Map<KOut,VOut> result=null;
      try {
        result=reduceTaskPart.get();
      }
 catch (      ExecutionException ee) {
        Throwable cause=ee.getCause();
        if (cause instanceof org.infinispan.util.concurrent.TimeoutException) {
          throw new ExecutionException("Reduce phase executing at " + reduceTaskPart.getAddress() + " did not complete within "+ rpcOptionsBuilder.timeout(TimeUnit.SECONDS)+ " sec timeout",cause);
        }
 else {
          throw ee;
        }
      }
      reduceResult.putAll(result);
    }
  }
  finally {
    cancellableTasks.clear();
  }
  return reduceResult;
}
