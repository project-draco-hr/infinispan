{
  RpcManager rpc=cache.getRpcManager();
  String destCache=getIntermediateCacheName();
  Cache<Object,Object> dstCache=cache.getCacheManager().getCache(destCache);
  Map<Address,? extends Collection<KOut>> keysToNodes=mapKeysToNodes(dstCache.getAdvancedCache().getDistributionManager(),allMapPhasesResponses,useIntermediateSharedCache);
  Map<KOut,VOut> reduceResult=new HashMap<KOut,VOut>();
  List<ReduceTaskPart<Map<KOut,VOut>>> reduceTasks=new ArrayList<ReduceTaskPart<Map<KOut,VOut>>>();
  ReduceCommand<KOut,VOut> reduceCommand=null;
  for (  Entry<Address,? extends Collection<KOut>> e : keysToNodes.entrySet()) {
    Address address=e.getKey();
    Collection<KOut> keys=e.getValue();
    if (address.equals(rpc.getAddress())) {
      reduceCommand=buildReduceCommand(resultCache,taskId.toString(),destCache,clone(reducer),keys,useIntermediateSharedCache);
    }
 else {
      reduceCommand=buildReduceCommand(resultCache,taskId.toString(),destCache,reducer,keys,useIntermediateSharedCache);
    }
    ReduceTaskPart<Map<KOut,VOut>> part=createReducePart(reduceCommand,address,destCache);
    part.execute();
    reduceTasks.add(part);
  }
  try {
    for (    ReduceTaskPart<Map<KOut,VOut>> reduceTaskPart : reduceTasks) {
      Map<KOut,VOut> result=null;
      try {
        result=reduceTaskPart.get();
      }
 catch (      ExecutionException ee) {
        throw new MapReduceException("Reduce phase failed",ee.getCause());
      }
      reduceResult.putAll(result);
    }
  }
  finally {
    cancellableTasks.clear();
  }
  return reduceResult;
}
