{
  RpcManager rpc=cache.getRpcManager();
  MapCombineCommand<KIn,VIn,KOut,VOut> cmd=null;
  Map<KOut,List<VOut>> mapPhasesResult=new HashMap<KOut,List<VOut>>();
  List<MapTaskPart<Map<KOut,List<VOut>>>> futures=new ArrayList<MapTaskPart<Map<KOut,List<VOut>>>>();
  Address localAddress=clusteringDependentLogic.getAddress();
  if (inputTaskKeysEmpty()) {
    List<Address> targets;
    if (isLocalOnly) {
      targets=Collections.singletonList(localAddress);
    }
 else {
      targets=rpc.getMembers();
    }
    for (    Address target : targets) {
      if (target.equals(localAddress)) {
        cmd=buildMapCombineCommand(taskId.toString(),clone(mapper),clone(combiner),getIntermediateCacheName(),null,false,false);
      }
 else {
        cmd=buildMapCombineCommand(taskId.toString(),mapper,combiner,getIntermediateCacheName(),null,false,false);
      }
      MapTaskPart<Map<KOut,List<VOut>>> part=createTaskMapPart(cmd,target,false);
      part.execute();
      futures.add(part);
    }
  }
 else {
    Map<Address,? extends Collection<KIn>> keysToNodes=mapKeysToNodes(keys);
    for (    Entry<Address,? extends Collection<KIn>> e : keysToNodes.entrySet()) {
      Address address=e.getKey();
      Collection<KIn> keys=e.getValue();
      if (address.equals(localAddress)) {
        cmd=buildMapCombineCommand(taskId.toString(),clone(mapper),clone(combiner),getIntermediateCacheName(),keys,false,false);
      }
 else {
        cmd=buildMapCombineCommand(taskId.toString(),mapper,combiner,getIntermediateCacheName(),keys,false,false);
      }
      MapTaskPart<Map<KOut,List<VOut>>> part=createTaskMapPart(cmd,address,false);
      part.execute();
      futures.add(part);
    }
  }
  try {
    for (    MapTaskPart<Map<KOut,List<VOut>>> mapTaskPart : futures) {
      Map<KOut,List<VOut>> result=null;
      try {
        result=mapTaskPart.get();
      }
 catch (      ExecutionException ee) {
        Throwable cause=ee.getCause();
        if (cause instanceof org.infinispan.util.concurrent.TimeoutException) {
          throw new ExecutionException("Map phase executing at " + mapTaskPart.getAddress() + " did not complete within "+ rpcOptionsBuilder.timeout(TimeUnit.SECONDS)+ " sec timeout",cause);
        }
 else {
          throw ee;
        }
      }
      mergeResponse(mapPhasesResult,result);
    }
  }
  finally {
    cancellableTasks.clear();
  }
  MapReduceTaskLifecycleService taskLifecycleService=MapReduceTaskLifecycleService.getInstance();
  log.tracef("For m/r task %s invoking %s locally",taskId,reducer);
  try {
    taskLifecycleService.onPreExecute(reducer,cache);
    for (    Entry<KOut,List<VOut>> e : mapPhasesResult.entrySet()) {
      reducedResult.put(e.getKey(),reducer.reduce(e.getKey(),e.getValue().iterator()));
    }
  }
  finally {
    taskLifecycleService.onPostExecute(reducer);
  }
}
