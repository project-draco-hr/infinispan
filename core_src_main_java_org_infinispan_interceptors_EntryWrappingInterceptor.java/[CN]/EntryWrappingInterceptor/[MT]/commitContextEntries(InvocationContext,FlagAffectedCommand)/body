{
  boolean isPutForStateTransfer=command == null ? isFromStateTransfer(ctx) : isFromStateTransfer(command);
  if (!isPutForStateTransfer && stateConsumer != null && ctx instanceof TxInvocationContext && ((TxInvocationContext)ctx).getCacheTransaction().hasModification(ClearCommand.class)) {
    stateConsumer.stopApplyingState();
  }
  if (ctx instanceof SingleKeyNonTxInvocationContext) {
    SingleKeyNonTxInvocationContext singleKeyCtx=(SingleKeyNonTxInvocationContext)ctx;
    commitEntryIfNeeded(ctx,command,singleKeyCtx.getKey(),singleKeyCtx.getCacheEntry(),isPutForStateTransfer);
  }
 else {
    Set<Map.Entry<Object,CacheEntry>> entries=ctx.getLookedUpEntries().entrySet();
    Iterator<Map.Entry<Object,CacheEntry>> it=entries.iterator();
    final Log log=getLog();
    while (it.hasNext()) {
      Map.Entry<Object,CacheEntry> e=it.next();
      CacheEntry entry=e.getValue();
      if (!commitEntryIfNeeded(ctx,command,e.getKey(),entry,isPutForStateTransfer)) {
        if (trace) {
          if (entry == null)           log.tracef("Entry for key %s is null : not calling commitUpdate",e.getKey());
 else           log.tracef("Entry for key %s is not changed(%s): not calling commitUpdate",e.getKey(),entry);
        }
      }
    }
  }
}
