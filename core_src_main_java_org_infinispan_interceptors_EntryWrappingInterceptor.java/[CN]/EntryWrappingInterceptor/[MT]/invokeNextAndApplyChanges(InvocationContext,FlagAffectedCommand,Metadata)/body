{
  final Object result=invokeNextInterceptor(ctx,command);
  if (!ctx.isInTxScope()) {
    stateTransferLock.acquireSharedTopologyLock();
    try {
      if (stateConsumer != null && stateConsumer.getCacheTopology() != null) {
        boolean isSync=(cacheConfiguration.clustering().cacheMode().isSynchronous() && !command.hasFlag(Flag.FORCE_ASYNCHRONOUS)) || command.hasFlag(Flag.FORCE_SYNCHRONOUS);
        int commandTopologyId=command.getTopologyId();
        int currentTopologyId=stateConsumer.getCacheTopology().getTopologyId();
        if (isSync && currentTopologyId != commandTopologyId && commandTopologyId != -1) {
          if (trace)           log.tracef("Cache topology changed while the command was executing: expected %d, got %d",commandTopologyId,currentTopologyId);
          throw new OutdatedTopologyException("Cache topology changed while the command was executing: expected " + commandTopologyId + ", got "+ currentTopologyId);
        }
      }
      commitContextEntries(ctx,command,metadata);
    }
  finally {
      stateTransferLock.releaseSharedTopologyLock();
    }
  }
  if (trace)   log.tracef("The return value is %s",result);
  return result;
}
