{
  final Object result=invokeNextInterceptor(ctx,command);
  if (!ctx.isInTxScope()) {
    stateTransferLock.acquireSharedTopologyLock();
    try {
      if (command instanceof WriteCommand) {
        WriteCommand writeCommand=(WriteCommand)command;
        boolean isSync=(cacheConfiguration.clustering().cacheMode().isSynchronous() && !command.hasFlag(Flag.FORCE_ASYNCHRONOUS)) || command.hasFlag(Flag.FORCE_SYNCHRONOUS);
        if (writeCommand.isSuccessful() && stateConsumer != null && stateConsumer.getCacheTopology() != null) {
          int commandTopologyId=command.getTopologyId();
          int currentTopologyId=stateConsumer.getCacheTopology().getTopologyId();
          if (isSync && currentTopologyId != commandTopologyId && commandTopologyId != -1) {
            if (!ctx.isOriginLocal() || !(command instanceof DataCommand) || ctx.hasLockedKey(((DataCommand)command).getKey())) {
              if (trace)               log.tracef("Cache topology changed while the command was executing: expected %d, got %d",commandTopologyId,currentTopologyId);
              writeCommand.setValueMatcher(writeCommand.getValueMatcher().matcherForRetry());
              throw new OutdatedTopologyException("Cache topology changed while the command was executing: expected " + commandTopologyId + ", got "+ currentTopologyId);
            }
          }
        }
      }
      commitContextEntries(ctx,command,metadata);
    }
  finally {
      stateTransferLock.releaseSharedTopologyLock();
    }
  }
  if (trace)   log.tracef("The return value is %s",result);
  return result;
}
