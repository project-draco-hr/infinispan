{
  final PathAddress address=PathAddress.pathAddress(operation.get(OP_ADDR));
  final String name=address.getLastElement().getValue();
  protocolStackSanityCheck(name,model);
  List<Property> orderedProtocols=getOrderedProtocolPropertyList(model);
  ModelNode resolvedValue=null;
  ModelNode transport=model.get(ModelKeys.TRANSPORT,ModelKeys.TRANSPORT_NAME);
  final String type=(resolvedValue=TransportResourceDefinition.TYPE.resolveModelAttribute(context,transport)).isDefined() ? resolvedValue.asString() : null;
  final boolean shared=TransportResourceDefinition.SHARED.resolveModelAttribute(context,transport).asBoolean();
  final String machine=(resolvedValue=TransportResourceDefinition.MACHINE.resolveModelAttribute(context,transport)).isDefined() ? resolvedValue.asString() : null;
  final String rack=(resolvedValue=TransportResourceDefinition.RACK.resolveModelAttribute(context,transport)).isDefined() ? resolvedValue.asString() : null;
  final String site=(resolvedValue=TransportResourceDefinition.SITE.resolveModelAttribute(context,transport)).isDefined() ? resolvedValue.asString() : null;
  final String timerExecutor=(resolvedValue=TransportResourceDefinition.TIMER_EXECUTOR.resolveModelAttribute(context,transport)).isDefined() ? resolvedValue.asString() : null;
  final String threadFactory=(resolvedValue=TransportResourceDefinition.THREAD_FACTORY.resolveModelAttribute(context,transport)).isDefined() ? resolvedValue.asString() : null;
  final String diagnosticsSocketBinding=(resolvedValue=TransportResourceDefinition.DIAGNOSTICS_SOCKET_BINDING.resolveModelAttribute(context,transport)).isDefined() ? resolvedValue.asString() : null;
  final String defaultExecutor=(resolvedValue=TransportResourceDefinition.DEFAULT_EXECUTOR.resolveModelAttribute(context,transport)).isDefined() ? resolvedValue.asString() : null;
  final String oobExecutor=(resolvedValue=TransportResourceDefinition.OOB_EXECUTOR.resolveModelAttribute(context,transport)).isDefined() ? resolvedValue.asString() : null;
  final String transportSocketBinding=(resolvedValue=TransportResourceDefinition.SOCKET_BINDING.resolveModelAttribute(context,transport)).isDefined() ? resolvedValue.asString() : null;
  Transport transportConfig=new Transport(type);
  transportConfig.setShared(shared);
  transportConfig.setTopology(site,rack,machine);
  initProtocolProperties(transport,transportConfig);
  Relay relayConfig=null;
  List<Map.Entry<String,Injector<Channel>>> channels=new LinkedList<Map.Entry<String,Injector<Channel>>>();
  if (model.hasDefined(ModelKeys.RELAY)) {
    final ModelNode relay=model.get(ModelKeys.RELAY,ModelKeys.RELAY_NAME);
    final String siteName=RelayResourceDefinition.SITE.resolveModelAttribute(context,relay).asString();
    relayConfig=new Relay(siteName);
    initProtocolProperties(relay,relayConfig);
    if (relay.hasDefined(ModelKeys.REMOTE_SITE)) {
      List<RemoteSiteConfiguration> remoteSites=relayConfig.getRemoteSites();
      for (      Property remoteSiteProperty : relay.get(ModelKeys.REMOTE_SITE).asPropertyList()) {
        final String remoteSiteName=remoteSiteProperty.getName();
        final String clusterName=RemoteSiteResourceDefinition.CLUSTER.resolveModelAttribute(context,remoteSiteProperty.getValue()).asString();
        final String stack=RemoteSiteResourceDefinition.STACK.resolveModelAttribute(context,remoteSiteProperty.getValue()).asString();
        RemoteSite remoteSite=new RemoteSite(remoteSiteName,clusterName);
        remoteSites.add(remoteSite);
        channels.add(new AbstractMap.SimpleImmutableEntry<String,Injector<Channel>>(stack,remoteSite.getChannelInjector()));
      }
    }
  }
  Sasl saslConfig=null;
  if (model.hasDefined(ModelKeys.SASL)) {
    final ModelNode sasl=model.get(ModelKeys.SASL,ModelKeys.SASL_NAME);
    final String clusterRole=(resolvedValue=SaslResourceDefinition.CLUSTER_ROLE.resolveModelAttribute(context,sasl)).isDefined() ? resolvedValue.asString() : null;
    final String securityRealm=SaslResourceDefinition.SECURITY_REALM.resolveModelAttribute(context,sasl).asString();
    final String mech=SaslResourceDefinition.MECH.resolveModelAttribute(context,sasl).asString();
    saslConfig=new Sasl(securityRealm,mech,clusterRole);
    initProtocolProperties(sasl,saslConfig);
  }
  ProtocolStack stackConfig=new ProtocolStack(name,transportConfig,relayConfig,saslConfig);
  List<Map.Entry<Protocol,String>> protocolSocketBindings=new ArrayList<Map.Entry<Protocol,String>>(orderedProtocols.size());
  for (  Property protocolProperty : orderedProtocols) {
    ModelNode protocol=protocolProperty.getValue();
    final String protocolType=(resolvedValue=ProtocolResourceDefinition.TYPE.resolveModelAttribute(context,protocol)).isDefined() ? resolvedValue.asString() : null;
    Protocol protocolConfig=new Protocol(protocolType);
    initProtocolProperties(protocol,protocolConfig);
    stackConfig.getProtocols().add(protocolConfig);
    final String protocolSocketBinding=(resolvedValue=ProtocolResourceDefinition.SOCKET_BINDING.resolveModelAttribute(context,protocol)).isDefined() ? resolvedValue.asString() : null;
    protocolSocketBindings.add(new AbstractMap.SimpleImmutableEntry<Protocol,String>(protocolConfig,protocolSocketBinding));
  }
  ServiceController<ChannelFactory> cfsController=installChannelFactoryService(context.getServiceTarget(),name,diagnosticsSocketBinding,defaultExecutor,oobExecutor,timerExecutor,threadFactory,transportSocketBinding,protocolSocketBindings,transportConfig,stackConfig,channels,saslConfig,verificationHandler);
  if (newControllers != null) {
    newControllers.add(cfsController);
  }
}
