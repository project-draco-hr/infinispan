{
switch (this.configurationTemplateMode) {
case NONE:
    this.logger.debug("ConfigurationTemplateMode is NONE: starting with a fresh Configuration");
  if (this.infinispanEmbeddedCacheManager.getCacheNames().contains(cacheName)) {
    throw new IllegalStateException("Cannot use ConfigurationTemplateMode NONE: a cache named [" + cacheName + "] has already been defined.");
  }
ConfigurationBuilder newConfiguration=new ConfigurationBuilder();
this.configurationOverrides.applyOverridesTo(newConfiguration);
this.infinispanEmbeddedCacheManager.defineConfiguration(cacheName,newConfiguration.build());
break;
case NAMED:
this.logger.debug("ConfigurationTemplateMode is NAMED: starting with a named Configuration [" + cacheName + "]");
org.infinispan.configuration.cache.Configuration cacheConfiguration=infinispanEmbeddedCacheManager.getCacheConfiguration(cacheName);
if (cacheConfiguration != null) {
ConfigurationBuilder newNamedConfig=new ConfigurationBuilder();
newNamedConfig.read(cacheConfiguration);
this.infinispanEmbeddedCacheManager.defineConfiguration(cacheName,newNamedConfig.build());
}
break;
case DEFAULT:
this.logger.debug("ConfigurationTemplateMode is DEFAULT: starting with default Configuration");
if (this.infinispanEmbeddedCacheManager.getCacheNames().contains(cacheName)) {
throw new IllegalStateException("Cannot use ConfigurationTemplateMode DEFAULT: a cache named [" + cacheName + "] has already been defined.");
}
break;
default :
throw new IllegalStateException("Unknown ConfigurationTemplateMode: " + this.configurationTemplateMode);
}
return this.infinispanEmbeddedCacheManager.getCache(cacheName);
}
